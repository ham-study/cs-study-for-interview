# TCP와 UDP

<br>

<details>
    <summary><b>TCP 프로토콜에 대해 설명해 주세요,</b></summary>
    <br>
    OSI 7계층에서 4계층인 전송계층에서 사용하는 프로토콜로서 신뢰성있는 데이터 통신을 가능하게 합니다. <br>
    양방향 통신을 하며, 데이터를 순차 전송을 보장합니다. 그리고 TCP는 수신측의 버퍼 오버 플로우를 막기 위한 흐름제어와 네트워크 과부하를 방지하는 혼잡제어의 역할을 수행합니다. 
</details>

<br>

<details>
    <summary><b>UDP 프로토콜에 대해 설명해 주세요.</b></summary>
    <br>
    TCP보다 신뢰성은 떨어지지만, 전송 속다가 일반적으로 빠른 프로토콜입니다. 서로 연결된 네트워크를 통해 팻킷 데이터그램을 전달하는 목적으로 사용합니다. <br>
    그리고 실시간 전송이 필요한 서비스에서 주로 사용합니다. 예를 들면 실시간 유트브 스트림을 예로 들 수 있습니다. 
</details>

<br>

<details>
    <summary><b>흐름제어에 대해 설명해 주세요.</b></summary>
    <br>
    전송자가 데이터를 만드는 속도와 수신자가 데이터를 사용의 속도의 균현을 맞추는 것을 흐름제어라고 할 수 있습니다. 흐름제어를 하기 위해서는 수신측의 수신 위도우 변수를 이용합니다. 
    <br> 흐름제어의 방법은 2가지 입니다. 첫번째는 Stop and Wait 입니다. 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있습니다. 이러한 구조로 인해 비효율적이라는 단점이 있습니다.
    <br> 두번쨰는 Sliding Window 입니다. 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법입니다. 따라서 송신측에서는 ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있습니다.
</details>

<br>

<details>
    <summary><b>혼잡제어에 대해 설명해 주세요.</b></summary>
    <br>
    공유자원인 네트워크망의 혼잡을 악화시켜 통신에 충돌이 나게 하는 것을 줄이고, 한정된 자원을 잘 분배하여 원활히 돌아갈 수 있도록 제어하는 것을 혼잡 제어라고 합니다.
    <br>
    방법은 2가지가 있습니다. 
    첫번쨰, AIMD방식은 네트워크에 문제가 없다면 혼잡 윈도우 크기를 1씩증가시키고 혼잡하다면 절반으로 줄이는 방식입니다. 나중에 네트워크에 진입하는 쪽이 불리하지만 시간이 지남에 따라 윈도우 크기가 평형상태로 수렴합니다. 네트워크에 문제가 없는 상황에서 초반에 대역폭을 제대로 활용하는데 시간이 걸린다는 단점이 있습니다.
    <br>
    두번쨰, Slow start 방식은 네트워크에 문제가 없다면 지수적으로 윈도우 크기를 늘리고 혼잡하다면 크기를 1로 만드는 방식입니다. 혼잡제어 정책에는 3ack duplicate, time out, threshold가 사용됩니다. 3ack duplicate는 네트워크에 문제가 발생해 3번의 같은 패킷 번호로 ack가 응답한 상황을 의미합니다. 이런 상황에서는 time out을 기다리지 않고 빠른 재전송을 사용합니다. Threshold는 혼잡 윈도우크기의 임계점을 말합니다. 혼잡제어 정책은 여러가지가 있지만 기본적으로 네트워크가 혼잡하면 윈도우 사이즈를 줄이고 아니면 늘리는 철학을 가지며 3ack duplicate, time out, threshold등을 고려해 장애 상황판단하고 윈도우 사이즈를 조절합니다.
</details>

<br>

<details>
    <summary><b>오류제어에 대해 설명해 주세요.</b></summary>
    <br>
    오류 검출과 재전송을 포함하며, ARQ(Automatic Repeat Request) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구하는 것을 흐름제어라고 합니다.
    <br>
    3가지 방식이 있습니다. 첫번째, Stop and Wait은 송신 측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무에 따라 ACK 혹은 NAK(Negative Acknowledgement)를 보내는 방식입니다.
    <br>
    두번째, Go back N방식은 오류가 난 패킷 번호로부터 전체를 재전송하는 방식을 말합니다. 오류가 발생한 패킷 뒤에 정상적으로 도착한 패킷은 폐기되며 재전송되는 패킷을 기다립니다. 
    <br>
    세번쨰, Selective Repeat방식은 오류가 발생한 패킷만을 재전송합니다. 두 방식의 차이점은 Go Back N방식은 오류가 발생한 패킷 이후에 전체를 재전송하여 비효율적인면이 있지만 따로 버퍼를 관리가 필요 없습니다. 
    Selective Repeat 방식은 오류가 발생한 패킷을 다시 재정렬해야하기 때문에 버퍼를 관리해야합니다.
</details>

<br>

<details>
    <summary><b>(4 way handshake) 클라이언트에서 FIN 패킷을 보내고, 서버에서 ACK 패킷을 보낸 후 FIN 패킷을 보낸 상황이라고 가정합시다. 이때 클라인트에서 ACK패킷을 전송했는데, 서버에서 받지 못했다면 어떻게 될까요?</b></summary>
    <br>
    두가지 경우가 있을 것 같습니다. 첫번쨰는 서버에서 ACK 패킷을 받지 못했다는 것을 클라이언트에 알려주어 다시 패킷을 보낼 줄 수 있을 것 같습니다. <br>
    그리고 두번째는 time way 상태인 클라이언트가 일정 시간이 되어 종료되는 상황입니다. 그렇게 되면 서버는 ACK 패킷을 받지 못한채, 타임아웃으로 종료될 것 같습니다.
</details>

<br>

<details>
    <summary><b>넷플릭스는 TCP일까요? UDP일까요? </b></summary>
    <br>
    넷플릭스는 TCP 입니다. 고화질의 영상을 사용자가 시청하는 것이 중요하기 때문입니다. 만약 실시간 전송이 중요하다면, UDP로 처리하는 것이 좋을 것 같습니다. 
</details>

