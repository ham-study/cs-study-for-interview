# 자바 키워드 3

<br>

## static

- 일반적인 변수는 jvm 힙 영역에 저장되는 반면, static 변수는 메소드 영역에 저장된다
- 메소드 영역은 가비지 컬렉터가 동작하지 않으므로, 프로그램 종료시까지 할당된 채로 존재함
    - 모든 인스턴스가 같은 값을 유지해야할 때 사용
    - 유틸 클래스처럼 인스턴스를 생성할 필요가 없는 클래스에서 사용. (할당없이 빠른 호출)

<br>

## final

- 객체를 단 한번만 할당하는 제어자. 두번 할당하려하면 컴파일 오류 발생
- 변수, 메소드, 클래스에 적용할 수 있음
    - 변수는 상수처럼 고정하여 사용
    - 메소드는 Overriding 불가
    - 클래스는 상속 불가
        - ex) Wrapper class
        - 하지만 내부 값은 변경 가능

### Effectively final

- Java 8 에 추가된 syntactic sugar의 일종 (문법적인 의미)
- 변수가 초기화 된 이후 값이 한번도 변경되지 않았다면 Final과 동일하게 컴파일러에서 처리하는 것.

<br>

## generic

- 객체 생성 시점에 타입을 결정하여, 유연한 설계를 가능하게 하는 기능
- 컴파일시 타입을 미리 체크한다
- ex) Collection 라이브러리

### Object와의 차이

- Object는 객체 생성시 타입을 지정하지 않는다.
    - generic은 객체 생성시 타입을 지정해준다
- Object를 사용하면 값을 리턴받을 때마다 캐스팅을 해줘야 하고, 개발자가 실수할 수도 있다
    - generic을 사용하면 객체 생성시 타입을 지정했기에 캐스팅이 필요 없다.
- Object는 런타임시 오류가 발생한다
    - generic은 컴파일 시점에서 오류를 체크할수 있다.

<br>

## Annotation

- 주석의 의미로 특별한 의미를 부여하거나 기능을 수행하도록 하는 메타데이터
    - javadoc에서 파생되었음

### 기능

- 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공
- 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공
- 런타임시 특정 기능을 실행하도록 정보를 제공

### 종류

- 표준 어노테이션 : 자바의 기본 제공 어노테이션
    - `@Override`, `@Deprecated` 등
- 메타 어노테이션 : 어노테이션을 위한 어노테이션
    - `@Target`, `@Retention` 등
- 마커 어노테이션 : 값을 지정할 필요가 없는 경우. 의미만 나타냄
    - `@Serializable`, `@Cloneable`, `@Test`

### 생성하기

```java
@Target()   // 적용 가능한 대상 종류 지정
@Retention( )   // 어노테이션 적용 시점 지정
public @interface 어노테이션 {
    타입 요소();
    String str(); default{};
}
```

- 정의는 인터페이스와 동일함
- 규칙
    - 상속 불가
    - 요소 타입은 기본형, String, enum, 어노테이션, Class만 허용
    - ()안에 매개변수 선언 불가
    - 예외 선언 불가
    - 요소를 타입 매개변수로 정의 불가

<br>

## Enum



<br>

## Lambda

- 익명함수를 뜻하고, 그 자체로 일급객체가 되며 매개변수처럼 사용할 수 있다.
- 람다함수 내부에서는 외부 지역 변수를 사용할 수 없음
    - but `final` or `Effectively final` 변수는 사용할 수 있다
    - 람다 실행시 임시 스레드가 따로 생성되므로, 스택영역을 공유하지 않기 때문
    - `final` 변수 또한 공유하는 것이 아닌 람다식에서 '복사'하여 사용하는 것.

### Functional Interface

- **추상메소드**가 하나만 존재하는 인터페이스
    - 인터페이스가 포함하는 메소드가 여러개여도 추상메소드만 하나면 조건 만족
    - `@FunctionalInterface` 어노테이션을 달아준다.
- Functional Interface의 메소드를 람다식으로 재정의하여 사용한다
- 여러 종류가 있음

|종류|	인자값	|리턴값	|용도|
|---|---|---|---|
|Runnable	|X	|X	|실행시키기|
|Supplier	|X	|T	|데이터 생성|
|Consumer	|T	|X	|데이터 사용|
|Function	|T	|R	|타입 변환|
|Predicate	|T	|bool	|조건식|

<br>

## Stream

- 컬렉션이나 배열의 요소를 내부적으로 반복 처리하는 기능
- 원본 객체를 변경하지 않는다.
    - 원본 객체를 참조하여 어떠한 새로운 결과를 도출해 내는것
- 일회용으로만 사용가능하다
    - stream 객체는 한번 선언하면 재사용이 불가능하다.
- 3가지 단계를 거쳐 사용된다
    - stream 생성
    - 중개 연산 : filter-map API를 사용하여 지연(lazy) 연산을 통해 선응을 최적화함
    - 최종 연산 : 이때 실제로 연산이 이루어지며, 지연됐던 모든 연산을 처리한다
- lambda와 stream의 장점
    - 불필요한 코드를 줄여 가독성을 좋게한다.
    - 내부 연산으로 병렬 처리가 가능하다
- 단점
    - 디버깅이 힘들다
    - 예외처리도 힘들다.

<br>

## Reflection

- 객체에서 클래스의 정보를 가져와 분석할 수 있도록하는 기법
- JVM에서의 **런타임시** 동작을 검사하고 수정하기 위해 사용된다
    - 이미 로딩된 클래스에서 동일한 새로운 클래스를 동적로딩하여 사용할 수 있도록 함

```java
Class class = "객체".getClass();
```

<br>

## Proxy

<img width="400" src="https://user-images.githubusercontent.com/71180414/156297193-656535e5-0bb1-4ffc-918e-bf4522208867.png">

- 타겟의 기능을 확장하거나 접근을 제어하기 위한 목적으로 사용되는 기법
- 동작원리
    - 특정 클래스를 Proxy 클래스에서 인스턴스로 선언
    - 해당 인스턴스가 동작할때 추가적인 행위를 덧붙이도록 한다
- 데코레이터 패턴에서 사용된다

### Dynamic Proxy

- Reflection API를 사용해 자동으로 프록시를 구현해주는 것
- AOP에서 사용된다고 ....?