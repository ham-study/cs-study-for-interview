# 디자인패턴

<br>

## 생성 패턴

### 팩토리 메소드 패턴

- 객체의 생성을 특정 메소드에게 위임하는 패턴
- 장점 : SRP, OCP 만족 -> 결합도 낮춤
- 단점 : 팩토리 클래스를 만들어야함. (이건 정적 팩토리 메소드로 해결됨)

### 싱글톤 패턴

- 객체를 static으로 선언하여 단 하나의 객체만 사용하는 패턴 
- 장점 : 메모리를 절약하고 데이터 공유가 쉬움
- 단점 : SRP 원칙 위반 멀티스레드 환경에서 동시성 문제가 발생

<br>

## 구조 패턴

### 프록시 패턴

- 객체를 직접 호출하는것이 아닌 프록시를 통해 간접 호출하는 패턴
- 장점 : OCP 만족, 클라이언트는 무엇이 동작하는지 몰라도 됨, 실제 객체가 없어도 프록시 먼저 동작
- 단점 : 응답 지연

### 데코레이터 패턴

- 프록시를 통해 객체의 기능을 추가하거나 꾸미는 것
- 장점 : SRP 만족, 기능추가에 새 객체 추가 안해도 됨
- 단점 : 데코레이터 적용 후엔 해제가 어려움, 적용 순서가 독립적이기 힘듬
- 프록시와 데코레이터의 차이점
    - 둘다 프록시를 사용하는 점에서 구조 자체는 비슷하지만 목적에 차이가 있음
    - 프록시 패턴 : 접근 제어가 목적 / 컴파일시 결정
    - 데코레이터 패턴 : 새로운 기능 추가가 목적 / 런타임시 결정

### 어댑터 패턴

- 기존 인터페이스에 호환되지 않는 새로운 인터페이스를 연결할 때 사용하는 패턴
- 장점 : SRP, OCP 만족
- 단점 : 코드의 복잡성 증가

<br>

## 행위 패턴

### 템플릿 메소드 패턴

- 추상 클래스를 사용하여 특정 메소드는 하위 클래스에서 구현하도록 하는 패턴
- 장점 : 코드 중복을 줄일 수 있음
- 단점 : 상위 클래스 변경시 하위 클래스에 영향

### 옵저버 패턴

- 하나의 Observable을 여러 Observer가 구독하고, 구독 객체에게는 동시에 알림을 보내는 패턴
- 장점 : OCP 만족, 느슨한 결합으로 결합도 낮음
- 단점 : 공평한 알림이 보장되지 않음

<br>

## 참고링크

- 프록시&데코레이터 : https://velog.io/@gmtmoney2357/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4Proxy-Pattern-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4Decorator-Pattern