# 객체지향

<br>

## 객체지향

- Object Oriented Programming
- 데이터를 추상화시켜 객체를 만들고, 객체에게 책임을 위임한다. 그리고 객체가 메시지를 주고받으며 상호작용하는 방식
- 객체가 책임을 가지기 때문에 코드의 재사용성이 높고 유지보수가 용이함

### 4가지 특징

- **캡슐화**
    - 객체가 스스로 동작하는 환경을 가지며 외부에 의존하지 않는다.
    - 외부의 간섭을 제한하며 정보를 은닉한다
- **추상화**
    - 현실 사물의 공통적인 특징을 파악하여 객체로 정의하는것
    - 상위 객체로 갈수록 더 추상적임
- **상속**
    - 상위 개념의 특징을 하위 개념이 물려받는 것
- **다형성**
    - 하나의 객체가 여러 형태를 가질 수 있는것

### 5원칙

- **단일책임 원칙**
    - SRP(Single responsibility principle)
    - 객체는 하나의 책임을 가져야 한다.
    - 객체가 수정되는 이유는 그 객체에게 있어야 한다
- **개방-폐쇄 원칙**
    - OCP(Open/closed principle)
    - 처음부터 수정은 지양, 확장은 지향하도록 설계하자
    - 변경이 일어나도 기존 객체를 수정하는 것이 아닌, 새로운 객체로 확장하는 방식이어야 함
- **리스코프 치환 원칙**
    - LSP(Liskov substitution principle)
    - 항상 상위 타입을 하위 타입으로 변경 가능해야 한다
    - 부모 객체를 자식 객체로 바꿔도 문제 없어야 함 -> 자식이 부모의 원칙을 따라야한다.
    - `Overloading`시 원칙을 위반하게 된다
- **인터페이스 분리 원칙**
    - ISP(Interface segregation principle)
    - 인터페이스는 자신을 사용하는 클라이언트 기준으로 분리해야 한다.
    - ex) `클라이언트3명 - 필통` => `클라이언트 1명씩 - (연필, 지우개, 샤프)필통`
- **의존 역전 원칙**
    - DIP(Dependency inversion principle)
    - 상위 모듈이 하위 모듈의 구현에 의존해서는 안된다.
    - 상위 객체가 하위 객체가 변경된다해서 코드를 고치면 안됨(OSP 위반)
    - ex) `자동차 - 스노우타이어` => `자동차 - (스노우타이어, ...)타이어`

<br>

## 프로그래밍 패러다임

### 명령형 vs 선언형

- **명령형**
    - 무엇(What) 할건지를 나타내기 보다 어떻게(How)을 할 건지 설명하는 방식
    - 절차지향, 객체지향 프로그래밍
- **선언형**
    - 어떻게(How) 할건지를 나타내기 보다 무엇(What)을 할 건지 설명하는 방식
    - 함수형 프로그래밍

### 절차지향

- 데이터 흐름에 기반하여 작업의 진행순서대로 프로그래밍하는 기법
    - 순차적인 처리가 중요하고 프로그램 전체가 연결된다
    - 순서를 먼저 정하고 상위로부터 하위로 설계하므로 Top-Down 방식이다
- 장점
    - 컴퓨터 작업방식과 유사하여 좀 더 빠름
- 단점
    - 코드의 결합도가 매우 높다

### 객체지향

- 추상화를 통해 작은 객체를 만들고 객체를 조합하여 설계하는 방식
    - Bottom-Up 방식이다
- 장점
    - 높은 재사용성, 유지보수성
- 단점
    - 설계에 많은 시간 소요
    - 처리속도가 상대적으로 느림

### 함수형

- 문제를 작은 문제로 나누고, 작은 문제를 해결하는 순수함수를 사용하는 방식
    - 순수함수는 상태값을 가지지 않고 외부 의존성을 가지지 않는다 (side effect가 없음)
    - 프로그램 실행에 영향을 미치는 영역과 미치지 않는 영역을 분리할 수 있다.
    - 함수를 변수처럼 사용할 수 있어야한다 (lambda)
- 장점
    - 높은 재사용성, 가독성, 유지보수성
- 단점
    - 상태를 건드릴수 없음

<br>