# TCP, UDP

<br>

## TCP (Transmission Control Protocol)

- 전송계층에서 사용되는 프로토콜
- 패킷 유실이 없는 신뢰성을 보장하는 연결지향형 데이터 전송 프로토콜
- 데이터를 여러 패킷으로 나누고 수신측에서 재조합

### 헤더 구조

![image](https://user-images.githubusercontent.com/71180414/150239604-d3cbb930-8176-440f-ac75-3f66e6f26ed0.png)

- `Source Port` : 출발지 포트번호
- `Destination Port` : 목적지 포트번호
- `Sequence Number` : byte 단위로 순서화되는 번호(TCP 세그먼트의 첫번째 byte에 부여됨)이며 이것을 통해 신뢰성(*3Way Handshake) 및 흐름제어- (sliding Window) 기능을 제공하게 됩니다.
- `Acknowledgment Number` : 수신하기를 기대하는 다음 byte 번호 (마지막으로 수신에 성공한 번호의 +1)
- `Offset` : 헤더 길이 필드이며 IPv4와 마찬가지로 나누기 4 계산 후 2진수로 작성됨
- `Reserved` : 예약된 필드, 현재 사용되지 않음
- `Window` : 자신의 수신 버퍼 여유용량 크기를 통보하여 얼마만큼의 데이터를 받을 수 있는지 상대방에게 알려주어 흐름제어를 수행하게 되는 필드
- `TCP Flags `
   - U (Urgent) : 긴급 비트, 내가 지금 보내는 데이터가 우선순위가 높음. Urgnet Pointer와 세트
   - A (Ack) : 승인 비트, 물어본거에 대한 응답을 해줄 때 사용됨
   - P (Push) : 밀어넣기 비트, TCP 버퍼가 일정한 크기만큼 쌓여야 하는데 이거 상관없이 데이터를 계속 밀어 넣겠다
   - R (Reset) : 초기화 비트, 상대방과 연결이 되어있는 상태에서 어떤 문제 등이 발생하여 연결 상태를 리셋하게 됨
   - S (Syn) : 동기화 비트, 상대방과 연결을 시작할때 무조건 사용되는 플레그
   - F (Fin) : 종료 비트

### 3 way handshake

![image](https://user-images.githubusercontent.com/71180414/150244452-57f12123-997a-400f-82d7-ad598bf77818.png)

- 클라이언트와 서버간 통신을 시작하기 위해 서로의 상태를 확인하는 절차
    1. 클라이언트가 서버에 접속을 요청하는 SYN 패킷을 보낸다. / SYN와 ACK 응답을 기다리는 SYN_SENT 상태가 된다
    2. 서버는 SYN 요청을 받고 요청을 수락하는 SYN과 ACK 패킷으로 응답한다. / 이때 서버는 클라이언트의 ACK 패킷 응답을 기다리는 SYN_RECEIVED 상태가 된다.
    3. 클라이언트는 서버에게 ACK 패킷을 보내고 연결이 이루어진다. / 클라이언트와 서버는 ESTABLISHED 상태가 된다

### 4 way handshake

![image](https://user-images.githubusercontent.com/71180414/150244473-10f7201f-c744-4109-bd2e-92c769a9c685.png)

- 클라이언트와 서버간 통신을 종료하기 위해 서로의 상태를 확인하는 절차
    1. 클라이언트가 연결 종료를 알리는 FIN 패킷을 보낸다
    2. 서버는 FIN 패캣을 받아 연결 종료를 감지하고 통신이 끝날때까지 TIME_WAIT 상태가 된다.
    3. 서버에서 통신이 종료됨을 알리기 위해 클라이언트로 FIN 패킷을 보낸다.
    4. 클라이언트에서 FIN 패킷을 받고 확인을 알리는 ACK 패킷을 보낸다.

### 흐름제어

- 송신측과 수신측의 데이터처리 속도 차이를 해결하기 위해 데이터 전송량을 제어하는 방법
    - 송신측이 수신측보다 속도가 빠르면 패킷이 유실되는 문제가 발생함
- **stop and wait** 
    - 패킷을 정상적으로 수신했다는 응답을 받은 후에만 패킷을 보내는 방식
- **sliding window** 
    - 수신측에서 윈도우 크기를 정하고 윈도우 크기만큼 확인 응답없이 패킷을 전송하는 방식. 
    - 송신 버퍼 범위는 수신측의 여유 버퍼 공간을 반영하여 동적으로 변경됨

### 혼잡제어

- 한 라우터에 데이터가 몰릴 경우 수신측에서 데이터 처리에 과부하가 발생하여 재전송이 빈번하게 일어남
- 이러한 네트워크의 혼잡을 피하기 위해 송신측의 데이터 전송속도를 제어하는 방식
- **AIMD(Additive Increase / Multiplicative Decrease)**
    - 패킷을 하나씩 보내면서 윈도우 크기를 1씩 증가시키다가 혼잡상태 발생시 윈도우를 절반으로 줄임
    - 단점 : 초기 전송속도 증가가 더디고, 네트워크가 혼잡상태가 된 후에야 조치를 취한다
- **Slow Start**
    - 윈도우 크기를 지수적으로 증가시키다가 임계점에 도달하면 선형적으로 증가시키고, 혼잡상태 발생시 정책에 따라 윈도우 크기를 감소
    - 혼잡제어 정책에 여러가지 요소가 사용됨
        - `Threshold` : 윈도우 크기가 지수적으로 증가하는 임계점
        - `3 ACK duplicate` : ACK 패킷이 세번 중복될 경우 윈도우 크기 감소
        - `Time out` : 패킷 응답 제한 시간이 초과될 경우 윈도우 크기 감소
        - `Fast Recovery` (빠른회복) : 혼잡상태 발생후 윈도우 크기가 줄었을때 윈도우 크기를 빠르게 증가시키는 모드
        - `Congestion avoidance` (혼잡회피) : 임계치에 도달하면 윈도우 크기를 1씩 증가시킴

<br>

## UDP (User Datagram Protocol)

- 송신측에서 데이터 전송 결과를 확인하지않고 **데이터를 보내기만하는** 프로토콜
- 비신뢰성 + 비연결성 데이터 전송 프로토콜
- TCP에 비해 속도가 빠름
- 한두개의 프레임이 유실되도 큰 문제가 없고 빠르게 처리해야하는 실시간 서비스에서 사용됨

<br>