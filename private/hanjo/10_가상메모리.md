# 가상메모리

<br>

## 가상 메모리란?

### 정의

- 프로세스가 실행될 때 코드 전체를 메모리에 로드하지만, 코드의 일부에서만 대부분의 시간을 사용함
    - 특정 순간에는 항상 작은 양의 주소공간을 사용
    - 코드 용량이 메모리 용량보다 큰 프로그램은 실행시킬 수 없음
- **물리적 메모리 용량의 한계를 극복하기 위한 기술**

### 역할

- 프로세스 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 둔다.
    - 프로세스 전체가 물리적 메모리에 존재하는 것처럼 수행된다
- 메모리에 작은 양의 주소 공간만 있으면 프로세스를 수행할 수 있게 되고, 더 많은 프로세스를 동시 실행 가능

### 용어 정리

- disk swap 영역 == 가상메모리 / 페이지
- 물리메모리 == 메인메모리 / 프레임

<br>

## 페이징 기법

- 프로세스를 **고정 분할** 기법을 사용하여 일정 크기의 페이지로 잘라 메모리에 적재하는 방식

<img width="700" alt="image" src="https://user-images.githubusercontent.com/71180414/149677880-7583f98f-88bc-486e-aeaa-f014183e9c12.png">


- 가상 메모리와 물리 메모리 영역의 주소 공간을 동일한 크기로 나눈다
    - 가상 메모리 블록 -> **페이지**
    - 물리 메모리 블록 -> **프레임**

### 프로세스 테이블

- 페이지와 프레임은 **프로세스 페이지 테이블**을 사용하여 매핑한다
- 각 프로세스는 자신만의 페이지 테이블을 가진다.

<img width="364" alt="image" src="https://user-images.githubusercontent.com/71180414/149678243-84ff2f10-74a6-4169-b1ff-1598a5e41042.png">

- 페이지 테이블은 배열이라고 생각하면 된다
    - 인덱스가 페이지 번호이고 배열의 값이 프레임 번호
- 하지만 페이지 테이블의 용량이 커서 성능문제가 발생하므로 캐시(TLB)를 사용한다

<br>

## 세그먼테이션 기법

<img width="700" alt="image" src="https://user-images.githubusercontent.com/71180414/149679442-6fb45e66-002d-4d72-9b59-23be57410452.png">

- 프로세스를 **가변 분할** 기법을 사용하여 가변 영역인 세그먼트로 잘라 메모리에 적재하는 방식
- **세그먼트 테이블**을 사용한다
    - index : 세그먼트 번호
    - base : 시작 주소
    - limit : 세그먼트 크기
- 데이터 공유에 유리하다
    - ex) 코드, 데이터, 스택영역을 나눌 때 각 영역에 알맞게 나누기 때문에 영역끼리 섞이지 않음

<br>

## 페이징 vs 세그먼테이션

||페이징|세그먼테이션|
|---|---|---|
|분할방식|고정분할|가변분할|
|외부단편화|X|O|
|내부단편화|O|X|

<br>

## 요구 페이징

- 초기에는 필요한 페이지만을 메인메모리에 적재하고, 프로세스 실행중에 실제로 필요한 페이지를 적재하는 기법
    - 이를 Lazy swapper라 함.
    - 가상메모리를 페이지로 나눈 뒤 메인메모리 프레임에 적재
- **장점** : 메모리 절약, 프로세스 응답 속도 향상
- **단점** : page fault 발생

### 원리

<img width="310" alt="image" src="https://user-images.githubusercontent.com/71180414/149810180-8cdc27a7-3986-4ee5-95cc-65c96c91b7db.png">

- 페이지가 실제로 물리메모리에 적재되었는지의 여부는 페이지 테이블을 통해 판단한다.
- Valid-Invalid Bit를 활용
    - `v` : 물리메모리에 적재되어 있음
    - `i` : 적재되어 있지 않음

<br>

## Page Fault

1. 프로세스가 특정 페이지를 요청 -> 메인메모리에 페이지 존재 X
2. 제어권이 운영체제로 넘어가고 페이지를 가져올 프레임 공간을 찾음(free frame)
    - 공간이 없다면 페이지 교체 발생
3. 페이지 테이블에서 가상메모리(디스크) 주소를 확인 -> 메인메모리에 페이지 저장 (disk I/O이므로 상태가 blocked로 변경)
4. 페이지 테이블 업데이트 후 ready 상태로 변경

<br>

## 페이지 교체 알고리즘

- page fault가 발생하여 페이지를 가져올 메인메모리의 프레임 공간이 부족할 경우 특정 프레임을 교체해야하는데, 가장 적절한 프레임을 선택하는 알고리즘이다.

### FIFO (First In First Out)

- **가장 먼저 들어온 페이지를 교체 (선입선출)**
- 큐로 구현

### OPT (Optimal)

- **앞으로 가장 오랫동안 사용되지 않을 페이지를 교체**
- 가장 이상적인 방법이지만 적절한 페이지를 예측하는것이 불가능함.

### LRU (Least Recently Used)

- **가장 오랫동안 사용되지 않은 페이지를 교체** 
- 큐로 구현
- 참조된 페이지 시간을 기록해야하므로 오버헤드가 발생

### NRU (Not Recently Used)

- **최근에 사용하지 않은 페이지 교체**
- LRU와 근사한 알고리즘
- 적은 오버헤드로 적절한 성능
- 두 개의 비트를 사용
    - `참조 비트 r` : 페이지가 참조되지 않았으면 0, 호출되었으면 1 (참조비트는 주기적으로 0으로 변경)
    - `변형 비트 m` : 페이지 내용이 변경되지 않으면 0, 변경되었으면 1
    - 교체 우선순위 예시
        1. r = 0 / m = 0
        2. r = 0 / m = 1
        3. r = 1 / m = 0
        4. r = 1 / m = 1

### LFU (Least Frequently Used)

- **참조 횟수가 가장 적은 페이지를 교체**
- 가장 최근에 불러운 페이지가 교체될 수 있고, 구현이 복잡함

### MFU (Most Frequently Used)

- **참조 횟수가 가장 많은 페이지를 교체**
- 가장 많이 사용된 페이지는 앞으로 사용되지 않을것이라는 가정


<br>

## 예상 질문

<br>

<details>
    <summary><b>가상메모리에 대해 설명해주세요</b></summary>
    <br>
    가상메모리란 물리적 메모리 용량의 한계를 극복하기 위한 기술입니다.<br>
    일반적으로 운영체제의 물리메모리 용량보다 큰 메모리를 가진 프로세스는 실행이 불가능합니다.<br>
    가상메모리를 사용하게 되면 프로세스 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크 영역에 적재합니다.<br>
    이로써 프로세스 전체가 물리메모리에 존재하는 것처럼 수행되고, 제한된 메모리보다 큰 프로세스를 동시실행할 수 있도록 합니다.
</details>

<br>

<details>
    <summary><b>페이징 기법에 대해 설명해주세요</b></summary>
    <br>
    페이징 기법은 프로세스를 고정분할 기법을 사용하여 일정 크기의 페이지로 잘라 메모리에 적재하는 가상메모리 관리 기법입니다.<br>
    이때 가상메모리를 분할한 블록을 페이지라 하고, 물리메모리를 분할한 블록을 프레임이라고 합니다.<br>
    페이지와 프레임은 프로세스 페이지 테이블을 사용하여 매핑됩니다.<br>
    모든 프로세스는 프로세스 페이지 테이블을 가지며 페이지와 프레임의 주소 정보를 저장합니다.
</details>

<br>

<details>
    <summary><b>세그먼테이션 기법에 대해 설명해주세요</b></summary>
    <br>
    세그먼테이션 기법은 프로세스를 가변분할 기법을 사용하여 가상메모리를 메모리에 관리하는 기법입니다.<br>
    가상메모리는 가변 영역인 세그먼트로 분할되며, 세그먼트 테이블을 통해 관리됩니다.<br>
    세그먼트 테이블은 세그먼트 번호를 저장하는 인덱스와, 물리메모리 시작 주소를 저장하는 base, 그리고 세그먼트 크기를 저장하는 limit으로 이루어져 있습니다.
</details>

<br>

<details>
    <summary><b>페이징과 세그먼테이션 기법을 비교해주세요</b></summary>
    <br>
    페이징 기법은 고정분할 방식을 사용하여 외부단편화를 방지하지만, 관리해야하는 페이지 테이블의 메모리 크기가 너무 커지게 됩니다.<br>
    반면 세그먼테이션 기법은 가변분할 방식을 사용하여 내부단편화를 방지하고 데이터 공유에 유리하지만 외부단편화가 발생하는 단점이 있습니다.<br>
    이와 같은 한계를 극복하기 위해 두 기법을 혼용하여 세그먼트를 페이징 기법으로 나누는 방식을 사용하게 됩니다.
</details>

<br>

<details>
    <summary><b>요구 페이징에 대해 설명해주세요</b></summary>
    <br>
    요구 페이징이란 초기에는 필요한 페이지만을 메인메모리에 적재하고, 프로세스 실행중에 실제로 필요한 페이지를 적재하는 기법입니다.<br>
    이로써 메모리 공간을 절약할 수 있고, 프로세스의 응답 속도가 향상되는 장점을 가집니다.<br>
    하지만 페이지 부재가 발생하는 단점도 존재합니다.
</details>

<br>

<details>
    <summary><b>페이지 부재에 대해 설명해주세요</b></summary>
    <br>
    페이지 부재란 프로세스에게 필요한 페이지가 메인메모리의 프레임 공간에 없을 때 발생하게 됩니다.<br>
    페이지 부재가 발생하면 메인메모리에 필요한 페이지를 가져와야 하는데, 만약 프레임 공간이 부족하다면 특정 프레임을 다시 디스크 스왑영역으로 내보내야 합니다.<br>
    이 때 페이지 교체 알고리즘을 사용하여 적절한 프레임을 내보내게 되고, 페이지 테이블에서 가상메모리 주소를 확인 후 필요한 페이지를 메민메모리에 가져오게 됩니다.
</details>

<br>

<details>
    <summary><b>페이지 교체 알고리즘에 대해 설명해주세요</b></summary>
    <br>
    페이지 부재가 발생하여 페이지를 가져올 메인메모리의 프레임 공간이 부족할 경우 프레임을 교체해야하는데, 이 때 가장 적절한 프레임을 선택하는 알고리즘입니다.<br>
    페이지 교체 알고리즘의 종류로는 FIFO, LRU, NRU 등이 있습니다.
</details>

<br>

<details>
    <summary><b>FIFO에 대해 설명해주세요</b></summary>
    <br>
    가장 먼저 들어온 페이지를 교체하는 알고리즘입니다.<br>
    페이지가 들어온 순서대로 저장해야하기 때문에 큐로 구현이 가능합니다.
</details>

<br>

<details>
    <summary><b>LRU에 대해 설명해주세요</b></summary>
    <br>
    가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘입니다.<br>
    큐로 구현이 가능하고 페이지의 사용시간을 지속적으로 기록해야하기 때문에 큰 오버헤드가 발생하는 단점이 있습니다.
</details>

<br>

<details>
    <summary><b>NRU에 대해 설명해주세요</b></summary>
    <br>
    최근에 사용하지 않은 페이지를 교체하는 알고리즘입니다.<br>
    LRU와 비슷하게 동작하고, 적은 오버헤드로 적절한 성능을 낼 수 있습니다.<br>
    참조비트와 변형비트가 사용하여 페이지 참조와 수정을 기록하여 교체 우선순위를 결정합니다.
</details>

<br>