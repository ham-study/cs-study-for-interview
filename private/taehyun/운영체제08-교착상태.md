## 교착 상태

교착상태(데드락)란 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생합니다.

일반적으로 교착상태는 비선점형 자원들을 대상으로 합니다. 선점형 자원들을 포함하는 잠재적인 교착상태는 보통 한 프로세스로부터 다른 프로세스로 자원들을 재배치하면 해결할 수 있습니다.



## 교착 상태 조건

교착상태는 상호배제, 점유와 대기, 비선점, 환형 대기 이 4가지 조건을 모두 충족할 때 발생 합니다.

**상호배제** : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 합니다.

**점유와 대기** : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 합니다.

**비선점 :** 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없어야 합니다.

**순환 대기 :** 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 기다려야 합니다.



## 교착 상태 해결 방법

### **교착상태 탐지 및 회복**

**교착상태 탐지**

교착상태에 빠져있는지 탐지하는 방법은 dfs로 탐색을 하는 방법이 있습니다. 프로세스와 자원들을 노드로 간주하고 dfs 탐색을 했을 때, 이미 방문했던 노드로 되돌아오면 사이클이 있는 것이고 교착상태에 빠진 것을 탐지할 수 있습니다.

이 탐색을 매 요청마다 할 수는 없으므로, 매 k분마다 혹은 CPU 이용률이 어떤 기준점보다 떨어졌을 때만 검사합니다. CPU 이용률을 고려하는 이유는, 만약 교착상태에 걸렸다면, 실행 가능한 프로세스들이 거의 없으므로 CPU가 유휴 상태가 되기 때문입니다.



**롤백을 통한 회복**

교착상태가 발생할 가능성이 있다는 것을 알았다면, 체크포인트와 같은 프로세스들을 배치할 수 있습니다. 회복을 위해서 필요한 자원을 소유한 프로세스는 이전의 체크포인트 위치로 롤백함으로써, 해당 자원을 획득하기 이전의 시점으로 돌아갑니다. 이 자원은 이제 교착상태에 걸린 프로세스들 중 하나에게 할당됩니다.



**프로세스 강제 종료를 통한 회복**

가장 간단한 방법은 프로세스들을 강제 종료 시키는 것입니다. 하나의 프로세스를 강제 종료시키고 운이 좋다면 다른 프로세스들은 실행을 계속 할 수 있습니다. 만약 해결이 안된다면 교착상태가 제거될 때까지 반복하여 프로세스들을 종료시킵니다.



### **교착상태 회피**

교착상태 회피 기법은 자원을 프로세스에게 할당할 때, 안전한지 아닌지 결정하고 안전할 때만 할당하는 방법입니다. 대표적으로 은행원 알고리즘이 있습니다.

**은행원 알고리즘**

은행원 알고리즘은 교착상태에 빠질 가능성이 있는지를 판단하기 위해 상태를 '안전 상태'와 '불안전 상태'로 나눕니다. 즉, 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 계속 거절합니다. 다음 상태가 안전한 상태인지를 알아보기 위하여 프로세스들은 실행하기 전에 자신이 필요로 하는 전체 자원들에 대한 보고를 하고, 시스템은 만족시킬 수 있는 자원을 가지고 있는지 계산합니다.

하지만, 이 방법은 이론적으로만 가능하고 실제로 사용하는 시스템은 거의 없습니다. 실제로 프로세스들이 자신의 최대 자원 요구량을 알 수도 없고, 프로세스의 수도 고정된 것이 아니라 동적으로 변하기 때문입니다.



### 교착상태 예방

교착상태 예방 기법은 교착상태가 발생하지 않도록 교착상태 발생의 4가지 조건 중에서 어느 하나라도 제거하는 기법입니다.

**상호 배제 부정** : 상호 배제를 제거하기 위해서는 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 합니다.

**점유 및 대기 부정** : 점유와 대기를 제거하기 위해서는 프로세스가 실행되기 전에 미리 필요한 모든 자원을 할당하여 프로세스 대기를 없앱니다. 약간 다른 방법으로 어떤 자원을 요구하는 프로세스는 먼저 그 프로세스가 보유하고 있는 모든 자원들을 반환하도록 합니다. 그리고 나서, 그 프로세스가 필요로 하는 모든 것을 한 번에 획득하도록 합니다.

**비선점 부정** : 비선점을 제거하기 위해서는 자원을 점유하고 있는 프로세스가 즉시 얻을 수 없는 다른 자원을 요구하면 현재 점유하고 있는 자원이 방출되어 필요로 하는 다른 프로세스가 선점하도록 합니다.

**순환 대기 부정** : 환형 대기를 제거하기 위해서는 자원을 선형 순서로 분류하여 고유 번호를 할당하고, 모든 프로세스들은 자원을 요청할 수 있지만 모든 요청들은 숫자의 오름차순 또는 내림차순 순서에 따라야 합니다.



## 식사하는 철학자 문제

철학자는 순서에 상관 없이 왼쪽 포크 또는 오른쪽 포크를 한 번에 하나씩 잡으려고 시도한다. 두 개의 포크를 잡게 되면 식사를 하고 포크를 내려놓고 다시 생각한다. 여기서 핵심은 각 철학자가 해야 할 일을 그대로 수행하면서 절대로 중단되지 않는 프로그램을 작성할 수 있는가이다.

해결책은 state라는 배열을 사용하여 철학자가 식사 중인지, 생각 중인지, 포크를 집으려고 시도하는 중인지 기록한다. 철학자는 양 옆 이웃이 식사 중이 아닌 경우에만 식사 중인 상태가 될 수 있다.

철학자 당 하나씩 세마포어 배열을 사용하므로 이제 필요한 포크가 사용중이면 배고픈 철학자는 대기하게 된다.