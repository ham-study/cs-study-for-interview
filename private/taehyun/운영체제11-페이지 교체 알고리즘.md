## 요구 페이징

요구 페이징은 페이지를 미리 적재하는 것이 아니라 실제로 필요한 시점에 적재하는 것입니다.

**페이지 폴트**

CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제 메모리에 원하는 페이지가 없는 것을 페이지 폴트라고 합니다. 페이지 폴트가 발생하면 가상메모리를 통해서 해당 데이터를 가져오게 됩니다. 가상메모리는 디스크에 저장되어 있기 때문에, 페이지 폴트가 발생하면 입출력에 의해 속도가 저하됩니다.

## 페이지 교체 알고리즘

페이즈 폴트가 발생하면 운영체제는 새로운 페이지를 메모리에 할당하기 위해서 기존의 페이지 중에 하나를 없애야 합니다. 이때 자주 사용되지 않을 페이지를 선택하는 것이 시스템 성능에 도움이 됩니다.

### FIFO

가장 먼저 적재된 페이지가 교체되는 알고리즘입니다. 자주 사용하는 페이지임에도 불구하고 먼저 적재되었다는 이유로 교체가 발생하는 문제가 생길 수 있습니다.

### Second-Change

FIFO의 문제점을 보완한 알고리즘입니다. 참조(R) 비트를 사용해서 만약 R이 0이면 가장 오래된 페이지이면서 조회되지 않은 페이지이므로 교체합니다. 반대로 R이 1이라면 이 페이지를 방금 추가된 것처럼 리스트의 뒤에 추가하고 R비트를 0으로 클리어합니다.

결국 Second Change 알고리즘은 가장 오래 되었고 최근에 참조되지 않은 페이지를 교체합니다. 만일 모든 페이지가 참조되었다면 FIFO와 동일하게 동작합니다.

### LRU(Least Recently Used)

LRU는 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘입니다. LRU를 위해서는 메모리 내에 있는 모든 페이지들이 리스트로 연결되어 있어야 하는데, 가장 최근에 참조된 페이지가 리스트의 앞에 가장 과거에 참조된 페이지가 리스트의 뒤에 위치해야 합니다. 여기서 어려운 점은 리스트에서 메모리 참조마다 리스트를 갱신해야 하는 것입니다. 리스트에서 페이지를 찾고, 삭제하고, 리스트의 가장 앞으로 옮기는 작업은 시간이 많이 걸립니다.

### NRU(Not Recently Used)

페이지마다 페이지 사용 정보를 알기 위해서 참조 비트와 변경 비트를 사용합니다. 여기서 참조 비트는 참조 될 때마다 설정되고, 변경 비트는 페이지가 수정될 때마다 설정됩니다. 그러면 운영체제는 참조 비트와 변경 비트의 값에 따라 모든 페이지를 4가지로 구분합니다.

1. 참조되지 않았고, 수정되지 않은 페이지
2. 참조되지 않았고, 수정된 페이지
3. 참조되었고 수정되지 않은 페이지
4. 참조되었고 수정된 페이지

NRU 알고리즘은 1,2,3,4 순서대로 페이지를 교체합니다. 이 알고리즘의 기본 아이디어는 가장 최근에 참조되지 않은 페이지를 교체하는 것입니다.