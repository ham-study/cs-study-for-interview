시스템마다 무엇을 목표로 스케줄러를 최적화 해야 하는지는 다릅니다. 따라서, 서로 다른 환경은 서로 다른 스케줄링 알고리즘을 필요로 합니다.

대표적인 세 가지 환경

1. 배치
2. 대화식
3. 실시간

**서로 다른 환경에서 스케줄링 알고리즘의 목표**

모든 시스템

- 공평함 - 각 프로세스에게 공평한 몫의 CPU를 할당함
- 균형 - 시스템의 모든 부분이 활동하도록 함

배치 시스템

- 성능 - 시간당 처리되는 작업 수 최대화
- CPU 이용률 - CPU가 항상 활용되도록 함
- 반환시간 - 작업의 제출부터 종료까지 걸리는 시간 최소화

대화식 시스템

- 응답시간 - 요청에 빠르게 응답하도록 함

실시간 시스템

- 마감시간 만족 - 데이터 손실을 방지
- 예측 가능 - 멀티미디어 시스템에서 품질 저하를 방지

### FCFS

이 알고리즘에서 프로세스들은 요청 순서대로 CPU를 할당받습니다. 기본적으로, 준비 상태의 프로세스를 위해 단일 큐가 존재합니다.

장점으로 스케줄링 구현이 쉽고, 준비 큐에 있는 모든 프로세스가 실행될 수 있으므로 starvation이 없습니다. 하지만, 비선점식이라 대화식 프로세스에는 부적합하고 실행시간이 긴 프로세스가 짧은 프로세스를 모두 지연시켜 평균 대기 시간이 길어질 수 있습니다.

### SJF

평균 대기 시간을 최소화 하기 위해 CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식입니다. 실행 시간이 짧은 프로세스를 먼저 처리하므로 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 우선순위가 밀려 기아상태에 빠질 수 있다는 단점이 있습니다.

### SRT

SRT는 SJF 기법을 선점 형태로 변경한 기법입니다. 새로 도착한 프로세스가 더 짧은 CPU 타임을 가지면 CPU를 뺏고 먼저 실행합니다.

### Round Robin

라운드 로빈은 프로세스들 사이에 우선순위를 두지 않고, 프로세스에게 시간 단위로 CPU를 할당하는 방식입니다. 할당 시간동안 수행한 프로세스는  Ready Queue의 끝으로 밀려납니다. 모든 프로세스가 공정하게 시간을 할당받기 때문에 starvation이 발생하지 않습니다.

할당 시간이 너무 크면 FCFS와 같아지고 너무 작으면 컨텍스트 스위칭의 오버헤드가 커집니다.

### 우선순위 스케줄링

각 프로세스에게는 우선순위가 할당되며 가장 높은 우선순위의 프로세스가 다음에 수행됩니다. 하지만 높은 우선순위의 프로세스가 무한히 실행될 수 있기 때문에 이를 막기 위해 스케줄러는 현재 실행중인 프로세스의 우선순위를 낮출 수 있습니다. 다른 방식으로, 각 프로세스는 최대로 실행할 수 있는 할당 시간을 가집니다. 이 할당 시간을 소비하면 다음 우선순위의 프로세스가 실행됩니다.

### MultiLevel Queue

MultiLevel Queue 방식은 프로세스를 그룹에 따라 각기 다른 READY QUEUE를 사용하는 기법입니다. 하위 큐에 있는 프로세스를 실행하는 도중이라도 상위 큐에 프로세스가 들어오면 상위 프로세스에세 CPU를 할당해야 합니다. 각 READY QUEUE에서는 독립적인 스케줄링 알고리즘이 적용됩니다.

우선순위가 높은 큐는 빠르게 작업을 처리할 수 있지만 우선순위가 낮은 큐의 프로세스는 Starvation 현상이 일어 날 수 있습니다.

### 다단계 피드백 큐 스케줄링(MLFQ, MultiLevel Feedback Queue)

MultiLevel Feedback Queue는 MLQ에서 처음 지정된 큐를 벗어나 우선순위를 바꿀 수 있도록 허용한 스케줄링 기법입니다. 우선순위가 바뀌거나 큐를 이동하면 프로세서를 뺏을 수 있습니다. 매우 유연하기 때문에 스케줄러를 특정 시스템에 맞춰 구현할 수 있다는 장점이 있고, 자동으로 입출력 중심, CPU 중심의 프로세스 특성에 따라 서로 다른 시간 할당을 할 수 있습니다.