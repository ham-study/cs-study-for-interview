# 프로세스 동기화
프로세스 동기화는 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜주어야 한다.

## 공유자원, 경쟁상태, 임계구역

### 공유자원
여러 프로세스가 공유하는 자원

### 경쟁상태

여러 프로세스가 동일한 데이터에 동시에 액세스하고 조작하는 상황에서 똑같은 코드라도 실행 순서에 따라 결과값이 달라지는 상황이다.

→ 동기화를 통해 일정시간에 공유 자원에 하나의 프로세스만 접근 가능하도록 한다.

### 임계구역

임계구역은 여러개의 쓰레드가 수행되는 시스템에서 각 쓰레드들이 동시에 접근해서는 안되는 **공유하는 데이터(변수, 테이블, 파일등)의 코드 영역을 말한다.** 

- 임계구역은 시간이 지나면 종료되며, 어떤 프로세스가 임계구역에 접근하기 위해서는 지정된 시간만큼 대기해야한다. 이때 쓰레드나 프로세스가 배타적인 사용권을 보장 받기 위해서 세마포어 같은 동기화 매커니즘을 사용하게 된다.
- 하나의 쓰레드가 임계구역에 접근하기 위해서는 요청→ 필요시 대기→ 임계구역 처리→ 빠져나감의 순서로 이루어진다.

**임계 구역을 해결하기 위해서는 3가지 조건을 만족해야한다**

1. Mutual exclusion(상호배타): 하나의 프로세스가 임계구역에 들어가 있으면 다른 프로세스는 들어갈 수 없다.
2. Progress(진행): 한 임계구역에 접근하는 쓰레드나 프로세스가 없다면, 어느 프로세스가 들어갈 것인지 적절히 선택해줘야 한다.
3. Bounded waiting(유한 대기): 기아상태를 방지하기 위해, 한 번 들어갔다가 나온 프로세스는 다음에 들어갈 때 제한을 준다.

## 피터슨 알고리즘

두개의 프로세스에 대한 스프트웨어 기반의 busy waiting을 사용하는 **임계구역 문제 해결 책**이다.
- 프로세스 P0과 P1가 있다고 할때 Pi,P(1-i)이라고 할 수 있다

- 두개의 프로세스는 turn(int)과 flag(boolean[])를 공유하도록 하여 임계구역 문제를 해결한다.
- turn: 임계구역으로 진입할 순번을 나타낸다
- flag 배열은 프로세스가 임계구역으로 진입할 준비가 되었다는 것을 나타낸다.

```c
do{
// 임계 구역 사용을 원함
flag[me]=true;

//me가 아닌 프로세스에게 차례가 간다
turn=!me;

while(flag[!me]&&turn==!me){
//임계 구역이 사용가능한지 계속 확인한다.
}
//임계구역

//임계구역 끝
flag[me]=false

```

하지만 프로세스가 많이 몰리게 되면 계속 while문을 대기해야하는 상황이 발생한다 이것을 **busy waiting** 이라고 부른다

## 뮤텍스(상호 배제)
- 상호배제를 뜻하고 binary semaphore와 같은 의미이다(자원에 단 하나의 작업만이 접근할 수 있다는 뜻)
- 동시 프록그래밍 환경(멀티 프로세스, 멀티 쓰레드 환경)에서 공유 불가능한 자원의 동시 사용을 막기 위해 사용되는 알고리즘이다
- Critical Section을 가진 스레드들의 실행 시간이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술이다. 다중 프로세스들의 공유 자원에 대한 접근을 조율하기 위해 lock과 unlock을 사용한다.
- locking
    - lock을 가진 쓰레드만이 임계구역에 접근할 수 있는 것
    - 임계구역에서 작업이 끝난 쓰레드는 unlock하여 lock을 반환한다.
  
## 세마포어

- 동시에 자원에 접근 할 수 있는 허용 가능한 counter의 개수를 뜻한다.
- 두개의 원자적 함수로 조작되는 정적 변수로써, 멀티 프로그래밍 환경에서 공유자원(임계구역)에 대한 접근을 제한하는 방법으로 사용된다.
- 모든 교착상태를 해결하지 못한다는 문제점이 있다.
  
**동작**

1. P: test→ acquire()
2. V: increment→release()

P는 임계구역에 들어가기전에 수행되고,V는 임계구역에서 나올 때 수행된다.

한 프로세스나 쓰레드에서 S을 변경하는 동안에 다른 프로세스나 쓰레드가 동시에 접근해서 변경할 수 없다.

값이 0보다 크면 접근을 허용하되 1을 감소하고, 값이 0이면 접근을 block시킨다.

작업이 끝나고 프로세스나 쓰레드가 나갈때는 값을 1로 증가시켜 다른 프로세스나 스레드가 접근할 수 있도록 한다.

**처음 제시된 방법(Busy-wait)**

busy waiting(대기중인 쓰레드가 여전히 활성상태이지만 아무 작업도 하지 않은 상태)을 활용하는 방법

```c
P(S) {
     while S <=0; // 아무것도 하지 않음 (반복문)
     S--;
 }

 V(S) {
//자원을 모두 사용했다면 반납한다.
     S++;
 }
```

- 임계 구역에 진입하기 전까지 빈 반복문을 계속 수행하므로 효율이 떨어진다.
- 대기중인 프로세스 중 어느 것을 먼저 임계구역에 진입시킬지 결정할 수 없다.

**Block-wakeup 방식:`Wait Queue`를 활용하여 보완할 수 있다.**

```c
P(S) {
     S--;
//자원의 개수가 부족해 사용할 수 없다면 현재 프로세스를 Wait Queue에 추가한 후 block을 통해 suspend시킨다.
     if S < 0
         // 이 프로세스를 Wait Queue에 추가 (잠 듦)
 }

 V(S) {
//작업을 완료해 자원의 값을 증가시키며 반납 했을 때
     S++;
//자원의 수가 없다면 현재 자원을 기다리는 프로세스가 존재한다는 뜻이다.
     if S <= 0
         // Wait Queue로부터 프로세스를 제거 (깨어남)
 }
```

- 임계 구역의 길이가 긴 경우는 Block-wakeup 방식이 유리하다. 하지만 짧다면 잦은 문맥교환으로 인해 오버헤드가 증가하게 된다.
  
#### 뮤텍스와 세마포어의 차이
1. 세마포어는 자원의 상태를 나타내는 ‘변수’로써 소유 개념이 아니다. 하지만 뮤텍스는 자원을 점유한 프로세스나 쓰레드가 잠시 소유하였다가 작업이 끝나면 반환하는 개념이다.
2. **뮤텍스는 동기화 대상이 자원의 하나라면 세마포어는 하나 이상일때 사용된다.**

## 모니터
동기화 문제를 해결하기 위해 세마포어를 사용했지만 몇가지 문제점이 있다.

- 정확성 입증이 어렵다
- 자발적 협력이 필요하다
- 한번의 실수가 모든 시스템에 치명적인 영향을 끼친다.

**모니터 특징**

1. 모니터 내에서는 한번에 하나의 프로세스만 활동이 가능하다
2. 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 없다.
3. 프로세스가 모니터 안에서 기다릴 수 있도록 Condition Variable을 사용한다
- wait(): 다른 프로세스가 signal을 하기 전까지 suspend된다
- signal(): 하나의 suspend된 프로세스를 깨운다

모니터는 자체적으로 하나의 프로세스만 처리하지만 Semaphore은 직접 Lock을 걸고 해제해야한다.

모니터는 뮤텍스의 상위 호환 버전이면서, 세마포어와는 약간의 차이를 가지고 있다.