## 요구 페이징

### 개요

- 사용자가 요구할때 해당 페이지를 메모리로 가져오는 것

**동작**

- 운영체제는 필요한 페이지만 메모리에 올려 실행하고 나머지 페이지는 필요하다고 판단될 때 메모리로 불러온다.

**이유**

- 메모리를 효율적으로 관리하기 위해서→메모리가 꽉 차면 관리하기 어려우므로 가급적이면 적은 양의 프로세스만 유지한다.
- 응답 속도를 향상하기 위해서→용량이 큰 프로세스를 전부 메모리로 가져와 실행하면 응답이 늦어질 수 있으므로 필요한 모듈만 올려 실행한다.

### 페이지 테이블 엔트리의 구조

- 가상 메모리 시스템 크기→ 물리 메모리+스왑영역 크기
- 가상 메모리 시스템에서 사용자의 프로세스는 물리 메모리와 스왑 영역 중 한 곳에 있다.

**스왑 영역에 있는 경우**

1. 요구 페이징으로 인해 처음부터 물리 메모리에 올라가지 못한 경우
2. 메모리가 꽉 차서 스왑 영역으로 옮겨온 경우(스왑 아웃)

**페이지 테이블 엔트리**

- 페이지 번호(직접 매핑에서는 사용하지 않음),플래그 비트(접근 비트, 변경비트,유효비트, 읽기 비트, 쓰기 비트, 실행 비트),프레임 번호로 구성되어 있다.
- 프레임 번호(주소 필드): 페이지 테이블의 핵심, 가상 주소의 해당 페이지가 어느 프레임에 있는지 알려주는 자료구조
- 접근 비트와 변경 비트는 페이지가 메모리에 올라온 후 어떤 작업이 있었는지 알려주는 역할로 메모리가 꽉 차서 어떤 페이지를 스왑 영역으로 옮겨야 할지 선택할 때 사용한다.

### 페이지 부재

- 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황

![](https://images.velog.io/images/pinoa1228/post/6bc20195-6e92-4d7c-84cd-48e967878acd/Untitled%20(4).png)

**유효비트**

페이지 테이블에 페이지가 메모리에 있는지 스왑 영역에 있는지 표시하는 비트

**유효비트에 따른 주소필드 변화**

유효비트:0→페이지가 메모리에 있다→주소필드(프레임 번호)에 프레임 번호

유효비트:1→페이지가 스왑 영역에 있다.→주소필드(프레임 번호)에 스왑 영역 내 페이지의 주소

**페이지 부재가 일어났을 때**

- 페이지 3번 같은 경우에는 페이지가 메모리에 없으므로 페이지 부재라고 할 수 있다.
- 페이지 부재가 발생하면, 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 한다

**페이지 부재 처리 과정**

1. 페이지 3번을 요청 했을때 유효비트가 1이기 때문에 페이지 부재가 발생한다
2. 메모리 관리자는 스왑 영역의 0번에 있는 페이지를 메모리의 비어 있는 프레임인 5로 가져온다(스왑인)
3. 프레임 5에 페이지가 들어오면 페이지 테이블 엔트리 3의 유효비트는 1→0으로, 주소필드는 0→5로 바뀐다.
4. 프레임 5로 접근하여 해당 데이터를 프로세스에 넘긴다.

**페이지 부재 vs 세그먼테이션 오류**

- 세그먼테이션 오류→ **사용자의 프로세스가 주어진 메모리 공간을 벗어나거나 접근 권한이 없는 곳에 접근 할 때 발생하며** 해당 프로세스를 강제 종료해서 해결한다.
- 페이지 부재→ 해당 페이지가 물리 메모리에 없을 때 발생하는 오류로 **사용자 프로세스와 무관하다.** 따라서 페이지 부재가 발생하면 메모리 관리자는 스왑 영역에서 해당 페이지를 물리 메모리로 옮긴 후 작업을 진행한다.

**지역성**

기억 장치에서 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질

**공간 지역성**

**현재 위치에서 가까운 데이터에 접근할 확률**이 먼 거리에 있는 데이터에 접근할 확률보다 높음

**시간 지역성**

**현재 기준으로 가장 가까운 시간에 접근한 데이터**가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높음

**순차 지역성**

여러 작업이 순서대로 진행되는 경향이 있음

## 페이지 교체 알고리즘

- 페이지 부재가 일어났으나, 빈 프레임이 없을 때 메모리에 있는 프레임 중 하나를 스왑 영역으로 내보낼지 결정하는 알고리즘
- 앞으로 사용하지 않을 페이지를 스왑 영역으로 옮기는 것이 중요하다.

**대상 페이지**

페이지 교체 알고리즘에 의해 스왑 영역으로 보낼 페이지

**페이지 알고리즘 처리 과정**

![](https://images.velog.io/images/pinoa1228/post/bfa2afc7-8959-4f8d-8063-76b6d02469d0/Untitled%20(5).png)

1. 페이지 4를 요청했을때 페이지 부재가 일어났다 하지만 메모리는 꽉차있는 상태이다.
2. 대상 페이지가 A라고 가정했을때, 이 페이지를 스왑영역으로 옮긴 후 페이지 엔트리 테이블에 A 페이지 정보를 업데이트한다.
3. E 페이지를 메모리로 가져온다(스왑인)
4. 페이지 엔트리 테이블에 E 페이지 정보를 업데이트 한다.

**성능 평가 기준**

여기서는 페이지 부재 횟수와 페이지 성공 횟수를 비교

### FIFO

- 처음 올라온 페이지를 스왑 영역으로 보낸다.
  
![](https://images.velog.io/images/pinoa1228/post/5178a31f-a635-4f6b-8d4b-bbdfc0cb1bb8/Untitled%20(6).png)

- 큐로 구현하여, 메모리가 꽉 차면 맨 위의 페이지가 스왑영역으로 가고 나머지 페이지들이 위쪽으로 이동하며, 새로운 페이지가 아래쪽의 남은 공간에 들어온다

**단점**

- 시간 지역성을 고려하여 제일 오래된 페이지를 스왑영역으로 옮겼으나, 오래된 페이지라도 자주 사용되는 페이지가 있는 것 역시 스왑 영역으로 옮겨져 성능이 떨어진다.

페이지 성공 횟수(원래 메모리에 올라와 성공하는 횟수): 3

### OPT

- 앞으로 사용하지 않을 페이지를 스왑 영역으로 옮긴다.
  
![](https://images.velog.io/images/pinoa1228/post/d4c0b76e-ea93-48c2-8b3d-0f8fe5e1afdd/Untitled%20(7).png)

- 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점 부터 사용시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정한다.
- 가장 이상적인 방법이지만 실제로 구현할 수 없다.

### LRU

![](https://images.velog.io/images/pinoa1228/post/4424533b-cea7-463c-90bf-01941445cef5/Untitled%20(8).png)

- 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.
- 최근 최소 사용 페이지 교체 알고리즘
- 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역에 옮긴다.
- 시간을 기준, 카운터나 참조 비트를 이용하는 방법이 있다.

**단점**

- 접근 시간이나 참조 비트를 유지하기 위한 메모리가 추가로 필요하기 때문에 낭비되는 메모리 공간이 많다.

**참조 비트 시프트 방식**

![](https://images.velog.io/images/pinoa1228/post/ed1e16b4-7277-435e-8c3b-d195fa4bba87/Untitled%20(9).png)

- 각 페이지에 일정한 참조 비트를 만들어 사용한다.
- 참조 비트는 0으로 초기화 되고 페이지에 접근 할 때마다 1로 바뀐다.
- 참조 비트는 오른쪽으로 한칸씩 이동한다
- 참조 비트를 갱신하다가 대상 페이지를 선정할 필요가 있으면 참조 비트 중 가장 작은 값을 대상 페이지로 선정한다.

**단점**

- 참조 비트 방식이 작지 않은 공간을 사용하므로 공간을 낭비한다.

**LFU가 아닌 LRU인 이유**

![](https://images.velog.io/images/pinoa1228/post/929d3fb6-f846-4c97-aef6-aa0b95e1944a/Untitled%20(10).png)

C가 가장 많이 접근 했으나 접근한 시각이 가장 오래되어서(참조비트가 제일 오른쪽에 있음) C가 대상 페이지가 된다.

### LFU

![](https://images.velog.io/images/pinoa1228/post/e32a4ed8-af18-4187-acdc-edad7954f1f5/Untitled%20(11).png)

- 페이지가 몇 번 사용되었는지를 기준으로 대상 페이지를 선정
- 현재 프레임에 있는 페이지마다 그동안 사용된 횟수를 세어 횟수가 가장 적은 페이지를 스왑 영역으로 옮긴다.