| 비선점형 알고리즘 | FCFS,SJF,HRN |
| --- | --- |
| 선점형 알고리즘 | RoundRobin,SRT,Multilevel Queue,Multilevel Feedback Queue |
| 둘다 가능 | Priority scheduling |

## 스케줄링 알고리즘의 선택 기준
![](https://images.velog.io/images/pinoa1228/post/d615f81f-1d84-47d2-a6fd-869693ffb84b/image.png)

1. cpu 사용률: 전체 시스템의 동작 시간 중 실제 cpu가 사용된 시간을 측정
2. 처리량: 단위 시간당 작업을 마친 프로세스의 수이다. 처리량이 클수록 좋은 알고리즘이다.
3. 대기 시간 : 프로세스가 생성된 후 실행되기 전까지 대기하는 시간
4. 응답 시간 : 첫 작업을 시작한 후 **첫 번째 출력이 나오기**까지의 시간
5. 반환 시간: 대기시간을 포함하여 실행이 종료될때까지의 시간

**평균 대기 시간**
![](https://images.velog.io/images/pinoa1228/post/553047bb-7f45-439d-8021-dc0a98fcdca3/image.png)

스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기시간을 본다.

(평균 대기시간= 모든 프로세스의 대기시간의 합/프로세스 수)

## FCFS(First Come First Served(선착순))

![](https://images.velog.io/images/pinoa1228/post/ae30f759-21c9-48bc-adfd-d7ca15df9363/image.png)

- 준비 큐에 도착한 순서대로 cpu를 할당하는 비선점형방식, 선입선출 스케줄링이라고도 한다.
- 한번 실행되면 그 프로세스가 끝나야 다음 프로세스를 실행 할 수 있다.
- 큐가 하나로 동작하며 **모든 프로세스의 우선순위는 동일**하다.

### FCFS 성능

![](https://images.velog.io/images/pinoa1228/post/437e7d0c-2891-4087-9610-edda2fcae8d6/image.png)

평균 대기시간=(0+27+42)/3=23

### FCFS 스케줄링 평가

- 처리기간이 긴 프로세스가 cpu를 차지하면 다른 프로세스들은 계속 기다려야한다. 이 때문에 시스템의 효율성이 떨어지는 문제가 있다
- 현재 작업중인 프로세스가 입출력 작업을 요청하는 경우 cpu가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어진다.
- 시분할 시스템에서는 입출력을 요청한 프로세스를 대기 상태로 보내어 처리할 수 있지만, 일괄 작업 시스템에서는 프로세스의 상태 변화가 없기 때문에 작업 효율이 떨어진다.

## SJF(SPF)

![](https://images.velog.io/images/pinoa1228/post/c716f881-02ab-4f5b-8669-1d989f19c6e3/image.png)
- 준비 큐에 있는 프로세스 중에서 실행시간이 가장 짧은 작업부터 cpu 할당
- 비선점형 방식
- 프로세스에 cpu를 배정할 때 시간이 오래 걸리는 작업이 앞에 있고 간단한 작업이 뒤에 있으면 그 순서를 바꾸어 실행한다.
- FCFS 스케줄링에서 보다 시스템의 효율성을 높이는 것이다.

### SJF 스케줄링 성능


![](https://images.velog.io/images/pinoa1228/post/437e7d0c-2891-4087-9610-edda2fcae8d6/image.png)

평균 대기시간= 0+ 24(p3)+36(p2)/3=20

### SJF 스케줄링 평가

- 작은 작업을 먼저 실행하기 때문에 시스템의 효율성이 좋아진다. 먼저 도착한 큰 작업으로 인해 작은 작업이 지연되는 FCFS 스케줄링보다 평균 대기시간이 줄어들어 시스템의 효율성이 높아진다.
- 프로세스의 종료시간을 파악하기 어렵고 아사현상이 일어나기 때문에 잘 사용하지 않는다.
- 운영체제가 프로세스의 종료시간을 정확하게 예측하기 어렵다
    - 과거의 일괄 작업 프로세스는 입출력 작업을 기다리는 것과 같은 상호작용이 없었다. 계산 작업만 끝나면 프로세스가 끝나기 때문에 프로세스의 길이를 정확하게 알 수 있었다. 하지만, 현대 시분할 시스템에서는 입출력 작업으로 인해 대기를 하는 등 사용자와의 상호작용이 빈번하기 때문에 프로세스의 길이를 예측하기가 어렵다.
- 공평하지 못하다
    - p2가 먼저 들어왔음에도 p3같은 프로세스가 계속해서 들어온다면, 프로세스의 작업시간이 길다는 이유로 계속해서 밀리는 상황이 발생할 수 있다. 이런 점은 공평성이 떨어진다고 할 수 있다. 이를 아사현상 또는 무한 봉쇄현상이라고한다.

**보완**

1. 프로세스가 자신의 작업시간을 운영체제에 알려주어 해결할 수 있다. 그러면 운영체제는 프로세스가 제출한 사용시간을 기준으로 SJF 스케줄링을 한다.

     → 프로세스가 정확한 자신의 작업시간을 알기 어렵고 악의적인 프로세스가 작업 시간을 속이면 시스템의 효율      성이 나빠진다.

1. 에이징으로 완화 할 수 있다. 프로세스가 양보 할 수 있는 상한선을 정하는 방식이다.

      프로세스가 자신의 순서를 양보할 때마다 나이를 한살 씩 먹어 최대 몇살까지 양보하도록 하는 것이다.

     → 에이징 값을 어떤 기준으로 정할 것인지가 문제다.

### HRN

- SJF의 아사현상을 해결하기 위해 만들어진 비선점형 알고리즘
- 최소 **응답률** 우선 스케줄링
- 서비스를 받기 위해 기다린시간+ cpu 사용시간을 고려하여 스케줄링한다.
- 우선순위= (대기시간+cpu 사용시간)/cpu 사용시간(우선순위가 큰 순으로 우선순위가 높다)

### HRN 스케줄링의 성능


![](https://images.velog.io/images/pinoa1228/post/7b964756-bc43-4247-80e9-f988bba3975b/image.png)

p2=  (27+18)/18

p3=(24+9)/9

평균 대기시간=(0+24+26)/3=16.xx

### HRN 평가

- 아사 현상을 완화한다
- 대기시간이 긴 프로세스의 우선순위를 높여 cpu 할당 확률을 높인다
- 우선순위 할당에 cpu 사용시간이 개입하므로 완전히 공평하지 않다.

## Round Robin


![](https://images.velog.io/images/pinoa1228/post/68a7c03f-77e1-4f4d-92a2-710bdbc49c56/image.png)

- 한 프로세스가 타임 슬라이스 동안 작업 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
- 선점형 알고리즘
    - 중간에 종료되거나 자발적으로 종료되지 않아도 운영체제에 의해 cpu사용권을 빼앗길 수 있다.
    - 선점형 알고리즘 중에 가장 단순하고 대표적인 방식이다.
- FCFS와의 차이점
    - 유사하지만, 프로세스마다 cpu를 사용할 수 있는 최대 시간, 타임 슬라이스가 있다.

### 라운드 로빈 스케줄링의 성능

![](https://images.velog.io/images/pinoa1228/post/cb6cb602-32d8-4b99-b48b-77a9c9900660/image.png)

타임 슬라이스=10

평균 대기시간=(7+14+19+19+8)/3=22.3

### 라운드 로빈 고려사항

- 타임 슬라이스의 크기와 문맥교환
    - 타임슬라이스의 크기는 프로세스의 반응 시간에 영향을 미칠 뿐아니라 시스템전체 성능에도 영향을 미친다.
    - **타임슬라이스가 너무 작다면** 문맥교환이 빈번하게 일어나고 이러한 추가 시간을 고려한다면 fcfs와 비교해서 항상 효율적이라고 할 수 없다. 또한 **문맥교환에 걸리는 시간이 실제 작업시간보다 상대적으로 커지며** 문맥교환에 많은 시간을 낭비하여 **실제 작업을 못하는 문제가 발생한다**.→ **시스템 성능이 떨어진다.**
    - **타임슬라이스가 큰 경우** 하나의 작업이 끝난 뒤 다음 작업을 하는 것이라 fcfs와 다를것이 없다.
    - 타임슬라이스는 되도록 **작게** 설정하되 문맥 교환에 걸리는 시간을 고려하여 **적당한 크기**로 하는 것이 중요하다.

## SRT

- 라운드 로빈 스케줄링에서 **남아있는 시간이 가장 적은 프로세스**를 선택하는 방식을 더한 스케줄링
![](https://images.velog.io/images/pinoa1228/post/17df97b8-132b-4a8a-8a47-472ae04315a1/image.png)
평균 대기시간=(0+4+16+27)/3=15.xx

### SRT 스케줄링의 평가

- 현재 실행중인 프로세스와 큐에 있는 프로세스의 남은시간을 주기적으로 계산해야하고 남은 시간이 더 적은 프로세스와 문맥 교환을 해야하므로 sjf 스케줄링에는 없는 작업이 추가된다
- sjf와 마찬가지로 운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않는다.

## Priority scheduling

- 프로세스의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘

### 우선순위 적용

- 우선순위는 비선점형 방식과 선점형 방식 모두 적용할 수 있다.
    - SJF(비선점형 방식): 작업시간이 짧은 프로세스에 높은 우선순위를 부여한다.
    - HRD(비선점형 방식): 작업시간이 짧거나 대기시간이 긴 프로세스에 높은 우선순위를 부여한다.
    - SRT(선점형 방식): 남은 시간이 짧은 프로세스에 높은 우선순위를 부여한다.
- 고정 우선순위 알고리즘과 변동 우선순위 알고리즘으로 나뉜다
    - 고정 순위 알고리즘: 한번 우선순위를 부여 받으면 종료될 때까지 우선순위가 고정된다.
        - 변동이 많은 시스템의 상황을 반영하지 못해 효율성이 떨어진다.
    - 변동 우선순위 알고리즘: 일정 시간마다 우선순위가 변한다
        - 계속해서 우선순위를 계산해야해서 시스템이 복잡하지만 시스템 상황을 반영하여 효율적인 운영이 가능하다.

### 우선순위 스케줄링의 평가

- 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 cpu를 할당하므로 공평성을 위배하고 아사현상을 일으킨다.
- 준비 큐에 있는 프로세스 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하기 떄문에 오버헤드가 발생하여 시스템의 효율성을 떨어트린다.
- 프로세스의 우선순위는 시스템의 효율성이 아니라 프로세스의 중요도를 기준으로 결정된다.
    - 커널 프로세스가 일반 프로세스보다 중요하기 때문에 먼저 실행되어야 한다.

## Multilevel Queue


![](https://images.velog.io/images/pinoa1228/post/3773b0f7-512c-4392-a7c0-eb8f98ff3901/image.png)

- 우선순위에 따라 준비 큐를 여러 개 사용하는 방식이다.
- 프로세스는 운영체제로 부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입된다.
- 라운드 로빈 방식으로 운영되는 큐는 우선순위에 따라 다단계로 나뉘어 있어 프로세스가 큐에 삽입 되는 것만으로 우선순위가 결정된다.
- 우선순위에 따라 다양한 스케줄링이 가능한 비선점형 방식이다.→ 전면 프로세스는 반응 속도를 높이기 위해 타임 슬라이스를 작게하고, 후면 프로세스는 사용자와의 상화작용이 없으므로 FCFS 방식으로 처리한다. 프로세스의 우선순위와 작업 형태를 고려하여 스케줄링 할 수 있다.
- 상단의 큐에 있는 작업이 모두 끝나야 하단에 있는 큐 작업이 시작된다.

## Multilevel Feedback Queue

![](https://images.velog.io/images/pinoa1228/post/69433b1d-2c90-4b9e-abb1-086c3f36a677/image.png)

- 우선순위가 낮은 프로세스에 불리한 다단계  큐 스케줄링의 문제점을 보완한 방식
- 다단계 큐 스케줄링과 기본적인 형태가 같다
- 다단계 큐 스케줄링은 각 단계의 큐에 라운드 로빈 방식으로 사용하고 우선순위에는 변화가 없다 하지만 다단계 피드백 큐 스케줄링은 cpu를 사용하고 난 프로세스의 우선순위가 낮아진다.→ 원래의 큐로 돌아가지 않고 우선순위가 낮은 큐의 끝으로 들어간다.
- 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다. → 하지만!! 커널 프로세스가 일반 프로세스의 큐에 삽입되는 경우는 없다
- 우선순위에 따라 타임 슬라이스의 크기가 다르다→ 우선순위가 낮아질 수 록 타임슬라이스 크기가 커진다. 우선순위가 낮은 프로세스는 cpu 할당 받기가 힘들다. 따라서 어렵게 얻은 cpu를 오랫동안 사용할 수 있도록 타임 슬라이스 크기를 크게 설정한다.→ 마지막 큐에 들어온 프로세스는 FCFS로 동잓한다.
- 오늘날의 운영체제가 cpu 스케줄링을 위해 일반적으로 사용하는 방식이다.
- 변동 우선순위 알고리즘의 전형적인 예이다.
- 유닉스 운영체제에서는 타임 슬라이스를 고정하지 않고 조정할 수 있도록 한 이유는 다단계 피드백 큐 스케줄링을 사용하기 때문이다.