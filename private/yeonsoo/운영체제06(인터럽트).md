## 인터럽트 개념

초기 컴퓨터 시스템에는 주변장치가 많지 않았다. **이전에는 폴링 방식으로 cpu가 입출력 장치의 상태를 주기적으로 검사하여** 일정한 조건을 만족할 때 데이터를 처리했다.

오늘날 컴퓨터에는 **많은 주변 장치가 있기 때문에 cpu가 명령어 해석과 실행이라는 본래 역할 외에 모든 입출력에 관여하면 작업 효율이 현저하게 떨어진다.** 따라서 이러한 문제를 해결하기 위해 등장한 것이 인터럽트 방식이다.

예시) 입출력 이외에도 유닉스 프로그램에서 무한 루프가 멈추지 않을때 컨트롤 c를 눌러 멈추는 방식 같은 경우

**동작 방식**

**이벤트 드리븐 방식**(버튼이 눌리면 프로세스에 알려주는 방식)과 마찬가지로 입출력을 요청하고 입출력이 완료되면 이벤트를 발생시켜  입출력 요청이 완료됨을 알린다.

**효과**

1.  **cpu의 작업과 저장장치의 데이터 이동을 독립적**으로 운영함으로써 시스템의 효율을 높인다
2. 데이터의 입출력이 이루어지는 동안 cpu가 다른 작업을 할 수 있다.

### 인터럽트 발생 상황

1. cpu가 입출력 관리자에게 입출력 명령을 보낸다.
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장 장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호를 cpu에 보낸다.
4. 입출력 관리자가 cpu에 보내는 완료 신호를 인터럽트라고 한다. cpu는 입출력 관리자에게 작업 지시를 내린 다른일을 하다가 완료 신호를 받으면 하던일을 중단하고 옮겨진 데이터를 처리한다


## 동기적 인터럽트, 비동기적 인터럽트

### 동기적 인터럽트(사용자 인터럽트)

- 실행중인 명령어로 인해 발생하는 인터럽트
- 프로그램상의 문제로 발생하는 인터럽트→ 다른 사용자의 메모리 영역에 접근하는 경우등등
- 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트(예: 컨트롤 c)
- 입출력장치 같은 주변장치의 조작에 의한 인터럽트
- 산술 연산 중 발생하는 인터럽트(예: 0으로 나눔)

### 비동기적 인터럽트

- 실행 중인 명령어와 무관하게 발생하는 인터럽트
- 하드웨어적인 오류로 발생하는 인터럽트 (예: 사용자가 직접 동작하는 키보드 인터럽트, 마우스 인터럽트)

## 인터럽트 처리과정

![](https://images.velog.io/images/pinoa1228/post/c1b97e56-0a14-4ae2-a87e-00b7d6af5e3a/image.png)
### 인터럽트 벡터

- 인터럽트의 집합
- 인터럽트가 일어나면, 인터럽트 번호에 해당하는 벡터 번호가 0에서 1로 변경된다
- 각 **벡터**는 각각의 **인터럽트**와 그 **인터럽트를 처리하는 함수인 인터럽트 핸들러**가 일대일로 연결되어 있다.

### 인터럽트 핸들러

인터럽트 핸들러는 기본적인 인터럽트들은 정의되어 있고, 사용자가 이를 다시 정의할 수 도 있다.

(예: 컨트롤 c후에 프로세스가 종료되지만 종료되지 않고 계속 작업이 진행되도록 인터럽트 핸들러를 다시 정의할 수도 있다.)

### 처리과정

1. 인터럽트가 발생하면 현재 실행 중인 프로세스는 일시 정지 상태가 되며, 재시작하기 위해 현재 프로세스 관련 정보를 임시로 저장한다.
2. **인터럽트 컨트롤러**가 실행되어 인터럽트의 처리 순서를 결정한다. 이때 **여러개의 인터럽트가 동시에 발생했다**면, **인터럽트의 우선순위를 고려하여 중요한 인터럽트부터** 처리하도록 순서를 결정한다. 
3. 먼저 처리할 인터럽트가 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러가 실행된다.
4. 인터럽트 벡터에 연결된 핸들러가 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료된다.(발생한 인터럽트가 입출력 완료 같은 경우에는 일시 정지된 프로세스가 다시 실행되고, 다른 프로세스의 메모리 영역 침범이나 오류 같은 경우이면 종료된다.)

## 인터럽트와 이중모드

프로세스는 커널 프로세스와 사용자 프로세스로 나뉜다.

### 커널 프로세스

- 운영체제와 관련된 커널 프로세스가 실행되는 상태

### 사용자 프로세스

- 사용자 프로세스가 실행되는 상태

### 이중 모드

사용자와 커널 두 모드을 전환하며 일 처리 하는 것

**상황**

사용자 프로세스가 커널의 기능(하드디스크 입출력, 프로세스 생성)을 사용하기 위해 시스템 호출을 이용하여 커널 프로세스에 작업을 요청했을때 

1. 사용자 프로세스는 시스템 호출을 요청한 후 대기 상태로 전환
2. 커널 프로세스는 요청받은 작업을 처리

사용자 모드에서 커널 모드로 전환된다.

**목적**

운영체제가 자원을 보호하기 위해 사용하기 위함

→ 사용자 프로세스가 시스템 자원에 직접 접근하면 문제가 발생할 수 있기 떄문에 커널은 시스템 호출을 이용해서만 자원에 접근하도록 한다.

### 시스템 호출과 API

![](https://images.velog.io/images/pinoa1228/post/59ad3d3d-405e-4442-8ff5-0f865d3386f9/image.png)

사용자가 자원에 접근하려면 시스템 호출을 사용해야하는데  커널이 제공하는 시스템 호출은 사용하기 어렵고 제한적이다 따라서 API를 제공하여 사용자는 시스템 호출을 사용하고, API가 준비해놓은 다양한 함수를 이용하여 시스템 자원에 접근 할 수 있다.

- 사용자→ 커널
1. 시스템 호출(자신이 원해서 진입하는 것이라 자발적)
2. 인터럽트 발생(인터럽트에 의해 커널 모드(예를들어 입출력작업)에 진입, 비자발적)

## DMA(Direct Memory Access) 직접 메모리 접근

입출력 장치와 메모리 사이 데이터 흐름에서 CPU를 배제하기 위해 사용하는 입출력 제어 방식

### 기본적인 입출력 제어 방식

---

![](https://images.velog.io/images/pinoa1228/post/4593669d-57b3-4a36-b72a-d1602ded2c8a/image.png)

예를 들어 하드디스크에서 메모리로 데이터를 이동시킨다면

1. 하드디스크에서 데이터를 꺼낸다
2. 시스템 버스를 통해 CPU 레지스터에 옮겨진다
3. 시스템 버스를 통해 CPU 레지스터에서 메모리로 이동한다

**문제점**

- cpu를 거쳐가기 때문에 지연시간 존재
- 입출력시간 동안 CPU는 아무 것도 하지 않고 대기 하고 있다→ 입출력 장치보다 CPU는 고속이기 때문에 그 시간을 낭비하는 것은 비효율적!!

### DMA

---

기존의 입출력 방식의 단점을 보완하고자 입출력 장치가 CPU를 거치지 않고 메모리에 직접 접근하도록 한다

→ 인터럽트 방식이 프로그램에 의한 입출력 방식(폴링 방식)보다는 효율적이지만 입출력을 위한 상태,제어정보, 데이터 전송을 위해서는 능동적인 CPU의 개입이 필요하기 때문에 오버헤드 발생 가능

![](https://images.velog.io/images/pinoa1228/post/2239c98e-b5e1-464f-8bb3-3becb5f80420/image.png)

- 하드 디스크와 메모리를 직접 연결하여 CPU는 제어 신호만 주고 받고, 데이터 전송 흐름에서는 제외시킨다
- 입출력시 CPU는 제어를 위해 데이터 전송 시작과 완료에만 할당 되어 CPU 자원 장비를 줄일 수 있다.
- 고속 입출력 장치의 경우 빈번한 인터럽트가 발생하는 것을 DMA를 사용함으로써 프로그램 수행 중 인터럽트의 발생 횟수를 최소화 한다.

### 동작 순서

---

1. 입출력 장치가 CPU에게 입출력을 요청한다.
2. CPU가 DMA 컨트롤러에 명령을 송신한다.
3. DMA가 CPU에게 시스템 버스 사용 요청을 한다.
4. CPU가 버스 사용을 허가한다→ CPU가 버스사용을 포기하는 것이다.
5. DMA 컨트롤러가 입출력 장치에서 데이터를 읽은 후 메모리로 전송한다.
6. 전송 완료후 CPU에게 완료 신호를 송신한다.

### 동작 모드

---

1. 사이클 스틸링:
    1.  DMA 컨트롤러와 CPU가 동시에 버스를 사용하고자 할때 속도가 빠른 CPU가 속도가 느린 DMA에 우선순위를 주어 빠른 입출력이 가능하게 하는 방법 
    2. 한번에 한 워드 정도의 데이터 전송

**인터럽트 vs 사이클 스틸링**

1. 인터럽트는 인터럽트가 해제될 때 까지 장기간 정지하지만 사이클 스틸링은 버스 사용을 위해 CPU를 한 사이클동안만 정지한다.
2. 인터럽트는 프로그램 상태 보존이 필요하지만, 사이클 스틸링은 필요하지 않다.

1. 버스트 모드
    1. 블록 단위 데이터 전송시 사용
    2. 여러 개의 메모리 워드로 구성된 블록이 지속적으로 전송된다.
    3.  DMA가 버스 사용권 획득 시 데이터 전송 완료까지 버스 사이클 독점