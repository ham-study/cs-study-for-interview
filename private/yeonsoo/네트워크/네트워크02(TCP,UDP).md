- **전송계층**에서 데이터를 보내기 위해 사용하는 프로토콜

## TCP

- 전송계층에 속하는 프로토콜로 네트워크 망에 연결된 컴퓨터의 프로그램간 데이터를 순서대로 에러 없이 교환할 수 있도록 한다.

**특징**

- **연결형 서비스**로 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정하는 가상 회선 방식을 제공한다.
- 논리적인 연결으로 데이터를 주고 받음으로써 데이터를 순서를 보장해준다. 따라서 **데이터를 정확하고 안정적으로 전달할 수 있다.**
- 스트림 기반의 전송 방식을 통해 데이터를 임의의 크기로 나누어 연속해서 전송하는 방식을 사용한다.
- TCP는 **신뢰성** 있는 데이터 전송한다.
    - 신뢰성 있는 데이터 전달과 흐름제어, 혼잡제어, 오류제어를 한다.
    - 패킷을 성공적으로 전송하면 ACK라는 신호를 날리고 만약에 ACK가 시간안에 도착하지 않았다면 time-out이 발생하여 패킷 손실이 발생한 패킷을 다시 전송해준다.
- 수신측에 데이터가 전송되면, TCP는 순차적으로 패킷이 가는 것을 확인하기 위해 번호를 붙여 추적한 후 재조립을 한다
- **높은 신뢰성**을 보장하려다 보니 UDP보다 **속도가 느리다.**
- Full-Duplex, Point to Point 방식

**단점**

- 속도가 느리다.
- 1:1 통신만 가능하다.
- 고정된 통신 선로가 최단길이가 아닐 경우 상대적으로 UDP보다 전송속도가 느리다.

**TCP 패킷 추적 및 관리**

데이터를 패킷단위로 나누어 같은 IP에 보낼때 A,B,C라는 패킷이 순차적으로 가는 것을 확인하기 위해서 패킷에 1,2,3이라는 번호를 붙여 패킷의 분실 확인 처리를 한 후 목적지에서 재조립한다.

### 3way-handshake

1. 클라이언트에서 서버에 연결 요청을 하기 위해 SYN을 보낸다.
2. 서버에서 해당 포트는 LISTEN 상태에서 SYN을 받고 SYN_RCV로 상태가 변경된다.
3. 서버는 클라이언트한테 **요청을 정상적으로 받았다는 ACK**와 **클라이언트 포트를 열어달라는 SYN**을 같이 보낸다.
4. 클라이언트에서는 SYN+ACK를 받고 ESTABLISHED로 상태를 변경하고 서버에 ACK를 전송한다.
5. ACK를 받은 서버는 상태가 ESTABLISHED로 변경된다.

→ 위 과정이 정상적으로 이루어 지면 서로의 포트가 ESTABLISHED되면서 연결이 된다.

→ 이 과정에서 많은 시간이 소요되어 UDP 방식보다 속도가 느려지는 원인이다.

### 4way-handshake

1. 클라이언트에서 서버와 연결 종료를 위해 서버에 FIN 패킷을 보내고 FIN_WAIT1상태가 된다
2. 서버는 클라이언트로부터 FIN을 받고 응답 패킷 ACK을 보낸다→ CLOSE_WAIT가 된다.
3. 서버가 통신이 끝나면, 클라이언트에게 FIN 패킷을 보내고 LAST_WAIT상태가 된다
4. 클라이언트는 확인 패킷 ACK을 보내고 TIME_WAIT 상태가 된다.

### 흐름제어

- 흐름제어는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것이다.
- 송신하는 곳에서 감당이 안되게 데이터를 빠르게 많이 보내면 전송된 패킷은 수신측의 큐를 넘어서 손실 될 수 있기 때문에 송신 측의 패킷 전송량을 제어해야한다.

**방법**

1. stop-and- wait
    1. 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다.→ 비효율적
2. 슬라이딩 윈도우
    1. 수신측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게하여 데이터 흐름을 동적으로 조절한다.→ 송신측에서 ack 없이 여러개의 프레임을 연속적으로 전송할 수 있다.
    2. 송신측에서 ack를 받으면 그 만큼 윈도우 크기를 늘려준다.

### 혼잡제어

- 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것이다.
- 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우에 호스트들은 재전송을 하게되고 결국 혼잡을 가중시켜 오버 플로우나 데이터 손실이 발생한다.

### 오류제어

오류 검출과 재전송을 포함한다.

- ARQ기법을 사용하여 프레임이 손상되었거나, 손실되었을 경우, 재전송을 통해 오류를 복구 한다.
1. stop-and- wait ARQ
    1. **송신 측에서 1개의 프레임을 송신하고** 수신측에서 수신된 프레임의 에러 유무에 따라 ACK나 NAK을 보내는 방식이다.
    2. 식별을 위해 데이터 프레임과 ack프레임은 각각 0,1번호를 번갈아 가며 부여한다.
    3. 수신측에서 데이터를 받지 못했을 경우 NAK을 보내고 송신측에서는 데이터를 재전송한다.
    4. 데이터나 ACK가 분실되었을 경우 일정시간을 두고 타임 아웃이 되면  데이터를 재전송한다.
2. go-back-nARQ
    1. **연속적**으로 프레임을 전송하는 방식이다.
    2. 전송된 프레임이 손상되거나 분실된 경우, ACK 손실로 인한 타임 아웃이 발생한 경우 확인된 마지막 프레임 이후 모든 프레임을 재전송한다.
    3. **슬라이딩 윈도우는 연속적으로 프레임 전송 기법**으로 전송 측은 전송된 프레임의 복사본을 가지고 있어야 하며 ACK, NAK을 각각 구별해야한다.
    4. ACK: 다음 프레임을 전송해라
    5. NAK: 손상된 프레임 자체 번호를 반환해라
    6. 수신측에서 데이터를 받지 못하거나 손상된 경우 해당 번호 이후 데이터를 모두 폐기하고 해당 번호에 대한 NAK를 보낸다. 송신측에서 NAK를 받으면 그 이후 번호에 해당하는 데이터를 모두 보낸다.
3. SR ARQ
    1. go-back-nARQ의 마지막 프레임 이후의 모든 프레임을 재전송하는 단점을 보완하는 기법
    2. 손상되거나 **손실된 프레임만 재전송**한다.→ 별도의 데이터 재정렬을 수행해야하고, 별도의 버퍼를 필요로 한다.
    3. 수신측에서 버퍼를 두고 받은 데이터의 정렬이 필요하다.

### TCP 헤더 정보

- Source Port(16 bits) : 출발지(송신) 포트 번호
- Destination Port(16 bits) : 목적지(수신) 포트 번호
- Sequence Number(32 bits) : 송신 데이터 순서 번호
    - 송신 시 전송하는 데이터의 시작 바이트 순번을 담는다. 바이트 순번은 전송하는 데이터의 바이트 단위로 부여하는 연속된 번호를 의미한다.
    - 연결설정 단계에서 초기 순서 번호를 상호간에 주고받는다, 초기 순서 번호는 0부터 시작하는 것이 아니라 임의의 수를 할당해서 사용한다.
- Acknowledgment Number(32 bits) : 상대방이 다음에 전송할 순서 번호
    - 수신 확인 응답(ACK)과 함께 해당 필드에 상대방이 다음에 전송할 순서 번호를 담아서 보낸다.
- HLEN(4 bits) : 헤더 길이
    - 4 bits 워드 단위로 표시(20 ~ 60 bytes)하며 기본 헤더 20 bytes와 옵션 헤더 최대 40 bytes로 구성된다.
- Reserved(4 bits) : 예약
- Control Flags(6 bits)
    - URG(Urgent pointer is valid) : 긴급 데이터 설정
    - ACK(Acknowledgment is valid) : 수신 확인 응답(ACK) 설정
    - PSH(Request for push) : 송수신 버퍼에 있는 데이터를 즉시 처리
    - RST(Reset the connection) : 연결 중단(강제 종료)
    - SYN(Synchronize sequence numbers) : 연결 설정
    - FIN(Terminate the connection) : 연결 종료 (정상 종료)
- Window size(16 bits)
    - 수신측에서 송신측에 보내는 Receiver window size로 수신버퍼의 여유공간 크기를 의미한다. 송신측에서는 상대방의 여유 공간 크기를 통해서 흐름제어를 수행할 수 있다.
    - 따라서 송신측에서는 상대방의 윈도우 사이즈 범위 내에서 수신측의 수신 확인 응답(ACK)을 기다리지 않고 연속적으로 전송할 수 있는데 이를 슬라이딩 윈도우 제어방식이라 한다.
- Checksum(16 bits) : 헤더를 포함한 전체 세그먼트에 대한 오류를 검사하기 위한 필드
- Urgent Pointer(16 bits) : 세그먼트가 긴급 데이터(URG 플래그 설정)를 포함하고 있는 경우에 사용되는 필드로 긴급 데이터의 위치값을 담고 있다.

## UDP

- 전송계층에 속하는 프로토콜 중 하나
- TCP와는 다르게 비연결형 프로토콜이다.

**특징**

- 비연결형 서비스로 데이터 그램 방식을 제공한다
    - 논리적인 경로가 없어서 데이터 그램 전송시 마다 주소 정보를 설정해서 전송한다.
    - 데이터의 순차적 전송을 보장해주지 않는다.
    - 데이터 그램기반의 전송 방식을 사용한다→ **데이터를 정해진 크기**로 전송하는 방식을 사용
- 신뢰성이 낮다
    - TCP와 다르게 흐름제어, 오류제어, 혼잡제어를 수행하지 않는다.
    - IP기반에 포트 정보를 이용해서 상위 송수신 어플리케이션을 식별해주는 역할 정도만 수행한다.
    - UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- TCP보다 속도가 빠르다.
    - TCP와 다르게 연결을 설정하거나 해제하는 과정이 존재하지 않고 서로 다른 경로로 독립적으로 처리하여 패킷에 순서를 부여하여 재조립하거나 흐름제어와 같은 기능을 처리하지 않는다.
    - 속도가 빨라 네트워크 부하가 적다.
- 신뢰성보다는 **연속성이 중요한** 서비스이다.→ streaming에 사용된다.
- 서버와 클라이언트는  1대1, 1대 N, N대M 등으로 연결될 수 있다.

비연결형 서비스로 연결을 설정하거나 해제하는 과정이 존재하지 않는다. 서로 다른 경로로 독립적으로 처리하여 패킷에 순서를 부여하여 재조립하거나 흐름제어와 같은 기능을 처리하지 않아 TCP보다 속도가 빠르며 네트워크 부하가 적다. 하지만 신뢰성있는 데이터의 전송을 보장하지 못하기 때문에 신뢰성보다는 연속성이 더 중요한 서비스에 많이 사용된다.

### UDP  프로토콜 구조


- source port: 출발지 포트 번호
- destination port: 목적지 포트 번호
- total length: 헤더와 데이터를 모두 포함한 길이
- check sum: 전체 데이터 그램에 대한 오류를 검사하기 위한 필드

### TCP VS UDP

**공통**

- 포트 번호를 이용하여 주소를 지정한다
- 오류검사를 위한 체크섬이 존재한다.

![](https://images.velog.io/images/pinoa1228/post/578f5cc3-53a6-4217-a424-6e4c4cfc59f7/Untitled%20(12).png)


