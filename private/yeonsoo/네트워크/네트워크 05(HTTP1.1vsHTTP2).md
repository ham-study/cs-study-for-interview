## HTTP1.1(표준 프로토콜)

### 동작 방식

- 기본적으로 한 connection당 하나의 요청을 처리하도록 설계한다.
- **동시 전송이 불가능** 하고 요청과 응답이 순차적으로 이루어진다.
- HTTP문서 안에 포함된 다수의 리소스를 처리하려면 **요청할 리소스 개수에 비례해서 대기시간은 길어진다.**

### 단점

- 연결당 하나의 요청과 응답을 처리하기 때문에 **동시 전송 문제**와 다수의 리소스를 처리하기에 **속도와 성능 이슈**가 존재한다.
1. **HOL (Head Of Line) Blocking 으로 패킷의 처리속도 지연**
- 네트워크에서 같은 큐에 있는 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다.
- 파이프 라이닝에서 하나의 커넥션에서 한번에 순차적인 요청을 연속적으로 하고 그 순서에 맞춰 응답을 받는 방식으로 **지연 시간을 줄이도록 했다.** 하지만 하나의 응답이 지연될 시 해당 응답이 완료될 때 까지 다음 요청은 무한 대기 상태가 된다.

![](https://images.velog.io/images/pinoa1228/post/b641a695-3203-4754-b5c6-841a3e621e7a/Untitled%20(13).png)!

1. **RTT(Round Trip Time) 증가**
- 파이프 라이닝 문제를 해결하고자 여러개의 connection을 두어 병렬적으로 처리하도록 하였다.
- 일반적으로 하나의 connection에 하나의 요청을 처리하게 되어서 요청 별로 connection을 만들어야한다
- 이 과정에서 TCP상에서 동작하는 HTTP의 특성상 **3-way Handshake가 반복적으로 일어나 오버헤드가 생기고** 또한 **불필요 한 RTT증가**로 네트워크 지연을 초래하여 성능을 저하시킨다.

1. **헤비한 헤더 구조**
- HTTP 1.1 헤더에는 많은 메타 정보들이 저장되는데, 사용자가 방문한 웹페이지는 다수의 HTTP 요청이 발생하게 된다.
- 이 경우에 매 요청 시마다 중복된 헤더 값을 전송하게 되고, 해당 도메인에 설정된 쿠키 정보도 매 요청시 헤더에 포함되므로 전송하려는 값보다 헤더 값이 더 클 수가 있다.

## HTTP2

- HTTP1.1을 해결하고자 등장 했으며 HTTP2.0은 성는 뿐만 아니라 속도면에서도 1.1보다 월등하다.
- 바이너리 프레이밍 계층을 사용하여 요청과 응답의 멀티 플렉싱을 지원한다.
- HTTP 메세지를 바이너리 형태의 프레임으로 나누고 전송 후 받은 쪽에서 다시 조립한다. 요청과 응답이 동시에 이루어지니 하나의 연결에 여러 요청과 응답이 뒤섞여 있다.
- 프레이밍 작업은 서버와 클라이언트에서 해주기 때문에 큰 변경사항을 고려하지 않아도 된다.

**향상 방법**

1. 요청,응답 다중화
   
(https://images.velog.io/images/pinoa1228/post/e7dce25e-e28e-48bd-a091-964e9db7e6de/Untitled%20(14).png)

- HTTP1.1에서는 클라이언트가 **병렬 요청**을 하려는 경우 여러개의 TCP 연결이 이루어져야한다.

      따라서 **연결당 한번에 하나의 응답을 주는 것과 기존 TCP 연결의 비효율적 사용**이 문제가 된다.

- HTTP2에서는 전체 요청 및 응답을 다중화 한다.
    - 클라이언트와 서버가 HTTP 메세지를 바이너리 형태의 프레임으로 나누고 전송 후 받은 쪽에서 다시 조립한다.
    
    **효과**
    
    - HOL 차단 해결
    - 여러개의 연결이 없어도 요청, 병렬처리가 가능하다.

1. Multiplexed Streams
    - 한 커넥션에 **여러 개의 메세지를 동시에** 주고 받을 수 있다.
        - TCP연결을 더 효율적으로 사용할 수 있으며 전반적인 프로토콜 오버헤드를 줄일 수 있다.
        - 3-way-handshaking이 줄고 세션 재사용률이 향상되며 클라이언트나 서버의 리소스가 감소한다.
2. Stream Prioritization
- 요청 리소스간의 **의존관계(우선순위)**를 설정할 수 있다.
- ex) 클라이언트가 요청한 HTML 문서 안에 CSS파일 1개와 이미지 파일 2개가 존재하는데 만약 이미지 파일 보다 CSS파일의 수신이 늦어지는 경우 브라우저 렌더링이 늦어질 수 있다. 이 것을 리소스간의 우선순위를 정함으로써 해결이 가능하다
1. Server Push
- HTML문서 상에 **필요한 리소스**를 **클라이언트 요청 없이** 보낼 수 있다.
- 클라이언트가 HTML문서를 요청할 시 해당 HTML에 여러개의 리소스(이미지,js,css)가 포함될 경우
    - HTTP 1.1은 HTML문서를 해석한 후 필요한 리소스를 요청한다.
    - HTTP 2에서는 재요청 없이 Server Push 기법을 사용하여 서버 필요한 리소스를 미리 파악하여 바로 전송해준다.
1. Header Compression
- 헤더 정보를 HPACK 압축 방식을 이용하여 압축하여 전송한다.
- ex) 클라이언트가 두번의 요청을 보낼때
    - HTTP1.1은 두개의 요청 헤더에 중복값이 존재해도 그냥 중복 전송을 진행한다.
    - HTTP2에서는 헤더에 중복값이 존재하는 경우 static/Dynamic header Table 개념을 사용하여 중복 헤더를 검출하고 **중복된 헤더는 index값만 전송하고** **중복되지 않은 정보 값은 하프만 코딩 기법으로 인코딩하여 전송한다.**


### 용어 설명

**스트림**

커넥션 내에서 양방향 통신을 하고, 하나 이상의 메세지를 전달할 수 있다.

**메세지**

요청 또는 응답 메세지에 매핑되는 프레임의 전체 시퀀스를 의미한다.

**프레임**

HTTP2에서 통신 최소 단위이다. 프레임에는 프레임 헤더가 포함된다.

프레임 헤더는 최소한으로 프레임이 속하는 스트림을 식별할 수 있다.