# 웹서버, 웹 애플리케이션 서버

### 웹

- HTTP 기반 통신
- 요즘은 모든것을 HTTP로 데이터를 주고 받는다.

## 웹 서버

- HTTP 기반으로 동작한다.
- **정적 리소스를 제공**하고 기타 부가기능을 한다
- 정적 리소스→ HTML,CSS,JS,이미지 영상
- nginx,아파치

## WAS

- HTTP 기반으로 동작
- 웹서버 기능을 포함한다(특히 정적 리소스 제공 부분)
- **프로그램 코드를 실행**해서 **애플리케이션 로직 수행**
    - 동적 HTML, HTTP API(JSON)→ REST API
    - 서블릿, JSP, 스프링 MVC
- 예) 톰캣, Undertow

### 차이

- 웹서버는 정적 리소스(파일) WAS는 애플리케이션 로직
    - 웹서버는 정적 리소스를 주기 때문에 특정 사용자마다 다른 페이지를 줄 수 없다 하지만 WAS에서는 프로그램 코드를 실행해서 애플리케이션 로직을 수행하기 때문에 사용자에 따라 다른 결과를 보여 줄 수 있다.
- WAS는 애플리케이션 코드를 실행하는데 더 특화 되어 있다.

## 웹 시스템 구성

### 초기

- WAS,DB로 구성 가능하다
- WAS는 정적 리소스와 애플리케이션 로직 모두 제공이 가능하다

**문제점**

1. 너무 많은 역할을 담당하게 되어 서버 과부하를 초래한다.
2. 중요한 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있다.
3. WAS 장애시 오류 화면도 노출이 불가능하다.

### 문제를 보완한 웹 시스템


- WEB Server,WAS,DB
- 정적 리소스는 웹 서버가 처리
- 컨테이너를 두어 웹서버가 보낸 파일들을 실행하고 로직 수행결과를 다시 웹서버로 보내준다.
- 웹서버는 애플리케이션 로직 같은 동적인 처리가 필요하면 WAS에 요청을 위임한다.

**장점**

- WAS는 **중요한 애플리케이션 로직 처리**를 전담하여 집중 할 수 있다.
- 효율적인 리소스 관리를 할 수 있다.
    - 정적 리소스가 많이 사용되면 웹서버 증설
    - 애플리케이션 리소스가 많이 사용되면 WAS 증설

- WAS, DB장애시 웹서버가 오류 화면을 제공할 수 있다.
- 여러대의 WAS를 연결해 로드 밸런싱 용도로 사용할 수 있다.

→ 데이터만 주고 받는 서버인 경우 굳이 웹서버를 두지 않아도 된다.

# CORS

Cross-Orgin-Resorce-Sharing의 약자로 브라우저에서 다른 출처의 리소스를 공유하는 방법이다.

**출처(Orgin)**

URL 구조에서 프로토콜, 호스트, 포트를 합친 것이다.

### 동일 출처 정책(Same-Orgin-Policy)

 브라우저가 동일 출처 정책을 지켜서 다른 출처의 리소스 접근을 금지하는 것이다.

동일 출처 정책을 지키면 외부 리소스를 가져오지 못해 불편하지만,XXS나 XSRF등의 보안 취약점을 노린 공격을 방어할 수 있다.

하지만 외부 리소스를 가져오는 것은 필요하기 때문에 방법이 필요하다. 따라서 CORS를 SOP의 예외 조항으로 보고 있다.

- 실제로 웹페이지는 자주 다른 출처의 리소스를 사용해야한다.
    
    ex) localhost:3000→localhost:8080 요청
    

## CORS 동작 원리

동작 방식은 단순 요청 방법과 예비 요청을 먼저 보내는 방법이 있다.

### Simple request

단순 요청 방법은 서버에게 바로 요청을 보내는 방법이다.


1. 서버에 API를 요청한 후 서버는 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보낸다.
2. 브라우저는 헤더를 확인 한 후 CORS 동작 여부를 판단한다.

**Simple request 조건**

서버로 전달하는 요청에 3가지 조건이 만족해야 단순 요청으로 동작한다.

1. 요청 메소드는 GET,POST, HEAD 중 하나여야 한다.
2. Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안 된다.
3. Content-Type 헤더는 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나를 사용해야 한다.

→ 사용자 인증에 사용되는 Authorization헤더도 포함되지 않고, Content-Type으로 application/json을 사용하기 때문에 지켜지기 어려운 조건이다.

### Preflight request

Preflight 요청은 **서버에 예비 요청을 보내서 안전한지 판단 후** 본 요청을 보내는 방법이다.

1. 리소스를 요청하기 전에 OPTION이라는 메소드를 통해 예비요청을 먼저 보낸다.
2. 서버는 예비 요청에 대한 응답으로 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보낸다.
3. 브라우저는 단순 요청과 동일하게 Access-Control-Allow-Origin 헤더를 확인해서 CORS 동작 여부를 판단한다.

### Credentialed Request

HTTP 쿠키와 인증 정보를 인식하는 것으로 좀더 보안을 강화하고 싶을 때 사용한다.

별도의 옵션없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는다. 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 Credentials 옵션이다.

이 옵션에서 총 3가지 값을 사용할 수 있다.

1. same-orgin(기본값): 같은 출처 간 요청에만 인증 정보를 담는다.
2. include: 모든 요청에 인증정보를 담는다.
3. omit: 모든 요청에 인증 정보를 담지 않는다.

## CORS 해결 방법

**서버**

Access-Control-Allow-Origin 헤더를 세팅해준다.

**클라이언트**

클라이언트와 서버 사이에 프록시 서버를 둬서 헤더를 추가 해주거나, 요청을 허용/거부 하는 역할을 하게 한다.

→ 중간 단계가 존재하여 속도가 느려지는 단점이 존재한다.