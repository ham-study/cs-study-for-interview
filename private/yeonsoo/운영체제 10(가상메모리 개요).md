## 가상 메모리 정의

- 실제 물리 메모리에 프로세스의 일부분만 올려놓고 사용하는 것이다.
- 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다.
- 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다.

**동작**

- 물리 메모리와 스왑 영역을 합쳐서 관리한다
- 물리메모리가 꽉 찼을 때 메모리 관리자가 일부 프로세스를 스왑 영역으로 내보내고, 프로세스가 작업을 마치면 스왑 영역에서 다시 메모리로 가지고 온다.

## 가상 메모리 필요성

- 하나의 프로세스에서 특정 시간동안 쓰는 메모리 영역은 아주 일부분이기 때문에 일부분만 실제 메모리에 올려놓고자 하였다.
- 프로세스 메모리 영역 간 침범 가능 이슈 때문에 사용한다.

## 페이징 기법

프로세스의 일부분을 메모리에 올릴때 어느 정도의 사이즈 만큼 메모리에 올릴지에 대한 결정이 필요하다. 따라서 이 것을 페이지 단위로 나누어 결정한다.

- 고정 분할 방식을 이용한 가상 메모리 관리 기법
- 물리 주소 공간을 같은 크기로 나누어 사용한다.
- 가상 메모리 공간을 같은 크기로 나눈 하나를 페이지라고 하고 번호를 매겨 관리한다.
- 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임이라고 부른다. 페이지와 마찬가지로 번호를 매겨 관리하고 페이지와 프레임의 크기는 같다.
- 페이지와 프레임의 크기가 같으므로 페이지는 어떤 프레임에도 배치될 수 있다.
- 페이지 번호를 기반으로 가상 주소와 물리 주소의 매핑 정보를 기록하고 사용한다.

### 주소변환

- 주소 변환 과정(페이지, 프레임당 10B)
    - 읽기(30번지)
    1. 가상 주소 30번지가 어느 페이지에 있는지 찾는다.→ 페이지 3의 0번째 위치
    2. 페이지 테이블에서 페이지 번호가 3이 어디에 있는지 찾는다→ 프레임1
    3. 물리 메모리의 프레임 1의 0번째 위치에 접근한다.
    - 쓰기(18번지에 값 저장)
    1. 가상 주소 18번지가 어느 페이지에 있는지 찾는다→ 페이지 1의 8번째 위치
    2. 페이지 테이블에서 페이지 1이 어디에 있는지 찾는다→ 프레임 3
    3. 프레임 3의 8번째 위치에 값을 저장한다.
- 정형화된 주소 변환
    - VA=<P,D>→PA=<F,D>: P번째 페이지에 D번째 주소를 F번째 프레임의 D번째 주소로 변환한다.
    - P= 가상 주소를 한페이지의 크기로 나눈 몫
    - D= 가상 주소를 한페이지의 크기로 나눈 나머지

### **페이지 테이블**

- 페이지 테이블에는 가상 주소와 물리 주소간 매핑 정보가 있다.

**관리**

- 페이지 테이블은 메모리 관리자가 자주 사용하는 자료구조 이므로 필요시 빨리 접근할 수 있도록 물리 메모리 영역중 운영체제 영역의 일부분에 모아 놓는다.
- 페이지 테이블에는 페이지 번호, 가상주소, 물리 주소, valid-invalid bit 정보가 저장된다→ 해당 페이지가 현재 물리 메모리에 올라가 있는지를 나타낸다.
- 페이지 테이블에 빠르게 접근하기 위해 각 페이지 테이블의 시작 주소를 저장하는 페이지 테이블 기준 레지스터(PTBR)이 존재하고 이것은 각 프로세스의 PCB에 위치한다.

### 페이지 테이블 매핑 방식

- 시스템에 여러개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문에 프로세스가 많아지면 테이블 개수가 많아지며 실제 사용할 메모리 영역이 줄어들게된다.→ 크기를 적절히 유지 해야한다.
- 페이지 테이블도 스왑 영역으로 옮겨질 수 있다.

**직접 매핑** 

- 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재(스왑 영역X)
- 메모리가 충분한 경우 사용, 주소 변환이 빠르다.

**연관 매핑**

- 페이지 테이블 전체를 스왑영역에 저장하고 일부 페이지만 물리 메모리에 무작위로 불러온다(캐시 시스템과 유사하다.)
- 페이지 테이블의 일부(TLB 또는 연관 레지스터)만 물리 메모리에서 관리하기 때문에 페이지 번호와 프레임 번호를 둘다 표시한다.
- 원하는 프레임 번호가 테이블에 있는지 모르기 때문에 전부 검색해야 한다. 만약에 메모리상에 없으면(TLB 미스 발생) 스왑 영역에서 다시 검색해야 하므로 시간이 오래 걸린다.

TLB 미스: TLB에 없는 경우, TLB가 발생하면 주소변환이 느려진다.

**집합- 연관 매핑**

- 연관 매핑과 유사하지만, 페이지 테이블을 여러 개의 영역으로 자르고 각 영역에 대한 집합 테이블을 통해 현재 특정 영역이 메모리 상에서 어디에 위치해 있는지 표기한다.
- 디렉토리 테이블을 통해 해당 묶음이 현재 메모리에 있는지, 스왑영역에 있는지를 표시한다.
- 디렉토리 테이블을 상펴보면 원하는 테이블 묶음이 어디에 있는지 알수 있어서 전체테이블을 찾아보지 않아도 TLB 미스를 바로 알 수 있다.
- ex) 각 페이지 테이블 집합이 페이지 0~4, 5~9, 10~14,..일때, 집합 2가 물리 메모리 상에 위치해 있다면, 집합 테이블의 2번에 해당 주소가 명시되어 있다.
- 모든 테이블을 검색할 필요가 없이 바로 TLB 미스를 알 수 있다.

**역 매핑**

- 프로세스의 수와 상관없이 하나의 테이블로 관리된다→ 테이블이 차지하는 공간이 작다
- 페이지→ 프레임이 아니라 프레임→페이지, PID이다.
- 가상 메모리 접근을 위해 프로세스ID와 페이지 번호를 모두 찾아야한다.
- 속도가 느리다.

## 세그먼테이션 기법

### 세그먼테이션 기법의 구현

- 세그먼테이션 테이블: 세그먼트의 크기를 나타내는 limit, 물리 메모리상의 시작 주소를 나타내는 address로 표시한다.
- 프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함한다.

**장점**

- 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순하다.

**단점**

- 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡하다

### 세그먼테이션 기법의 주소 변환

- VA=<S,D>
- 주소 변환 과정(프로세스 A→0, B→1,C→2)
    - 읽기 or 쓰기(프로세스 A, 32번지의 값)
    1. 프로세스 A→ 세그먼트 0, D32
    2. 세그먼테이션 테이블에서 시작 주소에 D를 더해 물리 메모리 주소를 구한다.(만약 D가 limit 보다 크다면 범위를 벗어난 것이므로 프로세스를 종료하고 메모리 오류를 출력한다)
        - ex) 시작 주소 120→ 물리 메모리 주소 152
    3. 해당 위치에 읽기 또는 쓰기 연산 수행
- 세그먼트의 범위를 정해 놓는 것이 메모리 보호를 겸하는 것이다.
- 메모리 오류를 트랩이라고 한다.

### 세그먼테이션- 페이징 혼용 기법

**메모리 접근 권한**

- 읽기, 쓰기, 실행, 추가
- 추가는 쓰기 권한과 동일하다→ 8(2^3)가지 모드
- 프로세스 영역별로 메모리 접근 권한이 다르다
    - 코드 영역: 읽기/실행 권한(자기 자신을 수정할 수 없기 때문에)
    - 데이터 영역: 읽기 전용 테이터(상수등등)는 읽기 권한만, 일반 데이터는 읽기/쓰기 권한
    

**세그먼테이션-페이징 혼용 기법의 도입**

![](https://images.velog.io/images/pinoa1228/post/247b9ef5-acea-4efc-b69a-74c8ee83e08d/image.png)

- 가상 주소에서 물리 주소로 주소 변환이 일어날 때마다 메모리 접근 권한을 검사하고, 이러한 정보는 매핑 테이블에 담겨 있다.
- 권한 비트를 세그먼테이션에 옮김으로써 페이지 테이블의 크기가 너무 커지는 것을 방지함

**세그머테이션- 페이징 혼용 기법의 주소 변환**

- VA=<S,P,D>→ 페이징 기법+ 세그먼트 번호 S
- 주소 변환 과정
    1. 요청한 데이터가 몇 번째 세그먼트의 몇 번째 페이지로 부터 얼마나 떨어져 있는지 계산하여 VA를 구한다.
    2. 세그먼테이션 테이블에서 해당 세그먼트 번호로 가서 영역을 벗어나는 불법 접근이 아닌지, 권한이 없는 것이 아닌지 확인한다.
        - 불법 접근→ 세그먼테이션 오류 발생 및 프로세스 강제 종료
        - 정상 접근→ 페이지 테이블로 이동
    3. 해당 페이지가 저장된 프레임 번호를 찾아서 물리 메모리에 프레임이 있다면 바로 접근하고 없다면 스왑영역에서 가져온다.
    4. 프레임의 처음 위치+D에 접근하여 데이터를 읽거나 쓴다.