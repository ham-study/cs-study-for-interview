## 인덱스 개념

- 인덱스는 데이터 베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조이다.
- 테이블에서 특정 컬럼에 인덱스를 생성한 후 별도의 인덱스 테이블에 저장한다.

**인덱스를 사용하는 이유**

- DBMS는 순차적으로 데이터를 쌓기 때문에 특정 데이터를 찾기 위해서는 FULL-SCAN(O(N))이 필요하다. 따라서 인덱스를 사용하여 탐색 속도를 개선할 수 있도록 한다.

**동작 과정**

1. 특정 컬럼에 인덱스를 생성한다.
2. 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.
3. Where조건에 인덱스 생성 컬럼을 걸면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수 있다.
4. 인덱스에서 저장되어 있는 데이터 물리적 주소로 가서 데이터를 가져오는 식으로 동작한다.

**장점**

- 검색속도 향상
    - 인덱스 테이블은 b+트리 자료구조로
- 데이터 정렬
    - Order By에 의한 정렬과정은 굉장히 부하가 많이 걸리는 작업이다. 인덱스를 사용하면 이미 정렬되어 있어서 Order By를 사용하지 않아도 된다.

**단점**

- 정렬된 상태를 계속 유지 시켜줘야한다.
    - INSERT,DELETE,UPDATE를 통해 데이터가 변경된다면, 인덱스 테이블 내에 있는 값을 다시 정렬해야한다.
- 데이터가 변경 되면 인덱스 테이블과 원본 테이블 모두 수정해줘야한다.

## Clustered index, Non-Clustered index

### clustered-index

- 테이블의 PK에 대해서만 적용된다.
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것이다.
- PK에 의해 레코드 저장위치가 결정된다.
- 한 테이블에 하나만 생성할 수 있다.

**단점**

- PK값이 변경되면 레코드의 물리적인 저장 위치가 바뀐다 이에 따라 랜덤 액세스가 많이 발생해서 IO가 증가한다.
- 기존의 데이터를 정렬해야 하기 때문에 시간이 오래 걸린다.

### Non-Clustered index

- 데이터와 인덱스를 각각 다른 위치에 저장한다.
- 인덱스는 해당 데이터의 위치에 대한 포인터를 포함한다.
- 한 테이블당 여러개를 생성할 수 있다.
- 데이터 검색 순서
    - 루트-리프-데이터 페이지(힙영역)
- unique,unique null을 추가하여 만들 수 있다.
- 페이지 정렬을 하지 않고 이루어진다.

## 인덱스 자료구조

### B-트리

- 데이터가 정렬된 상태로 유지된다.

**구성**

리프노드: 실제 데이터가 저장되는 노드, linkedlist로 연결되어 있다.

브랜치 노드: 리프 노드까지의 경로 역할을 하는 노드

루트 노드: 경로의 출발점 노드.

특정 컬럼에 인덱스를 생성하는 순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간쯤 되는 데이터를 루트 노드에 저장한다.

리프 블록에는 인덱스의 키가 되는 데이터와 데이터의 물리적 주소를 저장한다.

**장점**

- 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다.(균일하다)