## Sharding&Master/Slave

### Replication

하나의 DB가 많은 쿼리를 처리하다보면 과부하가 발생한다. 따라서 쿼리의 대부분을 차지 하는 읽기 작업을 어느정도 해결하기 위해 Master-Slave을 이용한다.

Master서버는 메인 프로세스를 담당하고 Slave는 Master서버로 부터 복제된 데이터를 받아서 요청을 처리한다.

만약 서버에서 db에 데이터를 요청하면 Master 서버가 아니라 똑같은 데이터가 복제된 Slave 서버가 데이터를 제공한다.


- 특징
    - 여러개의 DB를 수직적 구조(Master-Slave)로 구축하는 방식
    - Master 는 쓰기 작업만을 처리하고 Slave는 읽기 작업만 처리한다.
    - 비동기 방식으로 데이터 동기화를 진행한다.
- 장점
    - DB 요청의 대부분이 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
- 단점
    - Master-Slave 데이터 동기화까지의 시간이 소요되기 때문에 일관성 있는 데이터를 얻지 못할 수 있다.
    - Master가 다운되면 복구 및 대처가 까다롭다.

**동기화 과정**


1. 클라이언트가 마스터 db에 데이터를 보내준다.
2. 마스터 db는 Binary Log 파일에 로그를 기록한 후 필요할 때 db에 업데이트 한다.
3. Slave 서버가 최신 데이터를 요청하면 마스터 서버는  Binary Log 파일을 읽어서 전달한다.
4. Slave 서버는 이 정보들을 Relay log에 기록한 후 한번에 변경 사항을 DB에 저장한다.
5. 다른 클라이언트나 서버가 마스터가 저장해둔 데이터를 쿼리로 요청하면 Slave 서버가 동기화된 데이터를 전달해 준다.

→ 싱크가 안맞는 문제가 발생할 수 있는데 이때는 패치를 붙여  마스터에 직접 요청하기도 한다.

### Sharding

Replication을 사용하여 DB 서버에 부하는 분산 시켰지만, 원하는 데이터를 테이블로 부터 찾는데 많은 시간이 소요된다. 따라서 샤딩을 이용하여 특정 기준으로 나누어 저장하고 검색하도록 한다.

**정의**

하나의 거대한 데이터 베이스 테이블을 수평 분할하여 여러개의 작은 단위로 나눈 후 물리적으로 다른 위치에 분산하여 저장, 관리하는 기술이다.

**장점**

- 수평적 확장을 용이하게 하는 데 도움이 될 수 있다.
- 쿼리의 응답시간이 빨라진다.→ 한 테이블을 여러개의 테이블로 분할하여 쿼리의 행 수가 줄어든다.

**단점**

- 샤드에 균형이 맞지 않게 되면 다시 균일한 샤딩을 해야하는 상황이 발생한다
- 여러개의 테이블로 분할하여 서버와의 연결과정이 잦아지고 데이터를 찾는 과정이 기존보다 복잡해진다.(찾아야하는 테이블 수 가 많아지기 때문에)
- 데이터 베이스를 운영하는 복잡도가 높아지는 단점이 있다.

## 이상현상, 정규화

## 이상현상

여러 속성들을 하나의 릴레이션으로 표현하게 되어 속성들간에 존재하는 여러가지 종속 관계에 대해 정규화 되지 않아 발생하는 현상

- 삭제 이상(종속성)
    - 한 릴레이션에서 특정 튜플을 삭제할 경우 원하지 않은 정보까지 삭제되는 현상
- 삽입이상(종속성)
    - 한 릴레이션에서 특정 튜플을 삽입할 경우 원하지 않은 불필요한 정보까지 삽입되는 현상 또는 삽입하는데 데이터가 부족하여 지정하지 않은 속성 값이 NULL을 갖는 현상
- 갱신 이상(중복)
    - 데이터가 중복 저장된 상황에서 하나만 갱신할 경우 생기는 현상.

### 정규화

한 릴레이션에 여러 엔티티의 속성을 혼합하여 정보가 중복 저장되며 저장공간이 낭비되고, **이상현상**이 발생하게 된다. 

이러한 문제를 해결하기 위해서 정규화 과정을 거친다.

**정규화란?**

- 속성간의 종속성으로 인한 이상현상이 발생하는 릴레이션을 분해하여 이상현상을 없애는 과정
- 데이터의 중복 방지, 무결성 충족을 위해 데이터 베이스를 설계하는 방법

**정규화 원칙**

1. 정보의 무손실: 분해된 릴레이션이 표현하는 정보는 분해되기 전의 정보를 모두 포함해야한다.
2. 최소 데이터 중복: 이상현상을 제거하여 중복을 최소화 한다.
3. 분리의 원칙: 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리해서 표현해야한다.

**정규화 장점**

- 이상현상을 해결할 수 있다.
- 새로운 속성의 추가로 인해 DB 구조를 확장하는 경우 구조의 변경을 최소화 할 수 있다.
- 정규화된 릴레이션 간의 관계가 현실세계에서의 개념들간의 관계를 잘 보여준다.

**단점**

- 릴레이션 분해로 인해 연산이 많아져 응답시간이 오히려 느려질 수도 있다.→ 반정규화를 통해 성능을 향상 시킬 수 있다.

### 1 정규화

- 테이블의 컬림이 원자값을 갖도록 테이블을 분해해야한다.

![](https://images.velog.io/images/pinoa1228/post/61329c21-a789-46eb-b3bf-f3d22d1442d2/Untitled%20(15).png)

- 속성들간의 종속성을 제거 할 수 있다.

![](https://images.velog.io/images/pinoa1228/post/55126ec0-75ef-4c6d-ac2f-8f1e918fab93/Untitled%20(16).png)

### 2 정규화

- 1 정규화를 진행한 테이블에 대해 완전  함수 종속을 만족하도록 테이블을 분해하는 것이다.
    - 완전 함수 종속: 기본키의 부분 집합이 결정자가 되어서는 안된다.
- 학생 번호와 강좌 이름이 복합키가 되어 성적을 결정하고 있다. 또한 강좌이름에 따라 강의실이 결정될 수 있다.
    - (학생 번호, 강좌 이름)의 부분 집합인 강좌이름이 강의실을 결정하고 있다.
    - 부분집합이 결정자가 되었기 때문에 2정규화를 통해 강좌이름과 강의실이 포함된 테이블로 분해해야한다.

![](https://images.velog.io/images/pinoa1228/post/26080c7f-e6ea-4bb8-83f5-0f869452aa0b/Untitled%20(17).png)

- 2 정규화를 통해 강의실을 분해하여 별도의 테이블로 관리해야한다.
![](https://images.velog.io/images/pinoa1228/post/fcc83762-4d44-4659-b57b-8e7005fd3658/Untitled%20(18).png)

### 3 정규화

- 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다.
    - 이행함수 종속: A→B,B→C 가 성립할 때 A→C가 성립되는 것을 의미한다.
- 학생번호→ 강좌 이름, 강좌 이름→ 수강료, 학생번호→ 수강료 관계가 성립되어 이행함수 종속이 발생한다.
    - 3정규화를 통해 학생번호, 강좌이름/ 강좌 이름, 수강료로 테이블을 분해해야한다.
    
![](https://images.velog.io/images/pinoa1228/post/32313a04-cffd-4317-bff4-bbf63d9a8fda/Untitled%20(19).png)
    
![](https://images.velog.io/images/pinoa1228/post/b4392ad4-ae57-4e87-9d74-bdc671fc00c6/Untitled%20(20).png)
    

### BCNF 정규화

- 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다.

![](https://images.velog.io/images/pinoa1228/post/f7f087b6-5334-4b93-beeb-32fa65a16091/Untitled%20(21).png)

- 특강 수강 테이블에서 (학생 번호, 특강 이름)이 기본키가 되고, 기본키→교수 교수→ 특강이름 관계를 가지고 있다.
- 교수가 결정자이지만 후보키가 아니다.
- 3정규화를 통해 학생 번호,교수 / 특강이름, 교수 로 분해해야한다.