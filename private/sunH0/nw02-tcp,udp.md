## TCP와 UDP
TCP/IP의 전송계층은 송수신자 간 응용 프로세스 상호 간의 통신을 지원하는 계층이다. 전송되는 패킷의 IP는 호스트에서 호스토로 이동은 지원하지만 호스트 안의 여러 프로세스를 식별하기 위해서는 포트 번호가 필요하고, IP의 오류를 대처하기 위해서는 TCP와 UDP 같은 프로토콜이 필요하다.

### UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)

데이터를 데이터그램 단위로 처리하는 비연결형 전송계층 프로토콜이다. 각각의 패킷은 독립적인 관계와 경로를 가진다.
즉, 인터넷상에서 서로 정보를 주고받을 때 정보를 보낸다는 신호나 받는다는 **신호 절차를 거치지 않고, 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜이다.**

- 데이터의 신뢰성이 떨어진다.
  - UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 
  - 먼저 보낸 패킷이 느린 선로를 통해 전송될 경우 나중에 보낸 패킷보다 늦게 도착할 수 있다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 데이터의 경계를 구분한다. (데이터그램)
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.

**UPD는 신뢰성있는 데이터 전송을 보장하지는 않지만,  TCP보다 속도가 빠르며 네트워크 부하가 적다. 그렇기 때문에 신뢰성보다는 연속성이 중요한 실시간 서비스(streaming) 같은 곳에 자주 사용된다.**

#### UDP Header
- Source port : 시작 포트
- Destination port : 도착지 포트
- Length : 길이
- Checksum : 오류 검출
  -  네트워크를 통해서 전송된 데이터의 값이 변경되었는지(무결성)를 검사하는 단순한 값이다.
  
### TCP(Transmission Control Protocol, 전송제어 프로토콜)
대부분의 인터넷 Application 들은 신뢰성 과 순차적인 전달 을 필요로 한다. UDP 로는 이를 만족시킬 수 없으므로 탄생한 것이 TCP이다. IP가 데이터의 전송 처리한다면 TCP는 패킷을 추적 및 관리하게 된다. 

- 클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜 (연결지향 프로토콜)
  - 데이터로 보내기 전에 반드시 연결이 형성되는 가상 회선 방식을 제공
- 데이터가 순차적으로 전달된다. (각 바이트마다 시퀀스 번호를 부여)
- 데이터의 경계를 구분하지 않는다. (바이트 스트림 서비스)
- 1 : 1 통신만 가능하다.
- 높은 신뢰성을 보장한다
   - TCP는 패킷을 성공적으로 전송하면 응답번호(ACK)를 날리고 만약에 ACK 신호가 제 시간에 도착하지 않으면 Timeout이 발생하여 패킷 손실이 발생한 패킷을 다시 전송해준다.
- TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.

+) 가상회선 방식 : 데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(연결 지향형) 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다.

#### TCP Header 
- 송수신자의 포트 번호
- Sequence Number : 전송되는 바이트 순서
- 응답 번호 (ACK Number) : 수신 프로세스가 제대로 수신한 바이트 수를 응답하기 위해 사용
- Data Offset : TCP 헤더의 크기
- 제어 비트(Flag Bit) : SYN, ACK, FIN 등의 제어 번호
- Wiondow size : 수신 윈도우의 버퍼 크기를 지정할 때 사용. 0이면 송신 프로세스의 전송 중지
- Checksum : 프로토콜 헤더와 데이터에 대한 오류 검출 용도

#### 3way-handshake : TCP Connection 
3번의 패킷 교환을 통해 TCP 통신을 위한 연결을 준비한다.

1. 클라이언트는 SYN 패킷을 전송하여 접속을 요청한다. 클라이언트는 SYN패킷을 보냄과 동시에 SYN_SENT상태가 되고 SYN/ACK응답을 기다린다.
2. 서버는 SYN 패킷을 받고 클라이언트에게 요청을 수락하는 ACK/SYN패킷을 보냅니다. 이때 서버는 SYN_RCVD상태로 클라이언트의 ACK패킷을 기다린다.
3. 클라이언트는 ACK패킷을 보낸다. 서버에서 ACK패킷을 받게되면 ESTABLISHED상태가 되고 데이터 통신을 시작한다

#### 4way handshake
4개의 패킷을 교환을 통해 TCP는 세션을 안전하게 종료한다. 

1. 클라이언트는 접속 종료를 위해 서버에게 FIN을 보내고 FIN_WAIT1상태가 된다.
2. 서버는 클라이언트가 접속을 종료한다는 것을 알게되고 CLOSE_WAIT상태로 변경한뒤 ACK 패킷을 보낸다.
3. ACK를 받은 클라이언트는 FIN_WAIT2상태가 되고 서버는 close()함수를 호출한 뒤 FIN패킷을 보낸다. 이때, 서버는 LAST_ACK상태가 된다.
4. 서버가 보낸 FIN패킷을 수신하면 클라이언트는 ACK를 보내고 TIME_WAIT상태가 된다.

서버는 ACK를 받고 CLOSED상태가 된다.

#### 흐름제어
송 수신측 사이의 데이터 전송 속도 차이에서 감당할 수 없을 정도의 많은 데이터를 받게되면 버퍼 오버플로우가 발생하기 때문에 데이터 전송량을 제어한다.
- Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
- Sliding Window (Go Back N ARQ) : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법
  - 호스트들은 실제 데이터를 보내기 전에 '3 way handshaking'에서 TCP프로토콜은 헤더를 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 된다.
  
#### 혼잡제어
네트워크(라우터) 내의 패킷 수가 넘치지 않게 방지하는 것이다.
- AIMD(Additive Increase / Multiplicative Decrease)
처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기를 1씩 증가시켜가며 전송하는 방법. 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
- Slow Start
AIMD 방식이 , 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재
Slow Start는 윈도우 사이즈를 1로 시작해 전송에 성공한 패킷의 수 만큼 윈도우 사이즈를 증가시키는 방법이다. 
- Fast Retransmit (빠른 재전송)
패킷 하나가 중간에 유실된 경우 수신측은 유실된 패킷의 다음 시퀀스를 ACK에 실어 보낸다. 수신측은 유실된 패킷의 시퀀스를 중복적으로 보내고 시퀀스가 3번이 중복되면 송신측은 해당 패킷을 재전송한다.

#### 오류제어란
훼손된 패킷을 감지하고 중복 수신된 패킷은 폐기하며,, 손실된 패킷은 재전송하고 순서에 맞지 않는 패킷들은 분실된 패킷이 도착할 때 까지 버퍼에 저장하는 것을 말한다.
오류 제어는 크게 세 가지 도구를 통해 수행

•검사합(Check Sum) - 세그먼트내에 있는 검사합 필드를 통해 패킷이 훼손되었는지 확인한다.
•확인응답(Acknowledgement) - 세그먼트의 수신을 알려주기 위해 확인 응답을 사용한다.
•타임아웃(Time-out) - 송신 TCP는 연결당 재전송 타임아웃(RTO, retransmission time-out) 타이머를 사용하여 패킷의 재전송시기를 가늠한다.


### TCP와 UDP의 차이

TCP와 UDP는 체크섬을 이용하여 데이터 오류검사하며 port번호를 통해 주소를 지정하는 방식은 동일하다. 차이점은 TCP는 가상 회선방식의 연결형이지만 UDP는 데이터그램 방식의 비연결형 프로토콜이고 TCP는 패킷 순서를 보장하고 재전송을 통해 신뢰성있는 데이터 전송프로토콜이지만 UDP는 패킷 순서를 보장하지 않고 수신여부를 확인하지 않는다. 그렇기 때문에 UDP는 속도면에서TCP보다 빠르다. 통신 방식은 TCP는 1:1통신만 가능하지만 UDP는 1:1, 1:N, N:N통신 모두 가능하다.

+UDP가 속도가 더 빠른 이유 : 비연결형 서비스이기 때문에, 연결을 설정하고 해제하는 과정이 존재하지 않는다. 또한 서로 다른 경로로 독립적으로 처리함에도 패킷에 순서를 부여하여 재조립을 하거나 흐름 제어 또는 혼잡 제어와 같은 기능도 처리하지 않기에 TCP 보다 속도가 더 빠르며 네트워크 부하가 적다.


