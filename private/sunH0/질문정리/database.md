- 데이터 베이스를 사용하는 이유 및 특징

데이터의 종속성과 중복성, 무결성을 지키기 위해 데이터 베이스를 사용합니다. 데이터 베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터들을 각각의 파일 단위로 관리하였기에 데이터의 종속성, 무결성, 중복성 문제가 발생하였습니다. <br>

(1) 데이터 베이스는 응용 프로그램과 물리적 독립성을 지키기 때문에 데이터 베이스 확장이나 수정에 있어서 자유롭습니다. (독립성) <br>

(2) 인가된 사용자들만 데이터 베이스에 접근할 수 있는 보안을 구현할 수 있습니다. (보안성) <br>

(3) 데이터를 통합해서 관리함으로써 데이터의 중복 문제를 해결할 수 있습니다, (중복최소화)

(4) 데이터 베이스에서  null값 허용, 값 타입, 키와 관계에 대한  조건을 명시하거나 제한되어 있어서 유효성 검사를 통해 데이터의 무결성을 지킬수 있습니다. (무결성)

(5)  연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변했을 경우 발생할 수 있는 데이터의 불일치성을 막을 수 있습니다. (일관성)

- 관계형 데이터 베이스에 대해 설명해주세요

현재 가장 많이 사용되고 있는 데이터베이스의 종류로, 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타냅니다.  이러한 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스입니다. 대표적인 관계형 데이터 모델 DBMS는 Oracle, MySQL, 등이 있습니다. 

관계형 데이터 베이스의 장점은, <br>

(1) 오랫동안 사용된 만큼 범용적이고 신뢰성이 높으며, 데이터의 무결성을 보장합니다. (2)  데이터 분류, 정렬, 탐색 속도가 빠릅니다. (3) 실제 데이터의 물리적 구조 로 부터 자유롭습니다.

단점으로는 <br>

(1) 데이터 스키마는 사전에 설계되어야 하며, 수정하기 어렵습니다. (2) 데이터 사이의 관계에 의해 잦은 Join 연산은 복잡한 쿼리와 성능 문제가 발생할 수 있습니다.  (3) 데이터베이스의 부하를 분석하는 것이 어렵습니다. (4) 수평적 확장이 어렵기 때문에 대량의 데이터 처리에 비효율적입니다.

- 관계형 데이터 베이스 구조

관계형 데이터 베이스 구성요소로는 테이블, 필드 레코드, 도메인, 스키마가 있습니다. <br>

(1) 행과 열로 이루어진 데이터의 집합을 테이블이라 합니다. RDB에서는 테이블의 무든 값이 유일하고 중복되지 않는 다면 릴레이션이라고도 합니다. <br>

(2)  테이블에 저장된 한 행의 정보를 튜플 혹은 레코드라 합니다. 한 행에는 여러 필드의 값이 저장됩니다, <br>

(3) 테이블을 구성하는 데이터들 중 세로로 묶은 데이터셋을 필드 또는 칼럼이라 합니다.  <br>

(4) 도메인은 필드에 채워 질수 있는 값의 집합입니다. <br>

(5) 스키마는 데이터베이스의 구조와 제약조건을 전반적으로 기술한 것을 의미합니다. 예를들어 속성, 개체, 관계와 유지해야할 제약조건 등을 기술합니다.

+) 쉽게 생각하면, ERD 의 산출물이 개념스키마라고 생각하면되고, 하나의 엔티티에서도 사용자 관점에 따라 필요한 속성들이 다르기 때문에, 내부 스키마를 사용자 관점에 따라 추출한 스키마를 외부 스키마라고 생각하면된다. 내부 스키마는 개념 스키마에 저장 크기, 저장 위치등이 추가되었다고 생각하면된다.

- 잦은 join연산에 대한 성능 향상 방법

반정규화, 서브쿼리(**join_value), 인덱스, 조인 순서...**

- 프로젝트에서 mysql을 사용한 이유

- ****관계형 데이터베이스 언어 (질의어)****

 데이터 정의어인 DDL은  SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어입니다.  CREATE, ALTER, DROP, TRUNCATE(테이블 초기화)가 있습니다. <br>

데이터 조작어인 DML은 정의된 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 등의 역할을 합니다. SELECT, INSERT, UPDATE, DELETE가 있습니다. <br>

 데이터 제어어인 DCL은 데이터베이스에 접근하고 데이터를 사용할 수 있는 권한을 제어할수 있습니다.  GRANT, REVOKE가 있습니다.

- 데이터 베이스 Key

Key에는 슈퍼키, 후보키, 기본키, 외래키, 대체키가 있습니다. <br>

슈퍼키는 테이블에서 유일성을 만족하는 속성 또는 속성의 집합으로 최소성은 만족하지 않습니다. <br>

후보키는 슈퍼키들 중 유일성과 최소성을 모두 만족하는 속성 또는 속성들의 집합입니다. <br>

기본 키는 여러 후보키들 중 기본적으로 사용할 키를 선택한 것으로 null이 될수 없습니다. <br>

외래키는 한 릴레이션이 다른 릴레이션을 참조하기 위해 사용하는 키로 다른 릴레이션의 기본키입니다. <br>

마지막으로 대체키는 기본키로 선택되지 못한 후보키 입니다.

- Join

두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법입니다. 테이블을 연결하기 위해서는 적어도 하나의 컬럼을 서로 공유해야 합니다. 조인에는 INNER JOIN, OUTER JOIN, CROSS JOIN, SELF JOIN 이 있습니다.

INNER JOIN은 조인 대상의 테이블을 결합하여 컬럼 값이 동일한 경우만 가져오는 방법입니다.<br>

OUTER JOIN은 조인 대상 테이블에서 특정 테이블의 모든 데이터가 필요한 경우 사용하며, 모든 데이터가 필요한 테이블 기준으로 LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN이 있습니다.<br>

CORSS JOIN은  조인대상 테이블의 카르티시안 곱을 하여 반환합니다.<br>

SELF JOIN은 동일 데이블 사이의 조인을 말합니다. <br>

+) ****Cartesian Product  카티션 곱 :**** 두 테이블의 데이터를 기준으로 가능한 모든 조합의 데이터가 조회됩니다. (M*N)

+) 셀프 조인 ex) 고객 테이블에서(고객 id,고객 이름, 부부id) 고객의 부부 관계를 나태내는 칼럼이 있다. (고객 1의 부부 칼럼에는 고객 2의 id 값이 있다.) 고객 테이블에서 고객 1의 부인을 알수 있지만 부인의 이름은 바로 알 수 없다.) 따라서 셀프 조인을 하면 고객 테이블에서 부부 관계 고객의 이름 칼럼이 새로 추가된다.

- 데이터 베이스 이상현상

삽입, 삭제, 수정과 같은 데이터베이스의 상태를 변경하는 작업에서 발생할 수 있는 현상을 의미합니다. <br>

갱신 이상은 반복된 데이터 중에 일부만 갱신 할 시 데이터의 불일치가 발생하거나, 다른 튜플이 중복되는 현상입니다. <br>

삽입 이상은 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상입니다. <br>

삭제 이상은 어떤 튜플 삭제시, 의도하지 않은 다른 데이터까지 삭제되어버리는 현상입니다. 

이러한 이상 현상은 정규화 작업을 통해 해결할 수 있습니다.

+) 삽입 이상 예시 : 강의를 아직 수강하지 않은 새로운 학생을 삽입할 경우 강의코드 속성에는 null값이 들어가야 하는 문제가 생깁니다.

- 데이터 베이스 정규화

이상현상이 존재하는 릴레이션을 분해하는 과정으로, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 지키기 위한 방법입니다. 보통 나쁜 릴레이션의 속성을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 의미합니다.  하지만 릴레이션 분해로 많은 조인 연상이 발생할 수 있습니다. 이는 반정규화로 해결할 수 있습니다. <br>

릴레이션이 분해되는 정도에 따라 정규형 단계로 나누어지며 정규형이 높아질수록 이상현상은 줄어듭니다. 

제 1 정규화는 릴레이션 최소 조건으로, 테이블의 속성의 도메인이 원자 값을 갖도록 테이블을 분해하는 것입니다. <br>

제 2 정규화는 제1 정규형을 만족하고, 기본키가 아닌 모든 속성이 기본키에만 종속되도록 테이블을 분해하는 것입니다. (부분함수 종속 제거) <br>

제 3 정규화는 제2 정규화를 진행한 테이블에 대해, 이행적 함수 종속을 없애도록 테이블을 분해하는 것입니다. 이행적 함수 종속은 x 속성이 y에 종속되고 y가 z에 종속될 때 x 가 z에 종속되는 현상을 말합니다. <br>

BCNF 정규화는 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것입니다. <br>

BCNF 까지 정규화를 진행하였을때, 대부분의 함수 종속성을 해결한 상태가 됩니다. 정규화를 더 진행 하게 된다면, 릴레이션이 너무나도 많아지고 불필요한 JOIN 이 많아져 응답시간이 느려질수 있기 때문에 일반적으로 BCNF 까지  정규화 해도 충분 할 수 있습니다.

+) 정규화 예시 <br>

1정규화 :  ex) 김선호 -> order : 베토디, 빅맥

2 정규화 :  ex) [기본키: 학번, 과목코드] 학번 -> 학부 | 학번 -> 등록금 (부분함수 종속 제거)

3 정규화 : ex) (학번 : 학부 : 등록금) 학번 -> 학부 | 학부 -> 등록금 | 학번 -> 등록금 =>> (학번:학부) (학번:등록금)

- 함수적 종속성

A와 B를 임의의 애트리뷰트 집합이라고 했을 때,, A값에 의해 B값이 유일하게 정해지는 관계를 말하며, "B는 A에 함수 종속이다"라고 합니다. 함수적 종속성을 판단하여 이상현상이 발생하는 릴레이션을 확인할수 있습니다. <br>

완전 함수적 종속은 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우입니다. <br>

부분 함수적 종속은 릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을경우, 기본키를 구성하는 속성 중 일부만 종속되는 경우입니다. <br>

이행적 함수 종속은 릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때 이행적 함수 종속이라고 합니다. 즉, X를 알면 Y를 알고 그를 통해 Z를 알 수 있는 경우입니다. <br>

- ****반정규화****

정규화된 데이터 모델을 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 통합, 중복허용, 분리하는 데이터 모델링 기법으로, 즉 의도적으로 정규화 원칙을 위배하는 행위입니다. 보통 검색 기능은 향상되지만, 갱신, 삭제 등의 성능은 낮아집니다. <br>

반정규화의 대상으로는 테이블의 조인(JOIN)연산을 지나치게 잦아서 데이터를 조회의 성능이 안 좋을 경우나,  테이블에 많은 데이터가 있고, 다량의 범위 혹은 특정 범위를 자주 처리해야 하는 경우가 될 수 있습니다. <br>

즉, 데이터의 중복 방지, 무결성 vs 데이터베이스의 성능, 단순화 사이의 우선순위를 잘 조절하여 정규화/ 반정규화를 수행해야 합니다.

- NoSQL

NoSQL은 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며, 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 데이터 베이스를 말합니다.  <br>

인터넷이 활성화되고, 소셜네트워크 서비스 등이 등장하면서, 스토리지 비용도 하락하였기 때문에, 대용량 데이터나 비정형데이터를 빠르게 처리할 수 있는 구조의 데이터 베이스가 필요해졌습니다. <br>

기존의 RDBMS는 빅데이터에 대한 스키마를 미리 설계하거나 도중에 수정하기 힘들었고, 관계 모델과 일관성, 속성을 유지하면서 분산(스케일 아웃)하기 어렵다는 한계가 있습니다. <br>

Nosql은 스키마가 없거나 느슨하기 때문에 유연하고, 데이터를 여러 테이블에 나누지 않고, 관련 데이터를 동일한 컬렉션에 넣어 단순한 쿼리로 조인 없이 빠르게 조회할 수 있다는 특징이 있습니다. 또한 rdbms에 비해 저렴하고 확장에 유리합니다. <br>

하지만 Nosql은 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에 수행해야 하고, 인덱스 구조, 데이터 중복으로 인한 충분한 메모리가 필요하다는 단점이 있습니다.

- Sharding

샤딩은 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장, 관리하는 방법을 의미합니다. 하나의 DB에 데이터가 늘어나면 용량 이슈도 생기고, 느려지는 CRUD는 서비스 성능에 영향을 주기 때문에 트래픽을 분산할 목적으로 샤딩을 고려할 수 있습니다. Shard Key를 통해 데이터를 분산 시키고 분산된 데이터 베이스를 찾아 조회할 수 있습니다. <br>

샤딩의 장점은 서버의 수평적 확장의 역할을 하기 때문에, 특정 DB의 장애가 전면장애로 이어지지 않고, 인덱스의 크기가 작아짐에 따라 조회 성능이 향상 될수 있습니다.  <br>

단점으로는, 하나의 트랜잭션에서 두 개 이상의 샤드에 접근할 수 없습니다. 따라서 프로그래밍, 운영적인 복잡도는 더 높아지기 때문에, Cache나 Database의 Replication같이 가능하면 Sharding을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선입니다.

- ****Replication****

여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식입니다. Master Node는 쓰기 작업 만을 처리하며, Slave Node는 Master 노드의 로그 파일을 복사하여 저장하고 읽기 작업 만을 처리합니다.
