<br>

<details>
    <summary><b>운영체제란 무엇이나요?</b></summary>
    <br>
운영체제는 사용자가 컴퓨터를  편리하게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어 입니다.<br> 운영체제는 사용자에게  (1) 프로그램을 실행할 수 있는 환경을 제공함으로써 편의성과 기능의 확장을 제공하고, (2) 한정된 시스템 자원을 배분하고 보호하여 활용할 수 있는 효율성과, 마지막으로 (3) 입출력 장치 등의 하드웨어 운영의 안전성과 호환성을 제공합니다.
</details>

<br>

<details>
    <summary><b>운영체제의 구조에 대해 설명해주세요</b></summary>
    <br>
운영체제는 크게 인터페이스와 커널로의 구조로 되어 있습니다. <br> 사용자는 인터페이스를 통해 커널에 사용자의 명령을 전달하고 이에 대한 실행 결과를 받게 됩니다.  커널은 프로세스, 메모리,  저장장치 에 대한 관리 와 같이 운영체제 핵심 기능을 모아 놓은 것으로,  사용자의 요청에 대해 시스템을 통제 합니다. <br>
커널은 시스템 자원을 보호하기 위하여 시스템 호출이라는 인터페이스를 사용하여 응용 프로그램과 통신합니다.  또한 커널은 드라이버를 통해서 하드웨어를 제어합니다. <br>
  <br>
 +) 운영체제는 커널과 인터페이스를 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 가질 수 있습니다. <br>
 +) 커널이 모든 하드웨어에 맞는 인터페이스를 모두 개발하기 어렵기 때문에, 입출력의 기본적인 부분만 제작하고 하드웨어 특성을 반영한 소프트웨어를 하드웨어 제작자에게 받아 커널이 실행될 때 함께 실행한다. <br>
 +) 커널의 역할 :  프로세스에 CPU를 배분하는 등의 관리,  프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공하는 메모리 관리,  입출력 관리, 프로세스 간 통신 관리 등이 있다.
</details>

<br>

<details>
    <summary><b>커널의 구조에 대해 설명해 주세요</b></summary>
    <br>
초창기 운영체제는 커널의 핵심 기능 모듈들이 구분 없이 하나로 구성되어 있는 단일형 구조 커널을 사용 하였지만, 모듈간 의존성이 높고 다양한 환경에 적용하기 어렵다는 단점이 있었습니다.<br>
 계층형 구조 커널은 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들어서 계층 간의 통신을 통해 운영체제를 구현하는 방식으로 의존성 문제를 해결 하였지만, 계층이 많아짐에 따라 커널의 복잡성이 증가한다는 것과 계층형 구조 자체의 단점이 있습니다. <br>
마이크로 구조 커널은 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공하고 나머지 부분은 사용자 영역에 구현되어 있으므로 계층형 구조 문제를 해결하였습니다.<br>
 <br>
 +) 마이크로 구조 커널 특징 : 커널이 가벼워 지고 각 모듈은 독립적으로 작동하기 때문에 하나의 모듈이 실패하더라도 전체 운영체제가 멈추지 않는다. 하지만 모듈간 통신이 빈번하게 일어난다.
</details>

<br>
<details>
    <summary><b>프로세스는 무엇이나요?</b></summary>
    <br>
프로세스는 디스크에 있는 프로그램이 실행되서 운영체제에 의해 독립된 메모리 영역을 할당받고 CPU 의 할당을 받을 수 있는 상태를 의미합니다.  최소 하나의 스레드를 포함하며 PCB(프로세스 제어 블록)를 가지고 있고, 각 프로세스는 독립된 메모리 영역을 가집니다.<br>
 <br>
 +) 폰노이만 구조 :  오늘날의 컴퓨터는 대부분 폰 노이만 구조를 따른다. 폰 노이만 구조란 메모리를 사용하여 하드웨어는 그대로 두고 프로그램을 바꿔 메모리에 올리는 방식이다.
</details>

<br>
<details>
    <summary><b>프로세스 상태에 대해 설명해주세요</b></summary>
    <br>
프로세스가 생성되는 생성 상태로부터 시작됩니다.  CPU 스케줄러에 의해 CPU가 할당되어 실행 중을 뜻하는 실행상태 , CPU에 할당되기를 준비 큐에서 기다리는 준비 상태가 있습니다. 프로세스가 입출력이나 이벤트를 기다리는 대기 상태와, 프로세스가 작업을 완료하여 메모리에서 삭제되고 PCB가 폐기된 terminated 상태가 있습니다. 그 외에  프로세스가 스왑 영역에 보관되는 메모리에서 일시적으로 쫓겨난 보류 상태가 있습니다.
 <br>
 +) 대기 상태인 프로세스가 입출력이 완료되면 인터럽트가 발생하고 준비 상태로 변경됩니다.
 <br>
 +) 프로세스 큐 :  Job Queue(메인 메모리 할당), Ready Queue(CPU점유), Device Queue (입출력 장치)
 <br>
 +) 보류 상태는 다시 대기 상태에서 옮겨진 보류 대기 상태 , 준비 상태에서 옮겨진 보류 준비 상태
로 구분된다.  보류 대기 상태에서 입출력이 완료되면 보류 준비 상태로 옮겨진다. (인터럽트)
</details>

<br>
<details>
    <summary><b>프로세스 메모리 구조에 대해 설명해주세요</b></summary>
    <br>
프로세스가 운영체제에 의해 할당받은 메모리 구조로는 Code, Data, Stack, Heap 영역이 있습니다.<br>
코드 영영에는 실행할 프로그램의 코드 가 저장됩니다, CPU 는 이 영역에서 명령어를 하나씩 가져와 처리합니다.<br>
데이터 영역에는 전역변수와 정적변수가 저장됩니다.  이 변수들은 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸됩니다.<br>
Stack 영역에는 컴파일 시에 할당되는 지역변수, 매개변수, 리턴 값 같이 임시적으로 사용되는 데이터를 저장합니다.<br>
Heap 영역은 동적 데이터 영역으로 생성된 객체가 저장됩니다. 런타임시에 결정 되며 GC에 의해 관리되는 영역입니다.
 
</details>

<br>
<details>
    <summary><b>문맥교환에 대해 설명해 주세요</b></summary>
    <br>
CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말합니다. 이때 두 프로세스 제어 블록의 내용이 변경되고 이를 통해 작업을 시작합니다. 문맥 교환이 일어나는 대표적은 경우는 타임 아웃, 인터럽트, 시스템 콜이 있습니다.  문맥교환하는데 필요한 시간, 메모리 등을 오버헤드라 합니다.
</details>

<br>
<details>
    <summary><b>PCB에 대해 설명해주세요</b></summary>
    <br>
운영체제가 프로세스를 제어하기 위해 프로세스의 상태 정보를 메인 메모리에 저장하는 자료구조입니다. 프로세스의 생명주기와 함께 하며, 대표적인 역할로 CPU가 처리하던 작업 정보를 담고 있어 CPU를 재 점유 할 때 사용됩니다.
</details>

<br>
<details>
    <summary><b>스레드 에 대해 설명해주세요</b></summary>
    <br>
프로세스 내부에서프로세스가 할당받은 자원을 이용하는 하나의 실행단위를 의미합니다. 프로세스 내에서 스레드 ID, 레지스터 집합, 스택영역을 독립적으로 할당 받고 Code,Data,Heap 영역을 공유합니다.<br> 하나의 프로세스가 수행해야 하는 작업을 스레드가 나누어 수행함으로써 프로세스의 처리 속도를 높이는 역할을 합니다. 또한 각 스레드가 메모리 공간을 공유하기 때문에 스레드간 통신 비용이 적어 문맥교환에 용이합니다.
</details>

<br>
<details>
    <summary><b>프로세스와 스레드의 차이에 대해 설명해주세요</b></summary>
    <br>
프로세스는 운영체제에 의해 자원을 할당받아 실행 중인 프로그램을 뜻하며, 스레드는 프로세스의 실행 단위로 프로세스 메모리 영역 중 코드, 데이터, 힙 영역을 공유하여 자원을 효율적으로 관리할 수 있습니다.

스레드는 일부 메모리 영역을 공유하기 때문에 프로세스에 비해 서로 통신하기 용이하지만, 한 스레드의 결함이 전체 스레드에 영향을 미칠 수 있고 동기화 문제가 있을 수 잇습니다.
 
 +)  프로세스는 데이터를 주고 받을 때 프로세스간 통신(IPC: Inter Process Communication)을 이용한다.
</details>

<br>
<details>
    <summary><b>멀티 스레드와 멀티 프로세스의 차이에 대해 설명해주세요.</b></summary>
    <br>
멀티 프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하는 것으로, 프로세스는 독립된 메모리 영역을 가지고 서로 침범할 수 없습니다.  멀티 스레드는 하나의 프로세스가 여러개의 스레드로 구성하는 것을 뜻하며 프로세스 내부에서 메모리를 공유합니다.

두 방식 다 동시에 여러 작업을 처리할 수 있지만, 자원 공유 유무에 의한 차이가 있습니다. 

멀티 스레드는 멀티 프로세스보다 작은 메모리 공간을 차지하고 문맥 교환이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있습니다. <br>
멀티 프로세스는 하나의 프로세스가  다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지하고 문맥교환 비용이 크다는 단점이 있습니다.

+) 멀티 스레드의 장점으로는 높은 CPU활용으로 인한 응답성 향상과 효율적인 자원 공유, CPU 멀티 코어 활용 이 있습니다.
</details>

<br>
<details>
    <summary><b>스케줄링에 대해 설명해주세요</b></summary>
    <br>
CPU 이용률을 최대화 하기 위해  큐 에 있는 어떤 작업에게 CPU를 할당할 것인지를 결정하는 방법입니다. 

<br>

** 스케줄링 적용 시점에 따라 비선점 스케줄링, 선점 스케줄링으로 구분할 수 있습니다.  **

대표적인 

 <br>

비선점 스케줄링은 어떤 프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 입출력 요구가 발생하여 자발적으로 중지될 때까지 계속 실행되도록 보장합니다. 종류로는 FIFO,  HRN

등이 있고 일괄 처리 시스템에 적합합니다.

<br>

선점 스케줄링은 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식입니다. 종류로는 SRT, Round Robin 등이 있고 시분할 시스템이 적합합니다.

<br>

**스케줄링 유형은 장기, 단기, 중기 3가지로 나눌수 있습니다.**<br>

(1) 장기 스케줄러는 디스크 pool에 있는 프로세스 중 메모리를 할당하여  준비 큐로 보낼지 시스탬 내 전체 프로세스 수를 결정하는 역할을 합니다.<br>

(2) 단기 스케줄러는 준비 큐에 존재하는 프로세스 중 CPU를 할당할 프로세스와 대기 상태로 보낼 프로세스를 결정하는 역할을 합니다.

(3) 중기 스케줄러는 메모리에 올라간 프로세스 수를 조절하기 위해 준비, 대기 상태의 프로세스를 디스크로 보류( swap out) 하거나, 메모리에 여유가 생기면 다시 메모리를 할당(swap-in)하는 역할을 합니다.

+)  CPU 집중 프로세스와 입출력 집중 프로세스 중 입출력 집중 프로세스를 먼저 실행 시키는 것이 더 효율적이다. 입출력 집중 프로세스는 대기 상태로 옮겨져 CPU가 다른 프로세스의 작업을 수행할 수 있기 때문이다.

+) 보통 커널 프로세스는 일반 프로세스 보다 우선순위가 높다.

+) 비선점 스케줄링은  응답시간 예측이 용이하고 문맥교환 오버헤드가 비교적 적지만, 장기간 CPU 독점으로 인해 처리율이 떨어질 수 있다. 선점 스케줄링은 우선순위가 높은 프로세스를 빠르게 처리할 수 있지만, 문맥교환에 따른 오버헤드가 발생한다.

+) CPU가 할당되어 실행 중인 주기를 **CPU 버스트(CPU Burst)** , 입/출력이 이루어지는 주기를 I/O 버스트(I/O Burst)라 부른다.

+) 너무 많은 프로세스가 적재되면 하드디스크 입출력의 과다와 CPU경쟁이 심해져 시스템이 거의 멈추는 것을 Trashing 현상이라 한다. → 중기 스케줄러
</details>

<br>
<details>
    <summary><b>스케줄링 알고리즘에 대해 설명해 주세요.</b></summary>
    <br>
비선점형 알고리즘에는 대표적으로 FCFS, SJF, HRN 이 있습니다. <br>

(1) FCFS (First Come First Served) Scheduling 은 큐에 도착한 순서대로 CPU를 할당하는 알고리즘입니다.  처리 시간이 긴 프로세스가 CPU를 차지하면 시스템의 효율성을 저하 시키는 콘보이 효과가 발생할 수 있어서 주로 다른 알고리즘과 결합하여 사용됩니다. <br>

(2) SJF ****(Shortest Job First)은**** 큐에서 작업 시간이 가장 짧은 프로세스부터 CPU를 할당합니다. 콘보이 문제를 해결하였지만 CPU burst time이 길면 순서가 계속 밀리는 기아문제가 발생할 수 있습니다. <br>

+) SJF를 선점 방식으로 사용한 것을 SRTF (Shortest Remaining Time First) 라고 합니다. <br>

+) 고아 문제는 aging 기법을 통해 해결할 수 있다.  하지만 에이징 값의 기준을 얼마나 정할지 자체가 문제가 된다는 한계가 있다.<br>

+) SJF 는 프로세스의 작업 시간을 정확히 예측하기 어렵다는 문제가 있다. <br>

(3) HRN (Hightest Response-ratio Next) Scheduling 은 프로세스의 대기시간과, CPU 사용 시간을 같이 고려하여 스케줄링 우선순위를 정하는 방식입니다. 에이징 기법이 포함되어 있어 고아 현상을 완화 할 수 있습니다. 하지만 큐에 있는 각 프로세스의 cpu time을 지속적으로 예측해야 하는 오버헤드가 증가합니다.

선점형 알고리즘에는 대표적으로 RR, SRT, 다단계 큐가 있습니다. <br>

(1) 라운드 로빈 스케줄링은 우선 FCFS방식으로 프로세스가 CPU를 할당받고 ****할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식입니다. 타임슬라이스의 크기가 시스템 성능 전체에 영향을 미칠 수 있습니다. <br>

+) 타임 슬라이스가 너무 크면 fcfs 와 같아지고 너무 작아지면 문맥교환 비용이 커진다. <br>

(2) Sortest Remaining Time(SRT) 스케줄링은 SJF와 라운드 로빈 스케줄링을 혼합한 방식입니다.<br>

(3) MLQ(Multi Level Queue)는 우선순위나 프로세스의 성격에 따라 준비 큐를 여러개 사용하는 스케줄링입니다.  각 큐는 특성에 맞게 다른 스케줄링 알고리즘을 사용할 수 있고 상단 큐에 있는 모든 프로세스의 작업이 끝나야 다음 큐에 위치한 프로세스의 작업을 수행합니다. <br>

하지만 기아 현상이 발생할 수 있기 때문에,  <br>

멀티 피드백 큐는 프로세스의 우선순위가 변할 수 있고 그에 따라 큐의 이동이 가능합니다.  우선 순위가 높은 큐에는 작은 **Time Quantum**을, 낮은 큐에는 큰 Time Quantum을 할당합니다. ( 우선순위가 낮더라도 작업량을 보장)
</details>

<br>
<details>
    <summary><b>인터럽트에 대해 설명해주세요</b></summary>
    <br>
프로그램을 실행 중에 어떠한 이벤트가 발생할 경우 현재 실행중인 작업을 중단하고 발생된 상황을 우선적으로 처리하도록 요구하는 방식입니다. 프로세스가 실행 중인 **명령어로 인해 발생하는 인터럽트를 동기적 인터럽트**라 하고, 실행 중인 명령어와 무관하게 발생하는 인터럽트를 **비동기적 인터럽트**라 합니다.

+) 동기적 인터럽트로는 오버플로우,  잘못된 살술 연산, 부당한 기억 장소 참조 등이 있고, 비동기적 인터럽트로는 전원 이상, 입출력, 기계 착오 등이 있다. <br>

+) 인터럽트 전에는 풀링 방식으로 CPU가 일정한 시간 간격을 두고 각 자원들의 상태를 주기적으로 확인했어야 했다.

+) 비동기적 인터럽트가 동기적 인터럽트보다 우선순위가 높다. <br>
</details>

<br>
<details>
    <summary><b>인터럽트 처리 과정에 대해 설명해주세요</b></summary>
    <br>
(1) 인터럽트 요청이 발생하면 (2) 현재 실행중이던 프로그램은 일시 중단됩니다. (3) PCB, PC(Program Counter) 를 사용하여 프로그램 상태를 보존하고, (4) 인터럽트를 요청한 장치를 식별하여 Interrupt Vector 테이블을 통해 호출할 ISR(Interrupt Service Routine) 주소값을 얻습니다. (5) ISR 을 실행 시켜서 인터럽트 처리 작업을 수행합니다. (6) PC를 이용하여 이전 실행 위치로 돌아 간후, PCB 값을 이용하여 일시 중지되었던 프로그램을 재개합니다.
</details>

<br>
<details>
    <summary><b>이중 모드에 대해 설명해주세요</b></summary>
    <br>
시스템 내주 자원을 보호하기 위해 사용자 모드와 커널 모드로 나누어 작업을 수행하는 것을 말합니다.  사용자 모드에서는 인터페이스를 통해 작업 요청 및 결과를 받게 되고, 커널 모드에서는 운영체제 핵심 기능이 동작됩니다. 사용자가 커널 모드로 진입 하는 경우는 시스템 호출을 사용하는 경우, 인터럽트를 발생 시킨 경우 2가지가 있습니다.

+) 컴퓨터 부팅 시 커널 모드로 동작하다가 부팅 완료시 사용자 모드로 진입한다.
</details>

<br>
<details>
    <summary><b>직접 메모리 접근(DMA)에 대해 설명해주세요.</b></summary>
    <br>
특정 하드웨어 하위 시스템이 CPU와 독립적으로 메모리에 접근할 수 있는 권한을 의미하며, 시스템의 효율을 높여줍니다.

+) CPU와 DMA가 동시에 메모리에 접근하는 경우에는 어떻게 될까? 이 때는 비교적 작업속도가 느린 DMA가 메모리 사용권한을 가지게 되는데, 이를 CPU입장에서 사이클 훔치기 라고 한다.
</details>

<br>
