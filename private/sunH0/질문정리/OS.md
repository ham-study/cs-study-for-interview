<br>

<details>
    <summary><b>운영체제란 무엇이나요?</b></summary>
    <br>
운영체제는 사용자가 컴퓨터를  편리하게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어 입니다.<br> 운영체제는 사용자에게  (1) 프로그램을 실행할 수 있는 환경을 제공함으로써 편의성과 기능의 확장을 제공하고, (2) 한정된 시스템 자원을 배분하고 보호하여 활용할 수 있는 효율성과, 마지막으로 (3) 입출력 장치 등의 하드웨어 운영의 안전성과 호환성을 제공합니다.
</details>

<br>

<details>
    <summary><b>운영체제의 구조에 대해 설명해주세요</b></summary>
    <br>
운영체제는 크게 인터페이스와 커널로의 구조로 되어 있습니다. <br> 사용자는 인터페이스를 통해 커널에 사용자의 명령을 전달하고 이에 대한 실행 결과를 받게 됩니다.  커널은 프로세스, 메모리,  저장장치 에 대한 관리 와 같이 운영체제 핵심 기능을 모아 놓은 것으로,  사용자의 요청에 대해 시스템을 통제 합니다. <br>
커널은 시스템 자원을 보호하기 위하여 시스템 호출이라는 인터페이스를 사용하여 응용 프로그램과 통신합니다.  또한 커널은 드라이버를 통해서 하드웨어를 제어합니다. <br>
  <br>
 +) 운영체제는 커널과 인터페이스를 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 가질 수 있습니다. <br>
 +) 커널이 모든 하드웨어에 맞는 인터페이스를 모두 개발하기 어렵기 때문에, 입출력의 기본적인 부분만 제작하고 하드웨어 특성을 반영한 소프트웨어를 하드웨어 제작자에게 받아 커널이 실행될 때 함께 실행한다. <br>
 +) 커널의 역할 :  프로세스에 CPU를 배분하는 등의 관리,  프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공하는 메모리 관리,  입출력 관리, 프로세스 간 통신 관리 등이 있다.
</details>

<br>

<details>
    <summary><b>커널의 구조에 대해 설명해 주세요</b></summary>
    <br>
초창기 운영체제는 커널의 핵심 기능 모듈들이 구분 없이 하나로 구성되어 있는 단일형 구조 커널을 사용 하였지만, 모듈간 의존성이 높고 다양한 환경에 적용하기 어렵다는 단점이 있었습니다.<br>
 계층형 구조 커널은 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들어서 계층 간의 통신을 통해 운영체제를 구현하는 방식으로 의존성 문제를 해결 하였지만, 계층이 많아짐에 따라 커널의 복잡성이 증가한다는 것과 계층형 구조 자체의 단점이 있습니다. <br>
마이크로 구조 커널은 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공하고 나머지 부분은 사용자 영역에 구현되어 있으므로 계층형 구조 문제를 해결하였습니다.<br>
 <br>
 +) 마이크로 구조 커널 특징 : 커널이 가벼워 지고 각 모듈은 독립적으로 작동하기 때문에 하나의 모듈이 실패하더라도 전체 운영체제가 멈추지 않는다. 하지만 모듈간 통신이 빈번하게 일어난다.
</details>

<br>
<details>
    <summary><b>프로세스는 무엇이나요?</b></summary>
    <br>
프로세스는 디스크에 있는 프로그램이 실행되서 운영체제에 의해 독립된 메모리 영역을 할당받고 CPU 의 할당을 받을 수 있는 상태를 의미합니다.  최소 하나의 스레드를 포함하며 PCB(프로세스 제어 블록)를 가지고 있고, 각 프로세스는 독립된 메모리 영역을 가집니다.<br>
 <br>
 +) 폰노이만 구조 :  오늘날의 컴퓨터는 대부분 폰 노이만 구조를 따른다. 폰 노이만 구조란 메모리를 사용하여 하드웨어는 그대로 두고 프로그램을 바꿔 메모리에 올리는 방식이다.
</details>

<br>
<details>
    <summary><b>프로세스 상태에 대해 설명해주세요</b></summary>
    <br>
프로세스가 생성되는 생성 상태로부터 시작됩니다.  CPU 스케줄러에 의해 CPU가 할당되어 실행 중을 뜻하는 실행상태 , CPU에 할당되기를 준비 큐에서 기다리는 준비 상태가 있습니다. 프로세스가 입출력이나 이벤트를 기다리는 대기 상태와, 프로세스가 작업을 완료하여 메모리에서 삭제되고 PCB가 폐기된 terminated 상태가 있습니다. 그 외에  프로세스가 스왑 영역에 보관되는 메모리에서 일시적으로 쫓겨난 보류 상태가 있습니다.
 <br>
 +) 대기 상태인 프로세스가 입출력이 완료되면 인터럽트가 발생하고 준비 상태로 변경됩니다.
 <br>
 +) 프로세스 큐 :  Job Queue(메인 메모리 할당), Ready Queue(CPU점유), Device Queue (입출력 장치)
 <br>
 +) 보류 상태는 다시 대기 상태에서 옮겨진 보류 대기 상태 , 준비 상태에서 옮겨진 보류 준비 상태
로 구분된다.  보류 대기 상태에서 입출력이 완료되면 보류 준비 상태로 옮겨진다. (인터럽트)
</details>

<br>
<details>
    <summary><b>프로세스 메모리 구조에 대해 설명해주세요</b></summary>
    <br>
프로세스가 운영체제에 의해 할당받은 메모리 구조로는 Code, Data, Stack, Heap 영역이 있습니다.<br>
코드 영영에는 실행할 프로그램의 코드 가 저장됩니다, CPU 는 이 영역에서 명령어를 하나씩 가져와 처리합니다.<br>
데이터 영역에는 전역변수와 정적변수가 저장됩니다.  이 변수들은 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸됩니다.<br>
Stack 영역에는 컴파일 시에 할당되는 지역변수, 매개변수, 리턴 값 같이 임시적으로 사용되는 데이터를 저장합니다.<br>
Heap 영역은 동적 데이터 영역으로 생성된 객체가 저장됩니다. 런타임시에 결정 되며 GC에 의해 관리되는 영역입니다.
 
</details>

<br>
<details>
    <summary><b>문맥교환에 대해 설명해 주세요</b></summary>
    <br>
CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말합니다. 이때 두 프로세스 제어 블록의 내용이 변경되고 이를 통해 작업을 시작합니다. 문맥 교환이 일어나는 대표적은 경우는 타임 아웃, 인터럽트, 시스템 콜이 있습니다.  문맥교환하는데 필요한 시간, 메모리 등을 오버헤드라 합니다.
</details>

<br>
<details>
    <summary><b>PCB에 대해 설명해주세요</b></summary>
    <br>
운영체제가 프로세스를 제어하기 위해 프로세스의 상태 정보를 메인 메모리에 저장하는 자료구조입니다. 프로세스의 생명주기와 함께 하며, 대표적인 역할로 CPU가 처리하던 작업 정보를 담고 있어 CPU를 재 점유 할 때 사용됩니다.
</details>

<br>
<details>
    <summary><b>스레드 에 대해 설명해주세요</b></summary>
    <br>
프로세스 내부에서프로세스가 할당받은 자원을 이용하는 하나의 실행단위를 의미합니다. 프로세스 내에서 스레드 ID, 레지스터 집합, 스택영역을 독립적으로 할당 받고 Code,Data,Heap 영역을 공유합니다.<br> 하나의 프로세스가 수행해야 하는 작업을 스레드가 나누어 수행함으로써 프로세스의 처리 속도를 높이는 역할을 합니다. 또한 각 스레드가 메모리 공간을 공유하기 때문에 스레드간 통신 비용이 적어 문맥교환에 용이합니다.
</details>

<br>
<details>
    <summary><b>프로세스와 스레드의 차이에 대해 설명해주세요</b></summary>
    <br>
프로세스는 운영체제에 의해 자원을 할당받아 실행 중인 프로그램을 뜻하며, 스레드는 프로세스의 실행 단위로 프로세스 메모리 영역 중 코드, 데이터, 힙 영역을 공유하여 자원을 효율적으로 관리할 수 있습니다.

스레드는 일부 메모리 영역을 공유하기 때문에 프로세스에 비해 서로 통신하기 용이하지만, 한 스레드의 결함이 전체 스레드에 영향을 미칠 수 있고 동기화 문제가 있을 수 잇습니다.
 
 +)  프로세스는 데이터를 주고 받을 때 프로세스간 통신(IPC: Inter Process Communication)을 이용한다.
</details>

<br>
<details>
    <summary><b>멀티 스레드와 멀티 프로세스의 차이에 대해 설명해주세요.</b></summary>
    <br>
멀티 프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하는 것으로, 프로세스는 독립된 메모리 영역을 가지고 서로 침범할 수 없습니다.  멀티 스레드는 하나의 프로세스가 여러개의 스레드로 구성하는 것을 뜻하며 프로세스 내부에서 메모리를 공유합니다.

두 방식 다 동시에 여러 작업을 처리할 수 있지만, 자원 공유 유무에 의한 차이가 있습니다. 

멀티 스레드는 멀티 프로세스보다 작은 메모리 공간을 차지하고 문맥 교환이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있습니다. <br>
멀티 프로세스는 하나의 프로세스가  다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지하고 문맥교환 비용이 크다는 단점이 있습니다.

+) 멀티 스레드의 장점으로는 높은 CPU활용으로 인한 응답성 향상과 효율적인 자원 공유, CPU 멀티 코어 활용 이 있습니다.
</details>

<br>
<details>
    <summary><b>스케줄링에 대해 설명해주세요</b></summary>
    <br>
CPU 이용률을 최대화 하기 위해  큐 에 있는 어떤 작업에게 CPU를 할당할 것인지를 결정하는 방법입니다. 

<br>

** 스케줄링 적용 시점에 따라 비선점 스케줄링, 선점 스케줄링으로 구분할 수 있습니다.  **

대표적인 

 <br>

비선점 스케줄링은 어떤 프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 입출력 요구가 발생하여 자발적으로 중지될 때까지 계속 실행되도록 보장합니다. 종류로는 FIFO,  HRN

등이 있고 일괄 처리 시스템에 적합합니다.

<br>

선점 스케줄링은 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식입니다. 종류로는 SRT, Round Robin 등이 있고 시분할 시스템이 적합합니다.

<br>

**스케줄링 유형은 장기, 단기, 중기 3가지로 나눌수 있습니다.**<br>

(1) 장기 스케줄러는 디스크 pool에 있는 프로세스 중 메모리를 할당하여  준비 큐로 보낼지 시스탬 내 전체 프로세스 수를 결정하는 역할을 합니다.<br>

(2) 단기 스케줄러는 준비 큐에 존재하는 프로세스 중 CPU를 할당할 프로세스와 대기 상태로 보낼 프로세스를 결정하는 역할을 합니다.

(3) 중기 스케줄러는 메모리에 올라간 프로세스 수를 조절하기 위해 준비, 대기 상태의 프로세스를 디스크로 보류( swap out) 하거나, 메모리에 여유가 생기면 다시 메모리를 할당(swap-in)하는 역할을 합니다.

+)  CPU 집중 프로세스와 입출력 집중 프로세스 중 입출력 집중 프로세스를 먼저 실행 시키는 것이 더 효율적이다. 입출력 집중 프로세스는 대기 상태로 옮겨져 CPU가 다른 프로세스의 작업을 수행할 수 있기 때문이다.

+) 보통 커널 프로세스는 일반 프로세스 보다 우선순위가 높다.

+) 비선점 스케줄링은  응답시간 예측이 용이하고 문맥교환 오버헤드가 비교적 적지만, 장기간 CPU 독점으로 인해 처리율이 떨어질 수 있다. 선점 스케줄링은 우선순위가 높은 프로세스를 빠르게 처리할 수 있지만, 문맥교환에 따른 오버헤드가 발생한다.

+) CPU가 할당되어 실행 중인 주기를 **CPU 버스트(CPU Burst)** , 입/출력이 이루어지는 주기를 I/O 버스트(I/O Burst)라 부른다.

+) 너무 많은 프로세스가 적재되면 하드디스크 입출력의 과다와 CPU경쟁이 심해져 시스템이 거의 멈추는 것을 Trashing 현상이라 한다. → 중기 스케줄러
</details>

<br>
<details>
    <summary><b>스케줄링 알고리즘에 대해 설명해 주세요.</b></summary>
    <br>
비선점형 알고리즘에는 대표적으로 FCFS, SJF, HRN 이 있습니다. <br>

(1) FCFS (First Come First Served) Scheduling 은 큐에 도착한 순서대로 CPU를 할당하는 알고리즘입니다.  처리 시간이 긴 프로세스가 CPU를 차지하면 시스템의 효율성을 저하 시키는 콘보이 효과가 발생할 수 있어서 주로 다른 알고리즘과 결합하여 사용됩니다. <br>

(2) SJF ****(Shortest Job First)은**** 큐에서 작업 시간이 가장 짧은 프로세스부터 CPU를 할당합니다. 콘보이 문제를 해결하였지만 CPU burst time이 길면 순서가 계속 밀리는 기아문제가 발생할 수 있습니다. <br>

+) SJF를 선점 방식으로 사용한 것을 SRTF (Shortest Remaining Time First) 라고 합니다. <br>

+) 고아 문제는 aging 기법을 통해 해결할 수 있다.  하지만 에이징 값의 기준을 얼마나 정할지 자체가 문제가 된다는 한계가 있다.<br>

+) SJF 는 프로세스의 작업 시간을 정확히 예측하기 어렵다는 문제가 있다. <br>

(3) HRN (Hightest Response-ratio Next) Scheduling 은 프로세스의 대기시간과, CPU 사용 시간을 같이 고려하여 스케줄링 우선순위를 정하는 방식입니다. 에이징 기법이 포함되어 있어 고아 현상을 완화 할 수 있습니다. 하지만 큐에 있는 각 프로세스의 cpu time을 지속적으로 예측해야 하는 오버헤드가 증가합니다.

선점형 알고리즘에는 대표적으로 RR, SRT, 다단계 큐가 있습니다. <br>

(1) 라운드 로빈 스케줄링은 우선 FCFS방식으로 프로세스가 CPU를 할당받고 ****할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식입니다. 타임슬라이스의 크기가 시스템 성능 전체에 영향을 미칠 수 있습니다. <br>

+) 타임 슬라이스가 너무 크면 fcfs 와 같아지고 너무 작아지면 문맥교환 비용이 커진다. <br>

(2) Sortest Remaining Time(SRT) 스케줄링은 SJF와 라운드 로빈 스케줄링을 혼합한 방식입니다.<br>

(3) MLQ(Multi Level Queue)는 우선순위나 프로세스의 성격에 따라 준비 큐를 여러개 사용하는 스케줄링입니다.  각 큐는 특성에 맞게 다른 스케줄링 알고리즘을 사용할 수 있고 상단 큐에 있는 모든 프로세스의 작업이 끝나야 다음 큐에 위치한 프로세스의 작업을 수행합니다. <br>

하지만 기아 현상이 발생할 수 있기 때문에,  <br>

멀티 피드백 큐는 프로세스의 우선순위가 변할 수 있고 그에 따라 큐의 이동이 가능합니다.  우선 순위가 높은 큐에는 작은 **Time Quantum**을, 낮은 큐에는 큰 Time Quantum을 할당합니다. ( 우선순위가 낮더라도 작업량을 보장)
</details>

<br>
<details>
    <summary><b>인터럽트에 대해 설명해주세요</b></summary>
    <br>
프로그램을 실행 중에 어떠한 이벤트가 발생할 경우 현재 실행중인 작업을 중단하고 발생된 상황을 우선적으로 처리하도록 요구하는 방식입니다. 프로세스가 실행 중인 **명령어로 인해 발생하는 인터럽트를 동기적 인터럽트**라 하고, 실행 중인 명령어와 무관하게 발생하는 인터럽트를 **비동기적 인터럽트**라 합니다.

+) 동기적 인터럽트로는 오버플로우,  잘못된 살술 연산, 부당한 기억 장소 참조 등이 있고, 비동기적 인터럽트로는 전원 이상, 입출력, 기계 착오 등이 있다. <br>

+) 인터럽트 전에는 풀링 방식으로 CPU가 일정한 시간 간격을 두고 각 자원들의 상태를 주기적으로 확인했어야 했다.

+) 비동기적 인터럽트가 동기적 인터럽트보다 우선순위가 높다. <br>
</details>

<br>
<details>
    <summary><b>인터럽트 처리 과정에 대해 설명해주세요</b></summary>
    <br>
(1) 인터럽트 요청이 발생하면 (2) 현재 실행중이던 프로그램은 일시 중단됩니다. (3) PCB, PC(Program Counter) 를 사용하여 프로그램 상태를 보존하고, (4) 인터럽트를 요청한 장치를 식별하여 Interrupt Vector 테이블을 통해 호출할 ISR(Interrupt Service Routine) 주소값을 얻습니다. (5) ISR 을 실행 시켜서 인터럽트 처리 작업을 수행합니다. (6) PC를 이용하여 이전 실행 위치로 돌아 간후, PCB 값을 이용하여 일시 중지되었던 프로그램을 재개합니다.
</details>

<br>
<details>
    <summary><b>이중 모드에 대해 설명해주세요</b></summary>
    <br>
시스템 내주 자원을 보호하기 위해 사용자 모드와 커널 모드로 나누어 작업을 수행하는 것을 말합니다.  사용자 모드에서는 인터페이스를 통해 작업 요청 및 결과를 받게 되고, 커널 모드에서는 운영체제 핵심 기능이 동작됩니다. 사용자가 커널 모드로 진입 하는 경우는 시스템 호출을 사용하는 경우, 인터럽트를 발생 시킨 경우 2가지가 있습니다.

+) 컴퓨터 부팅 시 커널 모드로 동작하다가 부팅 완료시 사용자 모드로 진입한다.
</details>

<br>
<details>
    <summary><b>직접 메모리 접근(DMA)에 대해 설명해주세요.</b></summary>
    <br>
특정 하드웨어 하위 시스템이 CPU와 독립적으로 메모리에 접근할 수 있는 권한을 의미하며, 시스템의 효율을 높여줍니다.

+) CPU와 DMA가 동시에 메모리에 접근하는 경우에는 어떻게 될까? 이 때는 비교적 작업속도가 느린 DMA가 메모리 사용권한을 가지게 되는데, 이를 CPU입장에서 사이클 훔치기 라고 한다.
</details>

<br>

<details>
    <summary><b>프로세스 동기화란 무엇이나요?.</b></summary>
    <br>
프로세스 동기화는 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들을 제어하여 데이터의 일관성을 유지 시키는 것을 의미합니다.
</details>

<br>

<details>
    <summary><b>임계구역이란 무엇인가요?</b></summary>
    <br>
공유 자원 접근 순서에 따라 실행 결과가 달라지거나 교착 상태가 발생할 수 있는 프로그램의 영역을 임계구역 이라고 합니다. <br>
</details>

<br>

<details>
    <summary><b>뮤텍스와 세마포어에 대해 알고 계신가요?</b></summary>
    <br>
뮤택스와 세마포어 둘 다 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 매커니즘 입니다. 두 방법은 동기화 대상의 수에 대한 차이점이 있습니다.

뮤택스 1개의 스레드 만이 공유 자원에 접근할 수 있으며 boolean 타입의 Lock 변수를 사용합니다. 세마포어는 공유 자원에 세마포어 변수 만큼 프로세스가 임계구역에 접근할 수 있으며 프로세스가 세마포어 값을 변경할 수 있습니다.

대기 방식으로는 Busy-Waiting 방식의 스핀락과 대기 큐를 사용하는 방법이 있습니다.

+) 스핀 락은 loop를 돌면서 lock 반환될 때까지 대기합니다. <br>

+) 세마포어의 상태가 0,1 뿐인 이진 세마포어라면 뮤텍스와 동일합니다.<br>

+) 스핀락이라도 문맥교환 시간 짧거나, 멀티코어 환경에서는 더 성능이 좋을 수도 있다.
</details>

<br>

<details>
    <summary><b>모니터에 대해 설명해주세요 </b></summary>
    <br>
프로세스  또는 스레드 를 동기화하는 방법으로 두개의 큐를 사용해 하나의 프로세스만 모니터에서 활동하도록 보장해줍니다. 자바에서 **monitor는** Synchronized 키워드를 사용해 상호배제를 지킬 수 있습니다.  **notify, wait 함수를 사용해 스레드 접근 순서를 제어할 수 있습니다.**  **`모니터`는 세마포어와 비교해 공유자원에 접근할 수 있는 권한 획득과 해제를 프로 시저를 통해 편리하게 처리할 수 있습니다.**

+) 세마포어는 오래된 동기화 도구로 자바 같은 고수준인 언어에서는 모니터가 동기화 도구로 사용된다.

+) 모니터는 배타 동기와 조건 동기 2가지의 큐를 가진다. 배타동기는 하나의 **`스레드`만 공유자원에 접근할 수 있도록 다른 스레드들을 대기 시킨다. 조건 동기는 진입 `스레드`가 `블록` (wait)되면서 새 스레드가 진입가능하게 하는 공간이다.  새로운 스레드는 notify() 함수를 통해 블록된 함수를 다시 깨울 수 있다.**
</details>

<br>

<details>
    <summary><b>교착 상태란 무엇인가요?</b></summary>
    <br>
병렬 처리 환경에서 다수의 프로세스 또는 스레드가  특정자원의 할당을 무한정 기다리면서 작업을 진행하지 못하고 있는 상태입니다. <br>

교착 상태 발생 조건으로는 상호 배제, 점유 대기, 비선점, 순환대기가 있습니다. <brt>

교착 상태 해결 방법으로는 예방, 회피, 검출, 회복 4가지가 있습니다. **교착상태에 대해서 예방은 현실적으로 힘들고 회피는 자원의 낭비가 크기 때문에, 현실적으로 교착 상태를 검출하고 회복하는 것이 가장 적합합니다.**

+) **교착상태가 없는 해결안이 반드시 기아의 가능성도 제거하는 것은 아니다.**

+)  **4가지 모두 성립** 해야 교착 상태가 발생하며 하나라도 성립되지 않으면 교착 상태가 해결 가능하다.<br>

1. 상호 배제(Mutual exclusion) 한 프로세스가 사용하는 자원은 다른 프로세스가 사용할 수 없는 배타적 자원이다. 상호배제 알고리즘으로는 데커, 피터슨 이 있습니다. <br>
2. 점유 대기(Hold and wait) 다른 프로세스가 필요로 하는 자원을 점유하고 있으면서, 또 다른 자원을 기다리는 상태가 되어야 한다.<br>
3. 비선점(No preemption) 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다.<br>
4. 순환 대기(Circular wait) 점유와 대기를 하는 프로세스 간의 관계가 순환 형태를 이루어야 한다.<br>

+) <br>

(1) 예방은 데드락 성립의 4가지 조건중 하나를 제거함으로써 데드락을 예방합니다. (효율성이 좋지 않아 사용되지 않는다.) 

(2) 회피는 프로세스가 일정기간 내에 성공적으로 종료될 수 있는 **안전한 상태** 에서만 운영체제가 자원 요청을 허용하는 방법 ( 오버헤드가 크며, 대표적으로 은행원 알고리즘이 있지만 조건이 까다롭다.)

(3) 검출은  운영체제가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 탐지하는 것이다.  대표적으로 타임아웃을 이용하여 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하는 방법과, **자원 할당 그래프를 검사하여 사이클이 존재 하면 교착 상태라고 판단하는 방법이 있다.**

(4) 회복은 deadlock을 검출한 뒤 해결하는 과정이다. 대표적으로 데드락에 빠진 프로세스 중 하나 또는 전체를 종료하거나, 교착 상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스한테 할당하는 방법이 있다.

+) 타임아웃을 이용하는 방법을 **가벼운 교착 상태 검출(잘못 판단 가능성)** 이라 부르고, 자원 할당 그래프를 이용하는 방법을 **무거운 교착 상태 검출 (비용이 크다)** 이라 부른다.

+) 다중 자원에서 교착 상태 검출은 프로세스 대기 그래프를 이용하여 끝날 가능성이 있는 엣지를 제거해 나가며 하나 이상의 엣지가 남아있다면 교착상태라 판단한다.
</details>

<br>

<details>
    <summary><b>식사하는 철학자 문제 해결하는 방법에 대해 설명해주세요</b></summary>
    <br>

(1) 교착상태를  예방하자면 교착상태 성립 조건 4가지 중 하나 이상을 제거 함으로써 해결할 수 있습니다. <br>

상호 배제 : 철학자들의 포크를 서로 공유할 수 있도록 합니다 , 비선점 : 철학자들이 다른 철학자의 포크를 빼앗을 수 있도록 합니다 ,  점유 대기 : 두 포크르 모두 잡지 못한 철학자는 포크를 놓도록 합니다,  원형 대기 : 한 철학자는 왼쪽이 아닌 오른쪽 포크를 먼저 잡도록 합니다.  이 중 원형대기와 점유 대기를 해결해 주면 문제가 해결 됩니다. 

(2) 검출 방법을 사용한다면 타임 아웃을 설정하여 철학자가 포크를 잡고 일정 시간 내에 다른 쪽 포크를 획득하는데 실패한다면, 포크를 반납하게 합니다.

(3) 최대 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.
</details>

<br>

<details>
    <summary><b>메모리 분할 방식에 대해 설명해주세요</b></summary>
    <br>
메모리 분할 방식에는 메모리를 어떤 크기로 나눌 것인가를 기준으로 가변 분할 방식고가 고정 분할 방식이 있습니다. 가변 분할 방식은 프로세스의 크기에 맞게 메모리가 분할되며 한 프로세스가 연속된 공간에 배치됩니다. 외부 단편화가 발생할 수 있기 때문에 메모리 관리가 복잡합니다. 고정 분할 방식은 메모리 공간을 고정된 크기로 분할하고 한 프로세스가 분산되어 배치되는 방식입니다. 내부 단편화가 발생할 수 있기 때문에 배치 크기를 적절히 정해야 합니다. 가변 분할 방식이 좀 더 효율적입니다.

+) 내부 단편화란 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 메모리가 낭비되는 현상, 외부 단편화란 메모리가 할당 및 해제 작업의 반복으로 작은 메모리가 중간중간 존재하지만 연속된 공간이 아니기 때문에 낭비되는 현상을 말한다.
</details>

<br>
    
<details>
    <summary><b>가상 메모리 등장 배경</b></summary>
    <br>
초창기 컴퓨터에서는 사용 가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했습니다. 이러한 메모리 부족 문제를 해결하기 위해 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 최소한 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 하였습니다.
</details>

<br>
    
<details>
    <summary><b>가상메모리에 대해 설명해주세요</b></summary>
    <br>
다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리 (RAM)에 올려두어야 합니다.  가상메모리는 프로세스를 실행하는데 필요한 부분만 메인 메모리에 저장하고 나머지는 스왑 영역 (디스크)에 저장하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 장점이 있습니다.

<br>

****가상 주소 공간에서 프로세스는 자신이 메모리의 어느 위치에 있는지 상관 없이 virtual address상에 0번지 부터 시작하는 연속된 메모리 공간을 가집니다. 매핑 테이블을 사용하여 가상 주소를 실제 메모리 주소로 매핑할 수 있습니다.****

+) 이론상으로 가상 메모리 크기는 무한대이지만 실제적으로는 사용 할 수 있는 메모리의 전체 크기는 물리 메모리(RAM) 크기 + 스왑 영역(디스크)의 크기 이다.

+) page fault : 물리 메모리에 CPU가 요청한 페이지가 없다면, 스왑 영역(보조기억장치에 위치한 가상 메모리 영역)에서 페이지를 찾아 물리 메모리에 로드한다.
</details>

<br>
    
<details>
    <summary><b>페이징 기법에 대해 설명해주세요 ( 메모리 관리 기법)</b></summary>
    <br>
고정 분할 방식 을 활용하여 물리 주소 공간을 같은 크기의 block으로 나누어 사용하는 메모리 관리 기법입니다. 물리 메모리의 조각을 프레임이라 하고, 가상 메모리 조각을 페이지라고 하고 매핑 정보는 페이지 테이블에 저장되어 있습니다. <br>

페이지 테이블은 디스크에 저장되어 있지만 일부를 캐싱하여 TLB에 보관하여 히트 된다면 빠르게 주소 변환 할 수 있습니다.

+) 모든 프로세스는 각 하나씩 페이지 테이블을 가지고 있다. <br>

+)  페이지 테이블은 용량이 크기 때문에 전부를 레지스터에 보관할 수 없다. → TLB  <br>

+) 페이지 한개의 크기를 늘리면 가상 주소의 행의 개수가 줄어들고 페이지 테이블의 크기가 줄어 들게 된다. 하지만 무작정 페이지 크기를 늘리면, 내부 단편화가 발생할 수 있다. 최근에는 물리 메모리도 커지고, 응용프로그램도 커지고 있기 때문에 페이지 크기를 늘리는 추세이다.
</details>


<br>
    
<details>
    <summary><b>레지스터에 대해 설명해주세요</b></summary>
    <br>
프로세서(CPU)  내에서 자료를 보관하는 아주 빠른 기억 장소입니다. 메모리 계층 의 최상위에 위치하여 가장 빠른 속도로 접근 가능합니다.
</details>

<br>
    
<details>
    <summary><b>세그먼테이션 기법에 대해 설명해주세요 (메모리 관리 기법)</b></summary>
    <br>
가변 분할 방식을 사용하는 가상 메모리 관리 기법으로 프로세스를 논리적 단위 즉 세그먼트로 나누어 메모리에 배치하는 것입니다.  세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit과 물리 메모리상 시작 주소를 나타내는 address를 가지고 있습니다.

세그먼테이션 기법은 내부 단편화가 없고, 논리적으로 분할 하기 때문에 공유, 보호가 쉽지만 외부 단편화가 다시 발생할 수 있습니다.  페이지 기법은 메모리 관리가 수우러하지만 페이징 테이블의 크기가 크고 내부 단편화가 발생할 수 있습니다. 그래서 세그먼테이션-페이징 혼용 기법이 있습니다.

+) 프로세스는 세그멘테이션의 집합으로, 예를들어 프로세스를 code, data, stack으로 나누는 것도 세그멘테이션이다. 각각 내부에서 더 작은 세그먼트로 나눌 수 있다.
</details>

<br>
    
<details>
    <summary><b>세그먼테이션-페이징 혼용 기법에 대해 설명해주세요.</b></summary>
    <br>
페이지로 분할된 가상 주소 공간에서 서로 관련있는 영역을 하나의 세그먼트 영역으로 묶어 세그먼테이션 테이블로 관리합니다.  세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하고 세그먼테이션 테이블은 자신과 관련된 페이지 테이블의 시작주소를 나타냅니다, <br>
</details>

<br>
    
<details>
    <summary><b>요구 페이징에 대해 설명해주세요</b></summary>
    <br>
사용자가 요구 할 때 해당 페이지를 메모리로 가져 오는 것을 요구 페이징이라 합니다. 가상 메모리 시스템에서 프로그램 실행 시에 당장 사용될 페이지만을 적재함으로써 메모리를 더 효율적으로 사용할 수 있습니다. <br>

요청한 페이지에 대해 page fault라면 스왑 영역에서 페이지를 가져오고 빈 프레임에 배치해야 합니다. 빈 프레임이 없는 경우 다른 페이지를 스왑 영역으로 내보내야 하는데 이는 페이지 교체 알고리즘에 의해 결정됩니다.

+) 페이지 테이블에 저장되어 있는 데이터들을 페이지 테이블 엔트리라고 한다. 페이지 번호 / 프레임 번호 / 플래그 비트 로 구성된다. 플래그 비트에는 접근비트 (사용한적 있는지), 변경 비트, 유효 비트(스왑,메모리 어디에 있는지), 접근 권한 비트가 있다.

+) 페이지 교체 알고리즘은 지역성을 바탕으로 대상 페이지를 선정하여 자주 사용할 페이지를 내보내는 것을 피해야 한다. 공간의 지역성 (현재 위치에서 가까울수록 접근 확룔이 높다.), 시간의 지역성(최근에 접근한 데이터), 순차적 지역성(작업이 순차적으로 진행될 가능성)이 있다. <br>

지역적으로 가까이 있는 데이터를 캐시에 가져 옴으로써 Hit rate를 높일 수 있다.
</details>

<br>
    
<details>
    <summary><b>페이지 교체 알고리즘에 대해 설명해주세요.</b></summary>
    <br>
page fault 가 발생하였을 때, 어떠한 프레임에 있는 페이지를 디스크의 스왑 영역으로 보낼 것인지를 결정하는 알고리즘입니다. 앞으로의 페이지 부재율을 최소화 하여 오버해드를 줄이는 것이 목표입니다.

(1) fifo알고리즘은 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내보내는 알고리즘으로, 지역성을 고려하지 않기 때문에 비효율적입니다. : 큐 구현

(2) LRU (Least Recently Used)은 페이지 교체 시 가장 오랫동안 사용되지 않은 페이지를 내보내는 알고리즘입니다. page마다 참조 시간을 기록해야 합니다. : 연결리스트 

(3) 최적 알고리즘(OPT)은 메모리가 앞으로 사용할 페이지를 미리 살펴보고,  가장 멀리 있는 페이지를 교체하는 알고리즘 입니다.  미래의 패턴을 미리 안다는 것은 불가능하여 실제로 구현할 수 없습니다.

(4) LFU(Least Frequenctly Used) Algorithm은 과거에 참조 횟수가 가장 적은 페이지를 교체합니다. 최근 적재되었지만 앞으로 참조될 가능성이 높은 페이지가 교체될 수 있습니다.

(5) NUR ( Not Used Recently page replacement algorithm ) 알고리즘은 LRU와 비슷하게 최근에 사용하지 않은 페이지를 교체하는 알고리즘으로 참조 비트, 변경 비트 2개만 사용합니다. LRU,LFU와 비슷한 성능을 내지만 구현이 간단하고 공간 낭비가 적어 가장 많이 사용되는 알고리즘 입니다.

(6) 이차 기회 교체 알고리즘은 기본적으로 fifo형식으로 교체되지만 이전에 페이지 부재 없이 성공한 페이지의 경우 큐의 맨 뒤로 보내 한번의 기회를 더 줍니다,

+)  교체할 페이지를 선택할 때 프레임의 범위를 정한는 방법은 2가지가 있다. 메모리 상의 모든 프로세스 페이지를 대상으로하는 전역 교체와, 현재 실행중인 프로세스가 차지하고 있는 만큼의 물리 메모리 만을 대상으로 하는 지역 교체가 있다. 일반적으로 전역 교체 알고리즘이 더 좋은 성능을 나타낸다.
</details>

<br>
    
<details>
    <summary><b>스레싱 (trashing)에 대해 알고 계시나요?</b></summary>
    <br>
입출력 작업이 너무 많아져서 잦은 페이지 부재로 CPU 이용율이 급격히 떨어지는 상태를 말합니다.
</details>

<br>
    
<details>
    <summary><b>프레임을 할당하는 방식에 대해 설명해주세요</b></summary>
    <br>
프로세스에 프레임을 할당하는 방식에는 정적할당과 동적할당이 있습니다. <br>

정적할당은 프로세스 실행 초기에 프레임을 나누어 주고 그 크기를 고정하는 것입니다. 정적할당에는 프로세스의 크기와 상관없이 동일하게 프레임을 할당하는 균등 할당과, 프로세스 크기에 비례하여 프레임을 할당하는 비례할당이 있습니다. <br>

동적 할당은 프로세스를 실행할 때 Page의 사용을 고려하여 동적으로 프레임을 할당합니다.  페이지 부재 빈도를 기록하여 일정 기준으로 프레임의 크기를 조절하는 방식이 있습니다.

+) 쓰기 지점 복사는 프로세스의 생성을 위해 매번 새로운 데이터 공간을 만드는 것은 낭비이기 때문에, 크롬을 예를 들면 브라우저를 세 개 실행하면 일단 메모리 공간을 공유하고 데이터 변화가 있을때 데이터 복사를 진행합니다.
</details>


