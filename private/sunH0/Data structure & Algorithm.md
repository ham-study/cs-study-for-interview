## Array
같은 타입의 변수들로 이루어진 유한한 데이터 집합으로 배열 요소마다 인덱스를 가진다.

- 논리 메모리에 연속되어 저장된다.
- 인덱스(index)로 해당 원소(element)에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 Big-O(1)에 해당 원소로 접근할 수 있다. 
- 배열의 크기는 고정되어 있으며, 한 번 생성한 배열의 크기를 변경하는 것이 불가능하다.
- 삭제 또는 삽입의 과정에서는 원소들을 shift해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 최악으로는 O(n) 이다.

### 동적배열 (Dynamic Array)
배열은 크기가 고정해야 되기 때문에 이를 해결하기 위해 동적배열이 고안

초기에 고정된 크기를 할당받으며 생성하고, 용량에 넘어서는 원소가 추가 되면 기존의 2배 크기로 배열을 새로 할당한 후, 기존 배열의 원소를 복사한다. 


## LinkedList 
연속적인 메모리 위치에 저장되지 않는 선형 데이터 집합으로 각 데이터 (노드)가 포인터를 통해 연결되는 자료구조이다. 트리(Tree) 구조의 근간이 되는 자료구조이다.

#### 장점
- 항목 생성 후 포인터 값만 변경해주면 되기 때문에 삽입, 삭제가 간단하다.
   - 삽입, 삭제 행위 자체는 간단하지만 가장 앞에 있는 데이터가 아닌 경우 에는 탐색에 O(N)의 시간이 걸린다.
- 전체 크기를 고정할 필요가 없다.

#### 단점
- 탐색 시 항목부터 순차적으로 접근하므로 최대 O(n)의 시간이 걸린다.
- 포인터의 여분의 메모리 공간이 노드에 필요하다.
- 데이터가 인접해 있지 않기 때문에 접근하는데 시간이 걸린다.


## Stack
Last In First Out (LIFO)의 구조를 갖는 선형 자료구조의 일종이다. ex) 웹 브라우저 방문기록 (뒤로 가기)

- 비어있는 스택에서 원소를 추출하려고 할 때 stack underflow라고 하며, 스택이 넘치는 경우 stack overflow라고 한다.
- 스택에서 top을 통해 삽입하는 연산을 'push' , top을 통한 삭제하는 연산을 'pop'이라고 한다.

## Queue
First In First Out (FIFO) 구조를 갖는 선형 자료구조의 일종이다. ex) 프로세스 관리, 줄서기

- 한쪽 끝인 프론트(front) 에서 삭제 작업이, 다른 쪽 끝인 리어(rear)에서 삽입 작업이 이루어 진다.
- 삽입연산을 인큐(enQueue) 삭제연산을 디큐(dnQueue)라고 부른다.

### Priority Queue(우선순위 큐)
큐에 데이터가 들어가면 우선순위에 따라 정렬되고 순차적으로 나가게 된다. 우선순위를 계산할 때 배열과 연결리스트에서는 성능이 저하되므로 일반적으로 힙을 이용하여 많이 구현한다.

### Circular Queue (원형 큐)
데이터를 재배치 해야 하거나 빈 공간이 발생하는 선형 큐의 단점을 극복한 구조이다. 마지막 인덱스에서 다음 인덱스로 넘어갈 때 처음으로 다시 순환된다.

## HashTable
내부적으로 배열을 사용하고 Key, Value형식의 데이터를 저장하는 자료 구조이다. 해시 함수를 사용해서 key값을 해싱하고 나온 값을 인덱스로 사용한다. key를 통한 값을 조회할 때 시간 복잡도는 O(1)이 소요

Key값의 형태는 무한한데 해싱된 인덱스의 형태는 제한되어있다. 따라서 서로 다른 key에 대해 해싱한 결과가 중복되는 해시 충돌(Collision)이 발생할 수 있다.

### Resolve Conflict

- Separate Chaining 방식 (분리 연결법)
해시 값의 충돌이 발생했을 때 연결리스트나 트리 형태로 엔트리에 값을 이어 붙이는 방식이다. 별도의 인덱스를 사용하지않아 공간에 대한 제약이 적으나 최악의 경우 O(n)의 시간 복잡도가 발생할 수 있다. 

  - 일반적으로 Open Addressing 보다 빠르다. (해시 버킷이 많을 수록 빈 버킷을 찾지 어려워 지기 때문)
  - 메모리 측면을 봤을 때 데이터 개수가 적을 때는 트리보다 연결 리스트를 사용한다.
  - 버킷을 추가적으로 사용하지 않기 때문에 테이블의 확장을 보다 늦출 수 있다.

-  Open Address 방식 (개방주소법)
해시 값의 충돌이 발생했을 때 이후 index의 빈 버킷을 찾아 저장하는 방식. 연속된 공간에 데이터를 저장하기 때문에 캐시 효율이 좋다.
  - Open Address에서 데이터를 삭제하면 삭제돈 공간은 Dummy Space로 채워진다. 따라서, 해시 테이블을 재정리 해주는 추가 작업이 필요하다.
  
### 해시 테이블 vs 해시 맵

- 동기화 여부 : 해시 테이블은 병렬 처리에서 Thread sage 하다. 하지만 멀티 스레드 환경이 아니라면 해시 테이블은 성능이 떨어진다.
- Null 값 허용 : 해시 테이블은 key 에 null을 허용하지 않지만 해시 맵은 허용한다.
- HashMap은 보조해시를 사용하기 때문에 해시 충돌이 덜 발생할 수 있다.
