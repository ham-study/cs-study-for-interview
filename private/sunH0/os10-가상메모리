
## 가상 매모리
---

### 배경
초창기 컴퓨터에서는 사용 가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했다. 이러한 메모리 부족 문제를 해결하기 위해 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 최소한 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 하였다.

### 개념
다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 프로세스를 실행하는데 필요한 부분만 메인 메모리에 저장하고 나머지는 보조 기억장치에 저장하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

#### 프로그램의 일부분만 메모리(기억장치)에 올린다.
- 메모리 접근은 순차적이고 지역화되어 있기 때문이다.
- 메모리에 올라가지 않는 나머지는 **보조 기억장치**, 즉 디스크에 위치
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 **응답시간은 유지되고, CPU 이용률과 처리율은 높아진다.**
- swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.

**결국, 빠르고 작은 기억장치(RAM)을 크고 느린 기억장치(디스크)와 병합하여, 하나의 크고 빠른 기억장치(가상 메모리)처럼 동작하게 하는 것이다.
**

### 가상 주소 공간 (VAS, Virtual Address Space)

가상 메모리 시스템의 모든 프로세스는, 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지 상관 없이 virtual address상에 0번지 부터 시작하는 연속된 메모리 공간을 가진다. 그리고 address mapping을 통해 real address로 변환해서 물리적인 메모리 주소와 mapping한다. 이를 동적 주소 변환 이라 한다. -> MMU(Memory Management Unit)
이론상으로 가상 메모리 크기는 무한대이지만 실제적으로는 사용 할 수 있는 메모리의 전체 크기는** 물리 메모리 크기 + 스왑 영역**의 크기 이다. (CPU 32Bit -> 4G)

+) 가상 메모리의 address mapping 과정
프로세스의 bmt에 접근하고 bmt에서 block에 대한 항목(entry)을 찾는다. 그리고 residence bit를 확인하여 residence bit가 0인 경우 swap device에서 해당 블록을 메모리로 가져온다. 이후 bmt를 업데이트하고 block에 대한 실제 메모리 주소를 계산하여 메모리에 접근한다.

+) Block Map Table(BMT):
address mapping 정보를 관리한다. kernal 공간에 프로세스마다 하나의 BMT를 가진다.


### 페이징 기법
외부 단편화의 메모리 낭비를 해결하기 위해,
물리 주소 공간을 같은 크기의 block으로 나누어 사용하는 **고정 분할 방식**을 활용한 가상 메모리 관리 기법이다. 가상 주소의 분할된 각 영역을 **페이지**라고 부르고, 물리 메모리의 분할된 각 영역은 **프레임**이라고 부른다. 프레임과 페이지는 같은 크기이며 매핑 정보는 **PMT(page map table)**에 저장을 한다. 이를 통해 만들어지는 각 페이지에 해당하는 프레임은 연속적인 공간에 존재하지 않고, 페이지단위로 메모리를 할당하여 페이지 테이블을 통해 가상적으로 연속된 공간인 것처럼 보여지도록 만들어주기 때문이다.
**외부 단편화의 문제점은 해결하였지만 내부 단편화가 발생할 가능성이 있다.**  

+) page fault : 물리 메모리에 CPU가 요청한 페이지가 없다면, 스왑 영역(보조기억장치에 위치한 가상 메모리 영역)에서 페이지를 찾아 물리 메모리에 로드한다.

+) TLB (Translation Look aside Buffer)
페이징 테이블의 문제점은 주소결속까지 걸리는 속도 / 페이지테이블의 용량이다. 이를 개선하기 위해 TLB를 사용할 수 있다.
페이지 테이블을 위한 소형의 하드웨어 캐시로  CPU와 메모리 사이에 위치한다.  실제 전체 페이지 테이블은 메모리에 위치해 있고 테이블의 일부를 TLB에 가져와서 사용한다. 매번 MMU가 물리 주소를 확인하기 위해 메모리에 여러번 접근하지 않아도 되기 때문에 효율적이다. (key값과 value값을 사용해 탐색 속도가 메인 메모리보다 빠르다.)

+) 프로그램을 논리적인 단위로 분할하는 segmentation 시스템 대비 page 공유 및 보호 과정이 복잡하지만 관리가 단순하고 효율적인 특징이 있다.

####  페이지 공유
같은 프로그램을 실행시키는 프로세스들이 있다면 코드 영역은 공유할 수 있다. 이 영역은 변경 되어서는 안되며 해당 프레임에 대해 페이지 테이블이 동일한 번호를 기록해야 한다.

#### 메모리 보호
페이지테이블은 메모리 접근을 위해 반드시 거쳐가야만 하는 곳이기 때문에 보호비트를 통해 메모리를 보호 할 수 있다.

#### 페이징의 장단점
- 장점 : 외부 단편화 문제 해결, 페이지 공유 가능, 페이지 보호 가능, Swapping 이 용이해진다.
- 단점 : 페이지 테이블 사용으로 분할방식 대비 주소결속에서 오버헤드 발생, 페이지 테이블의 메인메모리 저장으로 공간 낭비
-> TLB 사용 및 페이지 테이블의 다단계 구성(구조 개선)으로 단점 완화 가능


### 세그멘테이션 기법
프로그램의 논리적인 단위(세그먼트)에 따라 프로세스의 메모리 공간을 구분하는 것으로 block의 크기가 서로 다를 수 있다. 예)stack, heap, main procedure, shared lib, etc

각각의 세그멘트가 차지하는 크기가 서로 다르기 때문에 각 세그멘트가 시작 주소(실제 메모리에서 위치)와 함께 끝 주소(크기)까지 같이 포함하고 있는 정보를 가지고 있는 것이 세그멘테이션 세그먼트 테이블이라고 한다.

컴파일러가 세그먼트를 구분하는 역할을 하여 프로그램 소스를 분석하면서 세그먼트를 식별하고 생성해낸다.

#### 세그멘테이션 장단점
- 장점: 내부 단편화가 없고, 코드나 데이터, 스택등 각 특징을 종류별로 분류하여 저장하므로, **공유, 보호가 쉽다.**
- 단점 : 세그먼트의 크기가 가변적이기 때문에 세그먼테이션 기법을 사용하면 페이징을 통해 해결된 **외부단편화 문제가 다시 발생**할 수 있다. 
그에 따라 세그먼트 내부에서 페이징 기법을 사용하는 기법이 고안되었고 이것이 'Page Segmentation'이다.
