
## 운영체제(Operating System)란?
---
### 정의
사용자가 응용 프로그램을 실행할 수 있는 기반 환경을 제공하여 컴퓨터를 편리하게 사용할 수 있도록 도와주고, 컴퓨터의 한정된 시스템 자원을 효율적으로 사용할 수 있도록 인터페이스를 제공해 주는 소프트웨어이다.

### 필요성
운영체제가 없으면 초기 설계한 기능만 사용 가능하지만 존재 하다면 기능의 추가, **확장** 및 성능 향상이 가능하다.
운영체제의 목적은 사용자 관점의 **편의성**, 자원 할당자로서 자원 활용의 **효율성** 마지막으로 다양한 입출력 장치의 운영 및 제어의 **안전성**을 추구한다. 
![](https://images.velog.io/images/sunho6824/post/2297b055-314e-4d89-a93e-8e9a933fc5a1/image.png)
### 역할과 기능
> 운영체제는 많은 기능과 역할을 하지만 대표적인 것으로 정리 하자면,

1. 자원 관리
운영체제 위에서 실행되는 여러 응용프로그램들이 자원(CPU, 메모리등의 장치)을 사용하려 할 때 사용순서에 따라 자원을 배분하고 사용이 끝나면 다시 이를 회수한다.

2. 자원 보호
응용프로그램의 자원 직접 접근을 막음으로써 악의적인 사용자로 부터 자원을 보호한다.

3. 사용자 인터페이스 제공
사용자가 쉽게 컴퓨터를 활용할 수 있게 해주는 유틸리티를 제공한다. 그래픽 사용자 인터페이스(GUI)가 대표적이다.  

4. 하드웨어 인터페이스 제공
운영체제는 응용프로그램이 하드웨어를 사용할 수 있도록 관리하고 하드웨어의 제조사, 종류에 관계없이 일관된 사용이 가능하도록 해주는 인터페이스를 제공한다.


운영체제 구조
커널
시스템 호출

## 운영체제 구조
---
> 운영체제는 크게 인터페이스 + 커널의 구조이다.

![](https://images.velog.io/images/sunho6824/post/098b35a8-8080-495e-965a-480ac8bdf63a/image.png)

- **커널** : 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아놓은 것으로 운영체제의 성능은 커널이 좌우 한다.

- **인터페이스** : 커널에 사용자의 명령을 전달하고 실행 결과를 사용자에게 알려주는 역할

- 운영체제는 커널과 인터페이스를 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 가질 수 있다. 

### 시스템 호출과 디바이스 드라이버

- **시스템 호출(Sysyem Call)** : 커널이 자신을 보호하기 위해 만든 응용 프로그램과 커널 사이의 인터페이스이다. 커널은 사용자나 응용 프로그램으로부터 컴퓨터 자원을 보호하기 위해 자원에 직접 접근하는 것을 차단한다. 따라서 자원을 이용하기 위해서는 시스템 호출이라는 인터페이스를 사용하여 접근하여야 한다. 
ex) printf(), write()

- **드라이버(Driver)** : 커널과 하드웨어의 인터페이스를 담당한다. 하드웨어의 종류는 다양하고 직접 각 하드웨어에 맞는 인터페이스를 개발하기는 어렵기 때문에 커널은 입출력의 기본적인 부분(마우스 키보드..)만 제작하고, 하드웨어의 특성을 반영한 소프트웨어를 하드웨어 제작자에게 받아 커널이 실행될 때 함께 실행되도록 한다.
이 때 하드웨어 제작자가 만든 소프트웨어를 **디바이스 드라이버**라고 부른다.

### 커널의 역할
- 프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경 제공
- 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공 
- 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스를 제공 
- 입출력 관리 : 필요한 입력과 출력 서비스를 제공
- 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경을 지원

### 커널의 구조

1. **단일형 구조 커널** : 초창기의 운영체제 구조로, 커널의 핵심 기능 모듈들이 구분 없이 하나로 구성되어 있. 대표적인 운영체제는 MS-DOS, VMS 등이 있다.

장점 : 모듈이 거의 분리되지 않았기 때문에 모듈 간의 통신 비용이 줄어들어 효율적인 운영 가능
    
단점 : 
- 모든 모듈이 하나로 묶여 있기 때문에 버그나 오류 처리하기 어렵다.
- 운영체제의 여러 기능이 서로 연결되어 있어 상호 의존성이 높기 떄문에 기능상 작은 결함이 시스템 전체로 확산할 수 있다.
- 다양한 환경 시스템에 적용하기 어렵다.

2. **계층형 구조 커널**

비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들어서 계층 간의 통신을 통해 운영체제를 구현하는 방식이다.

장점 :
- 단일형에 비해 버그나 오류를 쉽게 처리할 수 있다. 오류가 발생 시 해당 계층만 수정하면 된다.
- 디버깅이 쉽다.

단점 :
- 계층이 존재하기 때문에 하나의 계층에 문제가 생기면  위, 아래 계층도 동작하지 못할 수 있다.
- 운영체제가 커지고 복잡해지면 많은 계층들이 발생하게 되어 커널의 크기도 커지고 하드웨어의 용량도 늘어난다.


3. **마이크로 구조 커널**
계층형 구조의 문제로 인해 나타난 구조로, 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공하고 나머지 부분은 사용자 영역에 구현되어 있다. 

장점 :
- 각 모듈은 독립적으로 작동하기 때문에 하나의 모듈이 실패하더라도 전체 운영체제가 멈추지 않는다.
- 커널이 가벼워 CPU 용량이 적은 시스템에 적용이 가능하다.

단점 :
- 모듈이 독립적으로 존재하여 모듈 간 통신이 빈번하게 이루어져 성능이 저하될 수 있다.
 
## 프로세스

### 개념
---
프로세스는 디스크에 있는 프로그램이 실행되서 운영체제에 의해 독립된 메모리 영역을 할당받고, CPU 의 할당을 받을 수 있는 상태를 의미합니다. 최소 하나의 스레드를 포함하며 PCB를 가진 프로그램입니다.

- 프로세스들은 독립적인 주소 공간에서 실행되기 때문에 자원에 접근하기 위해서는 IPC를 사용

### 프로세스 메모리 구조
---

- **Code 영역** : 컴파일된 소스 코드가 저장되는 영역
- **Data 영역** : 전역변수, static 변수들이 위치하는 공간
- **Heap 영역** : 동적할당을 위한 메모리 영역( malloc(), new 등)으로 런타임시 크기가 결정된다. 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
- **Stack 영역** : 지역 변수, 매개변수(함수에 전달되는 인자)같은 임시 데이터가 위치하는 공간으로 컴파일시 크기가 결정된다. 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.

각 프로세스는 독립된 메모리 영역을 가진다.

데이터 영역을 나눈 이유?
최대한 데이터를 공유하여 메모리 사용량을 줄이기 위해서!

### 프로세스 상태 전이
---

![](https://images.velog.io/images/sunho6824/post/fd5d28fe-e200-4c49-aa88-345d05eaa542/image.png)

#### 상태
- **생성 (New)** : 프로세스 생성 상태
- **실행 (Running)** : 프로세스가 CPU에 할당되어 실행 중인 상태
- **준비 (Ready)** : 프로세스가 CPU에 할당되기를 기다리는 상태
- **대기 (Waiting)** : 보류(Block)라고도 하며, 프로세스가 입출력이나 이벤트를 기다리는 상태
- **종료 (Terminated)** : 프로세스 종료 상태
- Suspended Ready 
필요한 자원은 모두 얻었지만 주기억장치에 적재되지 못한 상태
- Suspended Blocked
필요한 자원도 없고 주기억장치에도 적재되지 못한 상태


#### 상태 전이
- **승인 (Admitted)** : 프로세스 생성이 가능하여 승인됨.
- **스케줄러 디스패치 (Scheduler Dispatch)** : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.
- **Time Run Out** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.
- **Block** : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.
- **Wake Up** : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것.
- Swap in
프로세스가 주기억장치에 적재 되는 상태
- Swap out
프로세스가 주기억장치에서 해제 되는 상태

### 프로세스 제어 블록
---
#### PCB(Process Control Block)이란?
운영체제가 프로세스를 제어하기 위해 프로세스의 상태 정보를 저장하는 자료구조다. 프로세스가 생성될 때마다 고유의 PCB가 생성되고 메인 메모리에 유지되며, 프로세스가 완료되면 PCB는 제거된다.

프로세스는 CPU가 처리하던 작업의 내용들을 자신의 PCB에 저장하고, 다음에 다시 CPU를 점유하여 작업을 수행해야 할 때 PCB로부터 해당 정보들을 CPU에 넘겨와서 계속해서 하던 작업을 진행한다.

운영체제에 따라 PCB에 포함되는 항목이 다를 수 있지만, 일반적으로 다음과 같은 정보가 포함된다.

- 포인터 :
프로세스가 준비상태나 대기 상태일 경우에 큐로 운영이 되는데, 프로세스 제어 블록을 연결 시 큐로 구현하기 위해 포인터를 사용

- 프로세스 상태 :
생성, 준비, 실행, 대기 , 완료, 보류 등 프로세스가 현재 어떠한 상태에 있는지를 나타낸다.

- 프로세스 식별자 : 
프로세스 ID 또는 PID라는 고유 한 ID가 할당

- 프로그램 카운터 :
프로세스가 준비상태에서 실행상태 갈 경우 프로그램 카운터를 통해 다음 실행될 명령어의 위치를 알 수 있다. 실행상태에서 준비상태로 갈 경우 프로그램 카운터에 저장하여 다음 실행될 명령어 위치를 저장한다.

- 프로세스 우선순위 :
CPU 스케줄러가 준비 상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스의 우선순위를 저장한다.

- 레지스터 정보 :
프로세스가 실행 중에 사용했던 레지스터 정보( 누산기(Accumulator), 색인 레지스터, 스택 포인터 등)들이 저장되고 다시 실행될때 복귀할 수 있다.

- 메모리 관리 정보 :
프로세스의 메모리 위치 정보가 필요하고 메모리 보호를 위해 사용되는 경계 레지스터, 한계 레지스터 값 등이 저장된다. 이외 세그먼테이션 테이블, 페이지 테이블 등의 정보도 포함된다.

- 할당된 자원 정보 :
프로세스를 실행하기 위해 사용되는 입출력 자원, 오픈 파일 등에 대한 정보가 포함된다.

- 계정 정보 :
계정 번호, CPU 할당 시간, CPU 사용 시간 등이 저장된다.

### 프로세스 큐(queue) 
프로세스는 수행하면서 상태가 여러번 변한다. 그리고 프로세스는 일반적으로 여러 개가 한 번에 수행되므로 이러한 순서를 대기하는 곳을 프로세스 큐라 한다. 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 PCB가 저장되어 있다.

- Job Queue: 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐이다.
- Ready Queue: CPU 점유 순서를 기다리는 큐이다.
- Device Queue: I/O를 위한 여러 장치가 있는데, 각 장치를 기다리는 큐가 각각 존재한다.

## 문맥 교환(Context Switching)
---
CPU를 차지하던 프로세스가 나가고 새로운 프로세스에 할당하는 경우 CPU에서 나가는 프로세스는 지금까지의 작업 내용을 저장하고 새로 들어오는 프로세스는 PCB의 내용으로 CPU가 다시 세팅된다. 이와 같이 두 프로세스의 PCB 교환하는 작업이 **문맥 교환**이다.

문맥교환하는데 필요한 시간, 메모리 등을 **오버헤드**라 부른다.
 
#### 문맥 교환 발생 시점
- 비 자발적 교환 : 타임 슬라이스(Time Slice) 소진 시 스케쥴링으로 다른 프로세스에게 선정되거나 인터럽트로 CPU가 선점 당했을 경우
- 자발적 교환 : 입출력 요구
