
## JDBC
Java Database Connectivity로 자바 프로그램이 데이터 베이스와 연결되어 데이터를 제어 수 있게 해주는 API이다.

#### 배경 
JDBC API가 없던 때에는 데이터베이스의 종류 마다 각각의  SQL문을 작성해야 했다.
JDBC는 DBMS 벤더에 의존하지 않고 통합된 코드를 사용하여 제어할 수 있다.

### 단계
1. JDBC Driver loading (벤더에 맞는 데이터 베이스 드라이버 로딩)
2. Connection : DB 연결
3. Statement : SQL 구문 정의, 값 세팅
4. executeUpdate() or executeQuery()
5. ResultSet : 조회인 경우
6. close : Connection, Statement, ResultSet

### Spring JDB

#### JdbcTemplate
템플릿 메소드 패턴이 적용된 클래스이다. jdbc 템플릿을 제공하여 존더 간편하게 jdbc를 사용할 수 있다.

## Mybatis
Mybatis는 자바 오브젝트와 SQL사이의 자동 매핑 기능을 지원하는 ORM프레임워크이다.

#### 장점
- MyBatis에서는 프로그램에 있는 SQL 쿼리들을 별도의 파일에 구성하여 프로그램 코드와 SQL을 분리할 수 있는 장점을 가지고 있다.

- 대부분의 JDBC 기능을 제공하며, JDBC API를 보다 간결한 코드로 편하게 사용할 수 있다.


## ORM
ORM(object relational mapping)은 객체 지향 프로그램과 관계형 데이터베이스간에 통신시 발생하는 패러다임 문제를 해결하기 위해  객체와 데이터를 자동으로 매핑해주는 기법이다. SQL을 작성하지 않아도 직관적인 메소드로 데이터를 조작할 수 있다. (생산성 증가)

### JPA
JPA는 자바 ORM에 대한 API 표준 명세 이다. 대표적인 구현체로 hibernate, EclipseLink나 DataNucleus 가 있다.

- 스프링이 제공하는 API가 아닌 자바가 제공하는 API다.
- 스프링 부트에서는 spring-boot-starter-data-jpa로 패키지를 가져와 사용하며, 이는 Hibernate 프레임워크를 활용한다.
- 개발자는 JPA를 활용하여 JDBC API를 통해 SQL을 호출하여 데이터베이스에 접근한다.

#### 장점

- 생산성
SQL 쿼리를 직접 생성하지 않고,  JPA에 저장할 객체를 전달하고 JPA 메소드를 활용해 데이터 베이스를 다룰 수 있다. SQL을 작성하고 JDBC API를 사용하는 반복적인 일을 JPA에서 대신해준다.

- 유지보수
유지 보수 측면에서는 SQL의존적인 개발은 엔티티 컬럼이 변경되는 상황에서 연관된 모든 SQL문을 수정해야하고 결과를 매핑하기 위한 JDBC API도 변경해야 한다. JPA는 JPA에서는 엔티티 클래스 정보만 변경하면 된다.

- 성능
JPA는 애플리케이션과 데이터 베이스 사이에서 동작하기 때문에 다양한 성능 최적화 기회를 제공한다. 예를 들어서 같은 트랜잭션 내에서는 캐싱 기능을 제공한다.

- 패러다임 불일치 문제 해결
데이터 베이스는 데이터 중심으로 구조화되어있어 객체 지향 언어와 패러다임 불일치 문제가 발생한다. JPA는 데이터 베이스에 맞춰 데이터를 저장하기위해 객체를 매핑하는 과정에서 드는 비용을 없애 좀 더 객체지향적인 개발이 가능하게 한다.

- DB벤더 독립성
SQL의존적인 개발은 DB벤더마다 문법이 다르기 때문에 다른 데이터베이스로 변경하는 작업이 어렵다. JPA는 데이터베이스와 애플리케이션 사이에서 추상화 데이터 접근 계층을 제공하므로 변경 작업이 비교적 간편하다. 예를들어 로컬 개발 환경은 H2데이터 베이스 사용, 개발이나 상용 환경은 MYSQL 사용

#### 단점

- JPA는 복잡한 쿼리보다는 실시간 쿼리에 최적화되어있다. 통계 처리와 같은 복잡한 작업이 필요한 경우에는 JPA가 제공하는 네이티브 SQL을 사용하거나, 기존의 Mybatis와 같은 Mapper 방식이 더 효율적일 수 있다.

- 자동 생성되는 쿼리문이 많아 성능 최적화가 필요할 수 있다. 

- Persistent Context에서 1차 Cache, Write Behind, Dirty Checking, Lazy Loading 등의 다양한 기능을 지원해주기 때문에 해당 개념을 잘 모르고 JPA를 사용했을 경우 수 많은 예외와 성능 감소가 발생할 수 있다.

#### 프로젝트에 JPA를 사용한 이유

프로젝트 진행간에 발생하는 반복되는 쿼리문을 없애고, 비즈니스 로직이 RDBMS에 의존하는 것이 아니라 좀 더 객체지향적으로 코드를 작성하고 싶어서 JPA를 사용하였습니다.

또한, JPA는 JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 독립해서 사용 할 수 있기 때문에, 로컬 개발 및 테스트 환경에서는 H2데이터 베이스를 사용하였고 실제 배포 환경에서는 MySQL을 사용하였습다.

+) database dialect : . JPA에서는 Dialect라는 추상화된 방언 클래스를 제공하고 각 벤더에 맞는 구현체를 제공하고 있다. 설정을 통해 원하는 Dialect만 설정해주면 해당 Dialect를 참고하여 그에 맞는 쿼리를 생성해준다.

+) H2 장점 : 1. 인메모리 기반 (메인메모리)이기 때문에 응답 속도가 빠르다. 2. 가볍고 오픈소스이다. 3. 설정이 간편하다. 

#### Hibernate
JPA를 구현한 여러 구현체 중 하나이다.

#### Spring Data JPA
 Spring 환경에서 JPA를 편리하게 사용할 수 있도록 Repository 기반으로 추상화 시킨 스프링 서브 프로젝트
 
  JPA 사용시 발생하는 수 많은 boilerplate를 없애주고 pagination이나 Query Method 등의 다양한 기능을 지원합니다.
  


## 영속성 컨텍스트

영속성 컨텍스트는 엔티티를 영구 저장하는 환경입니다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 영속성 컨텍스트에서 엔티티를 관리 혹은 보관할 수 있습니다.

### 영속성의 생명주기
(JPA Entity의 상태 변화)

- 비영속 상태 (Transient) 는 엔티티의 객체는 생성되었지만 아직 저장하지 않아 영속성 컨텍스트나 데이터베이스와 관련 없는 상태를 말합니다. 

- 영속 상태(Persistent) 는 영속성 컨텍스트가 관리하는 상태를 말합니다. : entityManager.persist(E) 

- 준영속 상태는 (Detached) 영속성 컨텍스트에서 관리하다, 영속성 컨텍스에서 분리된 상태, 준영속 상태는 영속 상태 였던 적이 있기 때문에 @Id 값을 반드시 가지고 있습니다.  준영속상태는 실제 데이터가 삭제되지는 않지만 1차캐시부터 쓰기 지연 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거됩니다. : entityManager.detach(E) 
 
- 삭제는 엔티티가 영속성 컨텍스트와 데이터베이스에서 삭제된 상태입니다.

영속성 컨텍스트는 엔티티의 식별자(@Id)를 통해 구분합니다. 따라서 영속 상태는 반드시 식별자가 있어야합니다. 영속성이 데이터베이스와 동기화하는 과정은 보통 트랜잭션이 커밋되는 순간이며 이를 flush라고합니다.

### 영속성 장점

- 1차 캐시
영속성 컨택스트 내부에는 1차 캐시라고 불리는 캐시를 가지고 있습니다. 영속상태의 엔티티는 모두 1차 캐시에 저장되고, 1차 캐시는 @Id를 키로 가지고 있는 Map이 존재합니다. 엔티티를 조회할 때 바로 DB에 접근하는 것이 아니고 1차 캐시에 있는 데이터를 먼저 조회한 후 없는 경우에만 DB에 접근하여 조회 후 다시 1차 캐시에 저장 합니다.

즉, 먼저 DB에 접근하는 것이 아닌 1차 캐시에 먼저 접근함으로서 데이터의 결과를 빠르게 가져올 수 있습니다. 그리고 식별자가 동일한 엔티티의 경우 1차 캐시는 동일성이 보장됩니다. (트랜잭션 격리 수준이 보장)

- 쓰기 지연
엔티티 매니저는 영속성 컨텍스트에서 DML이 발생했을 때 트랜잭션이 커밋되기 전까지 엔티티를 데이터베이스에 저장하지 않습니다. 쓰기 지연 SQL 저장소를 통해 insert SQL을 저장하며 트랜잭션을 커밋할 때 flush를 통해 쿼리들을 DB에 저장하게 되고 최종적으로 commit을 하여 DB에 쿼리를 반영합니다. DB에 접근하는 횟수가 줄어들기 때문에 성능면에서 뛰어납니다.

- 변경 감지 (Dirty Checking)
영속성 컨텍스트의 1차 캐시에는 스냅샷을 통해 엔티티의 변경을 감지합니다. 변경감지는 오직 영속 상태의 엔티티에만 적용이 됩니다.

1. 트랜잭션을 커밋하면, flush가 호출되고, 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾습니다.
2. 변경된 엔티티가 존재하면, 쿼리를 생성해서 쓰기지연 SQL 저장소에 저장합니다.
3. 쓰기지연SQL 저장소에 생성된 쿼리들을 데이터베이스에 flush하고 commit 합니다.


## 즉시/지연 로딩
JPA는 객체 그래프로 연관된 객체를 탐색합니다. 그러기 위해서는 엔티티에 객체 필드가 존재해야 합니다. 하지만, 사용하는 쿼리에 따라 연관 관계를 참조할 필요가 없을 수도 있습니다. 

JPA가 지원하는 즉시로딩은 엔티티를 조회할 때 연관된 객체를 함께 조회하는 것을 말하며, 지연 로딩은 연관된 객체를 함께 조회하지 않고 사용하는 시점에서 조회하는 것을 말합니다.

#### Jpa에서
- fetch 속성을 사용하여 설정할수 있다.
- @ManyToOne 은 기본값이 즉시로딩이고, @OnetoMany는 지연로딩이다.

#### 지연로딩 장단점
- 장점 : 적은 초기의 로딩 시간과 메모리 소비량 감소
- 단점 : 초기화가 지연되면 원하지 않는 순간 성능에 영향을 줄 수 있다.


## JPA 프록시 

지연 로딩을 사용하기위해 JPA에서는 실제 엔티티 객체 대신 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요합니다. 이것을 프록시 객체라고 합니다. 엔티티 매니저에서 getReference()메서드를 사용하면 프록시 객체를 얻을 수 있습니다. 이 프록시 객체는 엔티티의 상속을 통해 만들어진 것으로 실제 엔티티와 겉모습이 같습니다. 프록시 객체에 값을 얻기위해 호출하면 엔티티 정보를 얻어오기위한 DB조회를 조회해 엔티티를 가져옵니다. 이를 프록시 초기화라고합니다. DB조회로 영속성 컨텍스트에 저장된 엔티티를 프록시 객체가 참조하면서 값을 반환합니다. 이런 원리로 지연 로딩이 가능합니다.

### LAZY와 EAGER 각각 어떤 기준으로 사용하시는지?
가급적 지연 로딩만 사용하였습니다. 하지만 대부분 비즈니스 로직에서 같이 사용하는 경우가 많다면 Lazy가 손해이기 때문에 즉시 로딩을 사용하였습니다.
