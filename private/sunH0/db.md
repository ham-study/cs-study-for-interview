+) 용어 정리
- DBMS(Database Management System, 데이터베이스 관리 시스템) : 데이터베이스를 운영하고 관리하는 소프트웨어. 대표적으로 MySQL, 오라클(Oracle), SQL 서버, MariaDB 
- 데이터베이스(Database, DB) : 데이터의 저장소
- SQL(Structured Query Language) : 관계형 데이터베이스에서 사용되는 언어. DDL,DML, DCL

## Clustering
여러 개의 DB를 수평적인 구조로 구축하는 방식이다. DB 서버 한 대에 장애 발생시 대비할 수 있는 기법이다. 

장점으로는 하나의 서버가 부담하던 부하를 두 개의 DB가 나눠서 감당하므로 CPU, Memory 자원의 부하도 적어지게 된다.

단점으로는 스토리지 공유에 따른 병목현상이 있을 수 있다. 그리고 이전보다 많은 비용이 발생한다.

- Active - Active Clustering
서버 하나가 죽어도 다른 서버가 역할을 바로 수행하여 중단되는 시간이 없다. 같이 사용되어 CPU와 메모리 이용률을 올릴 수 있다.

- Active - StandBy Clustering
상대적 적은 비용으로 사용 가능하며 StandBy 서버가 Active로 전환되는데 시간이 들어 서버가 중단되는 시간이 있다.

## Replication
여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.
Master Node는 쓰기 작업 만을 처리하며, Slave Node는 Master 노드의 로그 파일을 복사하여 저장하고 읽기 작업 만을 처리한다.

### 특징

#### 장점
- DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다. (트래픽 분산)
- 데이터 백업 효과가 있다.
- DB 쿼리를 병렬적으로 수행할 수 있다.

#### 단점
- 비동기 방식으로 데이터를 복제하기 때문에 master와 slave 서버간의 데이터 불일치가 발생할 수 있다. (데이터 복제  동안에 발생한 트랜잭션은 적용이 불가)

## Sharding
하나의 DB에 데이터가 늘어나면 용량 이슈도 생기고, 느려지는 CRUD는 서비스 성능에 영향을 주게 된다. 그래서 트래픽을 분산할 목적으로 샤딩을 고려할 수 있다.

샤딩은 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장, 관리하는 방법을 의미한다. Shard Key를 통해 데이터를 분산 시키고 분산된 데이터 베이스를 찾아 조회할 수 있다. 따라서, 방법에 따라 효율성이 결정된다.

분산된 데이터를 shards라고 부르고 이는 database node에 뿌려진다.

+) database node: 데이터베이스의 인스턴스를 말한다. main node는 쓰기, 그 외의 노드는 읽기 전용으로 사용되는 것이 전형적

### 특징

#### 장점

- 특정 DB의 장애가 전면장애로 이어지지 않는다.
- 테이블 데이터가 분산됨으로써 인덱스의 크기가 작아지고 그 만큼 조회 성능이 향상된다.
- 서버의 수평적 확장이 가능하다.

#### 단점
- 프로그래밍, 운영적인 복잡도는 더 높아진다, 가능하면 Sharding을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선
  - Scale-in
  - Cache나 Database의 Replication을 적용
  - 테이블의 특정 컬럼만 자주 사용한다면 Vertically Partition(수직 분할) 도 하나의 방법
- 하나의 트랜잭션에서 두 개 이상의 샤드에 접근할 수 없다. & 두 개 이상의 샤드에 대한 JOIN 연산을 할 수 없다. 

### 방법

1. Hash Sharding
Database id를 Hashing 하여 sharding 하는 간단한 기법이다. 장점으로는 알고리즘적으로 분배하기 때문에 별도의 map이 필요 없다. 단점으로는 서버를 추가할 때 reSharding이 발생할 수 있다. (확장성이 좋지 않다.)

2. Directory Based Sharding
shard key와 매칭되는 shard의 정보를 갖고 있는 lookup table을 활용하는 방법이다. 장점으로는 동적으로 shard를 추가하는 것도 비교적 쉽다. 단점으로는 공유되는 lookup table이 손상되면 문제가 발생한다.

### 샤딩과 수평 파티셔닝의 차이
보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 방법을 뜻하며, 샤딩은 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법을 말한다.

## 이상현상
테이블내의 데이터 조작 시 중복성에 의해서 발생되는 데이터 불일치 현상이다. 정규화를 통해서 이상현상들을 해결할 수 있다. 

- 갱신 이상 (Modification Anomaly) : 반복된 데이터 중에 일부만 갱신 할 시 데이터의 불일치가 발생하거나 다른 튜플이 중복되는 현상

- 삽입 이상 (Insertion Anomaly) : 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상

- 삭제 이상 (Deletion Anomaly) : 어떤 튜플 삭제시, 의도하지 않은 다른 데이터까지 삭제되어버리는 현상


## 정규화
이상현상이 존재하는 릴레이션을 분해하는 과정으로 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이다. 릴레이션은 분해되는 정도에 따라 정규형 단계로 나누어지며 정규형이 높아질수록 이상현상은 줄어든다.

### 함수적 종속성
테이블의 속성 A와 B에 대하여, A값에 의해 B값이 유일하게 정해지는 관계를 말하며, "B는 A에 함수 종속이다"라고 한다.
이때, A를 결정자(Determinant)라고 하고, B를 종속자(Dependant)라고 한다. 


### 제 1 정규화
테이블의 속성 값이 원자 값(하나의 값)을 갖도록 테이블을 분해하는 것

### 제 2 정규화
제1 정규형을 만족하고, 완전 함수 종속을 만족하도록 테이블을 분해하는 것

+) 완전 함수 종속 : 복합키의 부분집합이 결정자가 되어선 안된다는 것을 의미

### 제 3 정규화
제2 정규화를 진행한 테이블에 대해 이행적 함수 종속을 없애도록 테이블을 분해하는 것

+) 이행적 함수 종속 : A, B, C 세 속성이 있고 A→B, B→C 종속 관계가 있을 때, A→C가 성립하는 경우


### BCNF 정규화
제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것


### 특징

#### 장점
- 데이터의 일관성 유지
- 중복 데이터 제거

#### 단점
- 릴레이션 분해로 많은 조인 연상이 발생할 수 있다.


### 반정규화
시스템의 성능 향상을 위해 정규화된 데이터 모델을 통합하는 작업으로, 의도적으로 정규화 원칙을 위배하는 행위이다. 

- 테이블이 단순해지고 관리 효율성이 증가
- 검색 기능은 향상되지만, 갱신, 삭제 등의 성능은 낮아진다.
- 데이터의 무결성이 깨질 수 있다.

데이터의 중복 방지, 무결성 vs 데이터베이스의 성능, 단순화 사이의 우선순위를 잘 조절하여 정규화/반정규화를 수행해야 한다

#### 반정규화의 대상
- 테이블의 조인(JOIN)연산을 지나치게 잦아서 데이터를 조회의 성능이 안 좋을 경우
- 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특정 범위를 자주 처리해야 하는 경우


## 트렌젝션

트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키기 위해 수행하는 작업의 논리적인 단위이다. 하나의 트랜잭션은 Commit되거나 Rollback된다.

### 성질 (ACID)

- 원자성 (Atomicity) : 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

- 일관성 (Consistency): 트랜잭션 작업 처리의 결과가 항상 일관되어야 한다. 즉, 데이터 타입이 반환 후와 전이 항상 동일해야 한다.

- 독립성,격리성 (Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

- 영속성,지속성 (Durability) : 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 한다.


### Commit
하나의 트랜잭션이 성공적으로 끝나서 데이터베이스가 일관성있는 상태에 있음을 의미한다.

### Rollback
Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.  Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.

### 락
Lock은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. Lock은 여러 커넥션에서 동시에 동일한 자원(레코드, 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 

+)  블로킹(Blocking) : 어떤 프로세스가 자원에 접근하려고 할 때 이미 다른 프로세스가 그 자원을 Lock 하고 있어서 그 Lock이 풀릴 때까지 기다려야 하는 상황

### 트랜잭션의 상태

- Active
트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.

- Failed
트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.

- Partially Committed
트랜잭션의 commit이전 sql문이 수행되고 commit만 남은 상태를 말한다.  이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 

- Committed
트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.

- Aborted
트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.


**데이터베이스 Connection 개수는 제한적이다. 트렌젝션은 Connection을 비교적 오래 소유하고 있을 가능성이 있기 때문에 트랜잭션의 범위를 최소화 하는 것이 좋다. **

### 트렌젝션 격리 수준
여러 트랜잭션이 동시에 작업을 수행할 때 한 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 트랜잭션의 격리수준이 낮아질수록 동시성이 증가하지만, 무결성, 고립성 등 문제가 발생하고 격리수준이 높아질수록 동시성은 감소하지만, 무결성, 고립성을 지킬 수 있다. 

트랜잭션의 격리수준에 따라 Dirty Read, Non-Repeatable Read, Phantom Read의 문제가 발생할 수 있다.

- Dirty Read : 다른 트랜잭션에서 아직 commit 되지 않은 데이터를 조회하는 문제. 트랜잭션이 rollback시 존재하지 않는 데이터를 참조할 수 있다.
- Non-Repeatable Read : 한 트랜잭션 내에서 같은 행을 여러 번 조회할 때 처음 조회 결과와 다른 경우
- Phantom Read : 한 트랜잭션 내에서 같은 쿼리문이 실행했을 때 이전 select에서 존재하지 않던 레코드가 두 번째 쿼리에서 나타나는 현상. 한 트랜잭션 수행 중 다른 트랜잭션이 새로운 레코드를 삽입함으로써 나타난다.


#### 0단계 Read Uncommitted
트랜잭션에서 변경하는 내용이 commit, rollback 여부에 관계없이 다른 트랜잭션에 노출한다.
Dirty Read, Non-Repeatable Read, Phantom Read 발생

#### 1단계 Read committed
Commit이 완료된 데이터에 대해서만 조회를 허용한다. 트랜잭션이 수행되는 동안 다른 트랜잭션은 접근할 수 없어 대기
Non-Repeatable, Phantom Read 발생 가능

#### 2단계 Repeatable Read
트랜잭션이 시작되기 전에 Commit된 내용에 대해서만 조회 가능. 트랜잭션의 첫 읽기의 결과를 undo 공간에 백업해두고 이후에 같은 레코드 조회 시 저장한 스냅 샷을 읽어 일관된 결과를 얻는다. update 된 내용은 정합성이 보장되지만, insert, delete는 보장되지 않는다. 
Phantom Read 발생 가능, 

#### 3단계 Serializable
단순 읽기 작업에서도 해당 행에 대해서 락을 거는 가장 엄격한 격리 수준. 동시성이 중요한 db에서는 거의 사용하지 않는다.


## 교착 상태(Deadlock)

여러 개의 트랜잭션을 사용할때 데이터의 동시성을 위해 Lock을 사용하게 되는데, 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하여 무한정 대기하게 되는 상황을 교착상태라고 한다.


### 교착 상태의 빈도를 낮추는 방법
1. 트랜잭션을 자주 커밋한다.
2. 정해진 순서로 테이블에 접근한다. 
3. 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
4. 테이블 단위의 잠금을 획득하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.


## Index

인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조로 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 메모리에 저장해 두는 형태이다.

### Index 특징
인덱스는 항상 정렬된 상태를 유지하기 때문에 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다. 다. 따라서 서비스의 특성상 조회 작업이 빈번하게 발생하는지, 레코드의 수정, 삭제, 삽입 작업이 자주 발생하는지 등을 고려해서 결정해야 한다.

### Index 하기 유리한 경우
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼에 유리하다.
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- 데이터의 중복도가 낮은 컬럼 (Cardinality가 높은 칼럼)

인덱스를 관리하기 위해서 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 또한 정렬된 상태를 계속 유지 시켜줘야 한다는 것은 큰 단점이기 때문에 사용하지 않는 인덱스는 바로 지워줘야 한다.

### Index 자료구조
DBMS 는 인덱스를 관리하는 구조는?

- B+ Tree 인덱스 알고리즘
일반적으로 사용되는 인덱스 알고리즘으로(innodb 기본값),  칼럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), 원래의 값을 이용해 인덱싱하는 알고리즘이다. 시간 복잡도는  O(log2n)

B+Tree는 B-Tree와는 다르게 leaf노드를 제외하고 데이터를 담아두지않기 때문에 branch에서 많은 key를 수용할 수 있어 트리의 높이가 낮아진다. 또한 leaf노드가 linked list로 연결되어 있어 B-Tree에 비해 노드 순회가 쉽다. 하지만 B+Tree는 데이터 탐색을 위해 leaf노드까지 내려가 확인해야하지만 B-Tree는 root나 branch노드에서 탐색을 중단할 수 있다. 

인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행

- Hash 인덱스 알고리즘
Key-Value 형태를 가지며 해시 함수(Hash Function)를 이용해 Key에 해당하는 index 값을 구한다. 매우 빠른 검색 속도를 지원하지만(O(1)) 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위(부등호)를 검색할 때는 해시 인덱스를 사용할 수 없다. , 해시 테이블은 내부적으로 데이터 정렬이 되어 있지 않기 때문이다.


### Clustered index, Non-Clustered index

Index는 열 단위로 생성되는데, 하나의 열에 Index를 생성할 수 있고, 여러 열에 하나의 Index를 생성 할 수도 있다. 제약 조건 없이 테이블 생성시에 인덱스를 만들 수 없으며, 인덱스가 자동 생성되기 위한 열의 제약 조건은 기본키 또는 Unique 뿐이다.
 
#### Clustered index

Clustered Index를 따로 지정하지 않는 경우, Clustered Index는 1순위로 PK키, 2순위로 Unique Key, 둘 다 없다면 6byte의 Hidden Key를 생성한다.

해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장한다. 데이터 행 자체는 한 가지 순서로만 저장될 수 있으므로 테이블당 클러스터형 인덱스는 하나만 있을 수 있다. Index Page를(루트 페이지) 키값과 데이터 페이지(루트 페이지) 번호로 구성하고, 검색하고자하는 데이터의 키 값으로 페이지 번호를 검색하여 데이터(루트 페이지)를 찾는다.

#### Non-Clustered index
Non-Clustered Index는 테이블의 데이터를 정렬하지 않은 상태로 별도의 장소에 정렬된 인덱스 페이지를 생성한다. Non-Clustered Index는 테이블 당 여러개 존재 가능하다. 데이터 페이지는 Heap 영역에 존재한다.

루프 페이지를 통해 리프 페이지를 찾고 최종적으로 리프 페이지의 포인터를 통해 데이터 페이지에 접근한다.

#### 비교
- Clustered Index 물리적으로 정렬되어 있어 검색 속도가 Non-Clustered Index 보다 더 빠르다. 하지만 데이터의 입력/수정/삭제 시에도 정렬을 수행하여 입력/수정/삭제 속도는 더 느리다. 
- Clustered Index는 루트 페이지와 리프 페이지로 구성되며, 리프 페이지는 데이터 그 자체이다. Non-Clustered index의 리프 페이지는 데이터가 위치하는 포인터(RID)다.
- Clustered Index는 범위 검색에 유리하다. (데이터가 인덱스 키로 인해 정렬되어 있기 때문)


## NoSQL

### 의미와 배경
대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 데이터 베이스를 말한다. 따라서 데이터를 여러 테이블에 나누지 않고, 관련 데이터를 동일한 컬렉션에 넣어 조인 없이 사용할 수 있다.

인터넷이 활성화되고, 소셜네트워크 서비스 등이 등장하면서 관계형 데이터 또는 정형데이터가 아닌 데이터, 즉 비정형데이터라는 것을 보다 쉽게 담아서 저장하고 처리할 수 있는 구조를 가진 데이터 베이스들이 관심을 받게 되었다. 또한 스토리지 비용이 크게 하락하면서 데이터 중복 감소를 목적으로 복잡하고 관리가 어려운 데이터 모델을 생성할 필요가 줄어들었다.

NoSQL 데이터베이스는 데이터 모델에 따라 관계형 데이터 베이스에서 제공하지 못하는 성능과 기술을 제공하며 본질적으로 확장(Scale out) 가능하고 대용량 데이터베이스이며 유연하다. 따라서  서비스에 맞는 DB 선택이 중요하다.

대표적으로 MongoDB, redis, HBASE 가 있다.

### 유형

1. Key Value DB
가장 간단한 형태의 NoSQL이며 데이터가 Key와 Value의 쌍으로 저장된다. Key는 Value에 접근하기 위한 용도로 사용되며, 속도가 빠르며 값은  이미지나 비디오 등의 어떠한 형태의 데이터라도 담을 수 있다.( 데이터 입력 단계에서 검증 로직을 제대로 구현하는 것이 중요)  

대량의 데이터를 저장해야 하지만 검색을 위해 복잡한 쿼리를 수행할 필요가 없는 사용 사례에 적합 (성능 향상을 위해 관계형 데이터베이스에서 데이터 캐싱이나 사용자 데이터 정보, 사용자 데이터 정보 저장에 많이 사용된다.)

하지만 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다. 

대표적인 모델로는 Redis, Amazon Dynamo DB 등이 있다.

2. Document Database
가장 많이 쓰이는 모델로 하나의 키에 하나의 구조화된 트리 데이터 방식으로 문서를 저장하고 조회한다. 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID 에 대한 인덱스를 생성한다. 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.

#### 특징

- 쿼리가 SQL과는 다르며 질의의 결과가 JSON이나 xml 형태로 출력된다. 
- 관계형 DB에서의 여러개 테이블 데이터를 하나의 Document에 모아둘 수 있다. (Join 기능을 대체)
- 문서 구조는 코드의 객체에 맞춰 조정되고 다양한 필드 값 유형과 강력한 쿼리 언어 덕분에  다양한 사용 사례에 적합하다. 
- 대표적인 모델로 몽고DB가 있다.

3.  Wide Column Database
하나의 키에 구조화된 연관된 데이터들(Column-family)과 각자의 Column-name 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 

대량의 데이터의 압축, 분산처리, 집계 처리와 쿼리 동작 속도가 뛰어나다. 대표적인 NoSQL Column-family Model로는 HBase, Hypertable 등이 있다.

4. Graph Database
데이터를 노드로 표현하며, 노드 사이의 관계를 엣지로 표현하는 그래프 구조를 갖고 있다. 페이스북이나 트위터 같은 소셜 네트워크에서(내 친구의 친구를 찾는 질의 등) 적합하고, 연관된 데이터를 추천해주는 추천 엔진이나 패턴 인식 등의 데이터베이스로도 적합하다.

대표적으로 Neo4J가 있다.

### RDB VS NoSQL

#### SQL 장점
- 스키마로 인한 명확하게 정의된 데이터 구조, 데이터 무결성 보장
- 관계는 각 데이터를 중복없이 한번만 저장

#### SQL 단점
- 데이터 스키마를 사전에 계획해야 하고 나중에 수정하기 힘들다.
- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있다.
- 대체로 수직적 확장만 가능하다. (하드웨어 향상)

#### NoSQL 장점
- 스키마가 없기 때문에 저장된 데이터를 조정하고 새로운 필드 추가하는데 유연하다.
- 쿼리 프로세싱이 단순화되어 대용량 데이터 처리 성능이 높다. (쿼리 외 다양한 API를 통한 데이터 저장 및 검색이 가능)
- 수직 및 수평 확장이 가능하다. (분산 시스템에 구축되므로 풀에 서버를 추가)
- RDBMS에 비해 저렴한 비용 (설계, 오픈소스, 분산 및 병렬처리)

#### NoSQL 단점
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 한다.
- 인덱스 구조, 데이터 중복으로 인한 충분한 메모리가 필요

#### RDB 사용하기 좋은 경우
- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
- 데이터 구조가 명확하고 명확한 스키마가 중요한 경우

#### NoSQL 사용하기 좋은 경우
- 정확한 데이터 구조(스키마)를 알 수 없거나 변경/확장 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 대용량 데이터를 다뤄야 해서 데이터베이스를 수평적 확장이 필요한 경우
- 비정형 데이터를 많이 사용하는 경우
- 초당 동시 처리가 중요한 경우
- 로그 및 이력 등의 단순 기록형 업무


### Redis (Remote dictionary server)

NoSQL로서 Key-value 구조이며, 모든 데이터를 디스크가 아닌 메모리에 저장하고 조회하는 인메모리 데이터 베이스이다. 따라서 빠른 속도를 제공한다. 데이터베이스로 사용될 수 있으며 Cache로도 사용될 수 있는 기술이다.

#### 특징
- 영속성을 지원한다.
  - 다른 서버의 메모리에 실시간으로 복사본을 저장하는 방법
  - 디스크에 직접 저장하는 방법
- 오픈 소스 소프트웨어이다.
- 문자열, 리스트, 해시, 셋과 같은 다양한 데이터형과 api 기능을 지원한다.
- Single thread (cpu 연산보다 디스크io 시간에 집중, 시간 복잡도를 잘 고려해야 한다.)
- 서버 하나에 여러개의 서버를 띄우는 것이 가능하다.
  - Master - Slave 형식
- 메모리 단편화로 인한 용량 부족의 단점이 있다.

여러 서버에서 대용량이 아닌 같은 데이터를 공유할 때 빠른 속도를 위해 많이 사용




