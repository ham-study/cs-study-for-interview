+) 용어 정리
- DBMS(Database Management System, 데이터베이스 관리 시스템) : 데이터베이스를 운영하고 관리하는 소프트웨어. 대표적으로 MySQL, 오라클(Oracle), SQL 서버, MariaDB 
- 데이터베이스(Database, DB) : 데이터의 저장소
- SQL(Structured Query Language) : 관계형 데이터베이스에서 사용되는 언어. DDL,DML, DCL

## Clustering
여러 개의 DB를 수평적인 구조로 구축하는 방식이다. DB 서버 한 대에 장애 발생시 대비할 수 있는 기법이다. 

장점으로는 하나의 서버가 부담하던 부하를 두 개의 DB가 나눠서 감당하므로 CPU, Memory 자원의 부하도 적어지게 된다.

단점으로는 스토리지 공유에 따른 병목현상이 있을 수 있다. 그리고 이전보다 많은 비용이 발생한다.

- Active - Active Clustering
서버 하나가 죽어도 다른 서버가 역할을 바로 수행하여 중단되는 시간이 없다. 같이 사용되어 CPU와 메모리 이용률을 올릴 수 있다.

- Active - StandBy Clustering
상대적 적은 비용으로 사용 가능하며 StandBy 서버가 Active로 전환되는데 시간이 들어 서버가 중단되는 시간이 있다.

## Replication
여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.
Master Node는 쓰기 작업 만을 처리하며, Slave Node는 Master 노드의 로그 파일을 복사하여 저장하고 읽기 작업 만을 처리한다.

### 특징

#### 장점
- DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다. (트래픽 분산)
- 데이터 백업 효과가 있다.
- DB 쿼리를 병렬적으로 수행할 수 있다.

#### 단점
- 비동기 방식으로 데이터를 복제하기 때문에 master와 slave 서버간의 데이터 불일치가 발생할 수 있다. (데이터 복제  동안에 발생한 트랜잭션은 적용이 불가)

## Sharding
하나의 DB에 데이터가 늘어나면 용량 이슈도 생기고, 느려지는 CRUD는 서비스 성능에 영향을 주게 된다. 그래서 트래픽을 분산할 목적으로 샤딩을 고려할 수 있다.

샤딩은 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장, 관리하는 방법을 의미한다. Shard Key를 통해 데이터를 분산 시키고 분산된 데이터 베이스를 찾아 조회할 수 있다. 따라서, 방법에 따라 효율성이 결정된다.

분산된 데이터를 shards라고 부르고 이는 database node에 뿌려진다.

+) database node: 데이터베이스의 인스턴스를 말한다. main node는 쓰기, 그 외의 노드는 읽기 전용으로 사용되는 것이 전형적

### 특징

#### 장점

- 특정 DB의 장애가 전면장애로 이어지지 않는다.
- 테이블 데이터가 분산됨으로써 인덱스의 크기가 작아지고 그 만큼 조회 성능이 향상된다.
- 서버의 수평적 확장이 가능하다.

#### 단점
- 프로그래밍, 운영적인 복잡도는 더 높아진다, 가능하면 Sharding을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선
  - Scale-in
  - Cache나 Database의 Replication을 적용
  - 테이블의 특정 컬럼만 자주 사용한다면 Vertically Partition(수직 분할) 도 하나의 방법
- 하나의 트랜잭션에서 두 개 이상의 샤드에 접근할 수 없다. & 두 개 이상의 샤드에 대한 JOIN 연산을 할 수 없다. 

### 방법

1. Hash Sharding
Database id를 Hashing 하여 sharding 하는 간단한 기법이다. 장점으로는 알고리즘적으로 분배하기 때문에 별도의 map이 필요 없다. 단점으로는 서버를 추가할 때 reSharding이 발생할 수 있다. (확장성이 좋지 않다.)

2. Directory Based Sharding
shard key와 매칭되는 shard의 정보를 갖고 있는 lookup table을 활용하는 방법이다. 장점으로는 동적으로 shard를 추가하는 것도 비교적 쉽다. 단점으로는 공유되는 lookup table이 손상되면 문제가 발생한다.

### 샤딩과 수평 파티셔닝의 차이
보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 방법을 뜻하며, 샤딩은 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법을 말한다.

## 이상현상
테이블내의 데이터 조작 시 중복성에 의해서 발생되는 데이터 불일치 현상이다. 정규화를 통해서 이상현상들을 해결할 수 있다. 

- 갱신 이상 (Modification Anomaly) : 반복된 데이터 중에 일부만 갱신 할 시 데이터의 불일치가 발생하거나 다른 튜플이 중복되는 현상

- 삽입 이상 (Insertion Anomaly) : 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상

- 삭제 이상 (Deletion Anomaly) : 어떤 튜플 삭제시, 의도하지 않은 다른 데이터까지 삭제되어버리는 현상


## 정규화
이상현상이 존재하는 릴레이션을 분해하는 과정으로 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이다. 릴레이션은 분해되는 정도에 따라 정규형 단계로 나누어지며 정규형이 높아질수록 이상현상은 줄어든다.

### 함수적 종속성
테이블의 속성 A와 B에 대하여, A값에 의해 B값이 유일하게 정해지는 관계를 말하며, "B는 A에 함수 종속이다"라고 한다.
이때, A를 결정자(Determinant)라고 하고, B를 종속자(Dependant)라고 한다. 


### 제 1 정규화
테이블의 속성 값이 원자 값(하나의 값)을 갖도록 테이블을 분해하는 것

### 제 2 정규화
제1 정규형을 만족하고, 완전 함수 종속을 만족하도록 테이블을 분해하는 것

+) 완전 함수 종속 : 복합키의 부분집합이 결정자가 되어선 안된다는 것을 의미

### 제 3 정규화
제2 정규화를 진행한 테이블에 대해 이행적 함수 종속을 없애도록 테이블을 분해하는 것

+) 이행적 함수 종속 : A, B, C 세 속성이 있고 A→B, B→C 종속 관계가 있을 때, A→C가 성립하는 경우


### BCNF 정규화
제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것


### 특징

#### 장점
- 데이터의 일관성 유지
- 중복 데이터 제거

#### 단점
- 릴레이션 분해로 많은 조인 연상이 발생할 수 있다.


### 반정규화
시스템의 성능 향상을 위해 정규화된 데이터 모델을 통합하는 작업으로, 의도적으로 정규화 원칙을 위배하는 행위이다. 

- 테이블이 단순해지고 관리 효율성이 증가
- 검색 기능은 향상되지만, 갱신, 삭제 등의 성능은 낮아진다.
- 데이터의 무결성이 깨질 수 있다.

데이터의 중복 방지, 무결성 vs 데이터베이스의 성능, 단순화 사이의 우선순위를 잘 조절하여 정규화/반정규화를 수행해야 한다

#### 반정규화의 대상
- 테이블의 조인(JOIN)연산을 지나치게 잦아서 데이터를 조회의 성능이 안 좋을 경우
- 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특정 범위를 자주 처리해야 하는 경우


## 트렌젝션

트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키기 위해 수행하는 작업의 논리적인 단위이다. 하나의 트랜잭션은 Commit되거나 Rollback된다.

### 성질 (ACID)

- 원자성 (Atomicity) : 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

- 일관성 (Consistency): 트랜잭션 작업 처리의 결과가 항상 일관되어야 한다. 즉, 데이터 타입이 반환 후와 전이 항상 동일해야 한다.

- 독립성,격리성 (Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

- 영속성,지속성 (Durability) : 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 한다.


### Commit
하나의 트랜잭션이 성공적으로 끝나서 데이터베이스가 일관성있는 상태에 있음을 의미한다.

### Rollback
Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.  Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.

### 락
Lock은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. Lock은 여러 커넥션에서 동시에 동일한 자원(레코드, 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 

+)  블로킹(Blocking) : 어떤 프로세스가 자원에 접근하려고 할 때 이미 다른 프로세스가 그 자원을 Lock 하고 있어서 그 Lock이 풀릴 때까지 기다려야 하는 상황

### 트랜잭션의 상태

- Active
트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.

- Failed
트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.

- Partially Committed
트랜잭션의 commit이전 sql문이 수행되고 commit만 남은 상태를 말한다.  이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 

- Committed
트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.

- Aborted
트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.


**데이터베이스 Connection 개수는 제한적이다. 트렌젝션은 Connection을 비교적 오래 소유하고 있을 가능성이 있기 때문에 트랜잭션의 범위를 최소화 하는 것이 좋다. **

### 트렌젝션 격리 수준
여러 트랜잭션이 동시에 작업을 수행할 때 한 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 트랜잭션의 격리수준이 낮아질수록 동시성이 증가하지만, 무결성, 고립성 등 문제가 발생하고 격리수준이 높아질수록 동시성은 감소하지만, 무결성, 고립성을 지킬 수 있다. 

트랜잭션의 격리수준에 따라 Dirty Read, Non-Repeatable Read, Phantom Read의 문제가 발생할 수 있다.

- Dirty Read : 다른 트랜잭션에서 아직 commit 되지 않은 데이터를 조회하는 문제. 트랜잭션이 rollback시 존재하지 않는 데이터를 참조할 수 있다.
- Non-Repeatable Read : 한 트랜잭션 내에서 같은 행을 여러 번 조회할 때 처음 조회 결과와 다른 경우
- Phantom Read : 한 트랜잭션 내에서 같은 쿼리문이 실행했을 때 이전 select에서 존재하지 않던 레코드가 두 번째 쿼리에서 나타나는 현상. 한 트랜잭션 수행 중 다른 트랜잭션이 새로운 레코드를 삽입함으로써 나타난다.


#### 0단계 Read Uncommitted
트랜잭션에서 변경하는 내용이 commit, rollback 여부에 관계없이 다른 트랜잭션에 노출한다.
Dirty Read, Non-Repeatable Read, Phantom Read 발생

#### 1단계 Read committed
Commit이 완료된 데이터에 대해서만 조회를 허용한다. 트랜잭션이 수행되는 동안 다른 트랜잭션은 접근할 수 없어 대기
Non-Repeatable, Phantom Read 발생 가능

#### 2단계 Repeatable Read
트랜잭션이 시작되기 전에 Commit된 내용에 대해서만 조회 가능. 트랜잭션의 첫 읽기의 결과를 undo 공간에 백업해두고 이후에 같은 레코드 조회 시 저장한 스냅 샷을 읽어 일관된 결과를 얻는다. update 된 내용은 정합성이 보장되지만, insert, delete는 보장되지 않는다. 
Phantom Read 발생 가능, 

#### 3단계 Serializable
단순 읽기 작업에서도 해당 행에 대해서 락을 거는 가장 엄격한 격리 수준. 동시성이 중요한 db에서는 거의 사용하지 않는다.


## 교착 상태(Deadlock)

여러 개의 트랜잭션을 사용할때 데이터의 동시성을 위해 Lock을 사용하게 되는데, 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하여 무한정 대기하게 되는 상황을 교착상태라고 한다.


### 교착 상태의 빈도를 낮추는 방법
1. 트랜잭션을 자주 커밋한다.
2. 정해진 순서로 테이블에 접근한다. 
3. 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
4. 테이블 단위의 잠금을 획득하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.


