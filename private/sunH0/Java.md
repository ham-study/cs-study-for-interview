
## 객체 지향 : OOP(Object Oriented Programming)

### 객체 지향이란?
객체지향은 실 세계의 개체(Entity)를 추상화하여 속성(Attribute)와 메소드(Method)가 결합된 형태의 객체(Object)로 표현하고, 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

### 객체가 무엇인가요?

클래스는 객체를 추상화 하여 메서드, 속성과 같은 공통된 특징을 정의한 집합이며, 객체는 구현할 대상으로 클래스를 토대로 생성된 실체이다. oop의 관점에서 클래스 타입으로 선언된 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다. 

### 객체지향 4가지 특징

1. 캡슐화(Encapsulation)
객체에 정보 은닉을 목적으로 외부의 직접적인 접근을 막고 객체가 제공하는 필드와 메소드를 통해서만 접근이 가능하다.

2. 다형성(Polymorphism)
하나의 객체가 여러 가지 타입을 가질 수 있는 것으로 하나의 변수와 함수 명이 상황에 따라 다르게 동작하는 것이다. 대표적으로 오버로딩, 오버라이딩, 함수형 인터페이스가 있다.

3. 상속성(inheritance)
중복되는 코드의 재사용성을 위해 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 확장해서 사용할 수 있다는 의미

4. 추상화(abstraction)
객체들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것 (객체 지향에서 추상화의 결과는 클래스다.)


### 객체지향 장단점

#### 장점

- 코드 재사용이 용이 
남이 만든 클래스를 필요에 따라 호출하여 이용할 수 있고 상속을 통해 확장해서 사용할 수 있다.

- 유지보수가 쉽다.
수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드와 같이 해당 부분만 수정하면 되고, 캡슐화를 통해 주변에 미치는 영향이 적다.

- 주체인 객체들간의 결합도가 낮기 때문에 특정 기능에서 문제가 생길 경우 특정 구간만을 확인하면 되기 때문에 디버깅이 쉽다.

- 대형 프로젝트와 협업에 적합
프로그램의 기능을 모듈화시켜 개발할 수 있으므로 대형 프로젝트처럼 여러 명, 여러 회사에서 프로젝트를 개발할 때 업무 분담하기 쉽다.

- 자연적인 모델링

#### 단점
- 프로그램의 알고리즘대로 실행될 코드가 바로 구현된 절차지향과는 달리 객체지향은 실행될 코드를 필요할 때 마다 객체에서 호출해서 사용하는 식으로 진행되기 때문에 코드의 실행처리속도가 비교적 느리다. 
- 객체가 많으면 용량이 커질 수 있다.
- 객체 지향 프로그래밍이 가진 대부분의 장점은 객체 간의 결합도가 낮을 때 적용되기 때문에 설계시 많은 시간과 노력이 필요하다.


### SOLID 원칙
객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 응집도는 높이고, 결합도는 낮춰야 한다는 관점에서 정립되었다.

#### 결합도와 응집도

- **결합도** : 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이

- **응집도 :** 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이


#### 1. **SRP(Single Responsibility Principle) : 단일 책임 원칙**

- 모든 클래스는 **단 한 가지의 책임만을 가지고**, 그 하나의 책임을 수행하는데 집중되어 있어야 한다.
- 클래스를 **변경하는 이유**는 단 한개여야 한다. → 변경을 유발하는 **행위자**가 명확해야 한다.
- 하나의 속성이 **여러 의미를 갖는 경우**가 존재하면 안된다.
- 메서드가 단일 책임 원칙을 지키지 않을 경우 나타내는 대표적인 문제가 **분기 처리를 위한 if 문 사용**

#### 2. OCP(Open Closed Principle) : 개방 폐쇄 원칙

- "소프트웨어 엔티티(클래스, 모듈, 함수 등) 는 **자신의 확장에 대해서는 열려 있어야 하지만 주변의 변경에 대해서는 닫혀 있어야 한다**."
- 기능을 확장하거나 변경할때 그것을 사용하는 코드는 수정하지 않는다.
- 상위 클래스 또는 인터페이스를 **완충장치로 사용**
- 장점 : 유연성, 재사용성, 유지보수성

❗**모든** 클래스의 결합 관계를 상위클래스나 인터페이스를 두고 느슨한 관계로 유지해야 할까??

→ 모든 확장에 대하여 예측을 미리 할 수 없으니 명확하게 확장이나 변경이 예상되는 시점에 적용하는 것이 좋지 않을까 생각합니다.

#### 3. **LSP(Liskov Substitution Principle) : 리스코프 치환 원칙**

하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 **상위 클래스의 인스턴스 역할을 하는데** 문제가 없어야 한다.
상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

- 하위형에서 선행 조건 은 강화될 수 없다.
    
    → 선행 조건 : 상위 클래스에서의 인자값에 대한 규칙
    
- 하위형에서 후행조건은 약화될 수 없다.
    
    → 후행 조건 : 상위 클래스에서 구현한 함수 종료 시점에 전달될 객체 값이 유효한 값인지 검사
    
- 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

- 리스코프 치환 원칙이 지켜지지 않으면 개방 폐쇄 원칙을 위반하게 된다.

#### 4. **ISP(Interface Segregation Principle) : 인터페이스 분리 원칙**


- 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다. 즉, 하나의 일반적인 인터페이스보다는 클라이언트를 기준으로 분리되어 구체적인 여러 개의 인터페이스가 효율적이다.

- SRP와 ISP는 같은 문제에 대한 두가지 다른 해결 책
  → 요구사항과 설계자의 취행에 따라 선택할 수 있지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는것이 더 좋은 해결책
    
- **상위 클래스는 풍성할수록 좋고, 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공**
    - 인터페이스는 그 역할에 충실한 최소한의 기능만 공개
    - 상위 클래스형의 참조 변수를 이용해야 상속의 가장 큰 혜택을 볼 수 있다.

#### 5. **DIP(Dependency Inversion Principle) : 의존 역전 원칙**

- "**고차원 모듈은 저차원 모듈의** 구현에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
- "**추상화된 것은 구체적인 것에** 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
- "**자주 변경되는 구체 클래스에** 의존하지 마라 "

즉, 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변**하기 쉬운 것의 변화에 영향받지 않게 하는 것**이 의존 역전 원칙이다.

+) 예시 : 자동차 -> 윈터 타이어 (X) || 자동차 -> 타이어 <- 윈터 타이어, 4계절 타이어, 레이스용 타이어 (O)

#### 정리

단일 책임 원칙과 인터페이스 분리 원칙은 객체가 커지지 않도록 막아준다. 객체가 단일 책임을 갖게 하고 클라이언트마다 다른 인터페이스를 사용하게 함으로써 한 기능의 변경이 다른 곳에까지 미치는 영향을 최소화할 수 있고, 결국 수정, 유지보수에 유리하다.

개방 폐쇄 원칙은 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장을 하면서도 기존 코드를 수정할 필요가 없도록 만들어 준다. 여기서, 변화되는 부분을 추상화할 수 있도록 도와주는 원칙이 바로 의존 역전 원칙이고, 다형성을 도와주는 원칙이 리스코프 치환 원칙이다.


### 객체지향 vs 절차지향 vs 함수형 프로그래밍

#### 절차적 프로그래밍
프로그램이 실행 되는 절차를 설계하고 이 절차에 맞게 프로그래밍 하는 방법. 대표적으로 C언어가 있다.

- 장점 
  - 코드의 가독성이 좋다,
  - 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다.

- 단점
  - 각각의 코드가 순서에 민감하게 연결 되어있어, 유지보수 및 디버깅이 어렵다.
  - 동일한 결과를 보장하기 어렵다.

- 기능별로 묶어 모듈화 함으로써 중복적 연산을 줄여주고 재사용 할수 있어 유지보수에 유리한 객체 지향이 등장하였다.
- 객체지향과 절차 지향은 서로 반대되는 개념이 아니다. 객체지향 역시 절차적으로 프로그램이 실행된다. 

#### 함수형 프로그래밍

함수형 프로그래밍은  이 순수함수를 1급 객체로 간주하고 이를 조합하여 소프트웨어를 프로그래밍 하는 방식이다.
순수 함수는 
- 같은 인풋 값에 있어서는 동일한 아웃풋 값이 나와야한다.
- 함수가 실행되는 동안 프로그램에 영향을 미쳐서는 안된다. ( thread에 안전성을 보장)

+) 1급 객체 : 
	- 변수나 데이터 구조 안에 담을 수 있다.
 	- 파라미터나 반환값으로 사용할 수 있다.
    - 할당에 사용된 이름과 무관하게 고유한 구별이 가능하다.

- 함수형 프로그래밍에서의 데이터는 변하지 않는 불변성을 유지해야 한다. 데이터의 변경이 필요한 경우, 원본 데이터 구조를 변경하지 않고 그 데이터의 복사본을 만들어서 작업을 진행한다.

- 장점
  - 테스트가 쉽다.
  - 높은 수준의 추상화를 제공한다.
  - 함수 단위의 코드 재사용이 수월하다.
  - 불변성을 지향하기 때문에 프로그램의 동작을 예측하기 쉬워진다.

- 단점
  - 외부 데이터 혹은 내부 데이터의 상태를 조작할 수 없다.
  - 순수함수를 사용하는 것은 쉬울 수 있지만 조합하는 것은 쉽지 않다.
  

- C++, Python, JavaScript, Java와 같은 언어의 최신버전에 함수형 프로그래밍의 특징들이 더해졌다.



## JDK, JRE, JVM

### JDK : Java Development Kit  |  자바 개발 도구
JRE를 포함하고, Java application의 개발을 위한 자바 소스 컴파일러(javac.exe)와 디버거 등을 포함하는 프로그램이다. 

+) 자바 소스 컴파일러 : JVM이 이해할 수 있도록 소스파일(*.java)를 목적파일(*.class, 바이트파일)로 변환시켜주는 역할

### JRE : Java Runtime Enviroment | 자바 실행 환경

JVM 과 JVM이 자바 프로그램을 동작시킬 때 필요한 핵심 라이브러리, 자바 런타임에서 사용하는 설정이나 리소스 파일 등 으로 구성되어 있다. 자바 프로그램 실행기 (java.exe) 와 라이브러리를 자바 코드와 결합 한 후 JVM이 원활하게 잘 작동할수 있도록  환경을 구성하는 역할을 한다.

#### JDK 와 JRE
JDK가 자바 기반 소프트웨어를 개발하기 위한 도구들로 이뤄진 패키지인 반면, JRE는 자바 코드를 실행하기 위한 도구들로 구성된 패키지라는 점이다.

java 11부터는 JRE 없이 JDK 만 제공한다. 이유는??

### JVM : Java Virtual Machine |  자바 가상 머신

메모리 상에만 존재하는 가상 컴퓨터로, 자바 바이트 코드(.class)를 어떠한 OS 에서도 실행될 수 있게 최적화하는 역할을 한다. (Write Once Run Anywhere) JVM은 특정 플랫폼 (하드웨어와 OS의 조합) 에 종속적 이다. (윈도우용 JVM)

#### jvm 구성요소

- Class loader 
런타임 시점에서 클래스 파일을 메모리에 적재
- Runtime Data Access 
메모리 공간 관리 : 총 5가지 영역으로 나누어짐 : PC 레지스터, JVM 스택, Native Method 스택, 힙, 메서드 영역
- Execution Engine (실행 엔진)
클래스 로더를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명렁어 단위로 읽어서 실행
- Garbage Collector
 힙 메모리에 남아있는 데이터를 효율적으로 관리(삭제)하는 역할



**한 줄 정리,**

JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 실행된다.


## 자바 컴파일 과정

1. 개발자가 자바 소스코드(.java)를 작성

2. 자바 컴파일러(javac)가 자바 소스파일을 JVM이 이해할 수 있는 자바 바이트 코드 파일(.로 컴파일한다.

3. 컴파일된 바이크 코드를 JVM의 클래스 로더에게 전달

4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 런타임 데이터 영역(Runtime Data area), 즉 JVM의 메모리에 올린다.
	- 클래스 로더 세부 동작 : 바이트 코드를 BootStrap, Extension, Application 3가지의 클래스 로더로 로딩하여 링크로 코드 내부의 레퍼런스를 실제 메모리 레퍼런스로 연결하고 추가적으로 static 변수는 초기화 과정까지 거쳐 실행 엔진이 사용할 수 있도록 JVM 메모리의 메서드 영역에 적재하는 시스템이다.

5. JVM의 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 이때, 인터프리터와 Jit 컴파일러가 사용된다.
    
    
## 컴파일 언어 vs 인터프리터 언어
작성한 프로그램을 실행하기 위해서는 컴퓨터가 이해할 수 있는 기계어로 변환해 주어야 한다. 이 방법에는 대표적인 2가지 방식이 있다.

### 컴파일 언어
빌드타임에 작성한 모든 소스코드에 대한 기계어를 생성하고 런타임에 생성된 모든 기계어를 한 번에 JVM같은 machine으로 보낸다. 컴파일 이후에는 실행이 빠르다. 대표언어로는 C, C++이 있다.

- 컴파일 과정에서는 시간이 상당히 많이 소요되고 메모리도 많이 차지한다.

### 인터프리터 언어
빌드타임에는 별다른 동작을 하지 않고, 런타임시 한 행씩 해석하여 알맞은 기계어를 생성한 뒤 명령어를 실행한다. 실행속도가 느리지만 코드 변경시 빌드 과정없이 즉시 실행이 가능하여 테스트에 용이하다.

- 인터프리터는 별도의 실행파일이 존재하지 않는다.
- 소스 코드가 실행되기 전까지는 소스 코드의 버그를 인지하는 것이 어렵다.
- 빌드 속도는 빠르지만 연산 속도나 실행 속도에 민감한 프로그램은 인터프리터 언어로 개발하지 않는다.

R, Python, Ruby와 같은 언어들이 대표적인 인터프리터 언어이다.



### 자바는 컴파일? 인터프리터?

자바는 빌드타임에 자바 코드를 컴파일하여 바이트 코드를 생성하고 런타임 시 JVM의 실행 엔진이 jvm 메모리에 적재된 바이트 코드를 기계어로 인터프리터하여 실행한다. 따라서, 컴파일과 인터프리터가 둘다 사용하는 성향을 가지고 있고 순수 컴파일에 비해서 실행 속도가 느리다. JIT 컴파일러를 사용하면 매번 기계어로 번역하지 않고 이전에 실행한 코드를 캐싱하여 재사용하기 때문에 좀 더 빠른 실행이 가능하다.

+) 같은 컴파일러로 중간언어를 만들기 때문에 운영체제에 독립적

## JVM 메모리 구조 (Runtime Data Area)

1. Method area 

모든 쓰레드가 공유하는 메모리 영역이고 JVM이 시작될 때 생성된다. 메소드 영역은 클래스, 인터페이스, 메소드, 필드, Static 변수&메서드 등의 바이트 코드를 보관한다. 

2. Heap area

모든 쓰레드가 공유하며, 타임에 동적으로 할당되는 데이터가 저장되는 영역(new 키워드로 생성된 객체와 배열)이다. 또한, 메소드 영역에 로드된 클래스만 생성이 가능하고 힙에 할당된 데이터들은 가비지컬렉터의 대상이 된다.  

3. Stack area 

메서드 호출 시마다 각각의 스택 프레임이 생성한다. 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다. 마지막으로, 메서드 수행이 끝나면 프레임별로 삭제한다.
 

4. PC Register

쓰레드가 시작될 때 생성되며, 쓰레드마다 하나씩 존재한다. 주로 쓰레드의 상태를 기록을 하는 부분으로 현재 수행중인 JVM 명령의 주소를 갖는다.
 

5. Native method stack

기계어로 작성된 프로그램을 실행시키는 영역


## Garbage Collector 동작과정
