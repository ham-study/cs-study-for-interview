## HTTP

### HTTP(Hyper Text Transfer Protocol)란?
인터넷에서 서버/클라이언트 모델을 따라  하이퍼텍스트 기반 데이터(주로 HTML)를 주고 받기 위한 프로토콜이다.

+) **서버/ 클라이언트 모델은** 클라이언트에서 요청(request)를 보내면 서버는 요청을 처리해서 응답(response)하는 방식이다.  **클라이언트는** 클라이언트 소프트웨어(IE, Chrome, Firefox, Safari ...)가 설치된 컴퓨터를 이용하는 일종의 사용자이 며, **서버는** 서버 소프트웨어가 설치된 컴퓨터(Apache, nginx, IIS, lighttpd) 를 이용하는 개발자 또는 관리자이다. 클라이언트는 URI를 이용해서 서버에 접속하고, 데이터를 요청할 수 있고, 웹서버는 보통 표준포트인 80번 포트로 서비스한다.

- 80번 포트를 사용하고 있다
- 애플리케이션 레벨의 프로토콜로 TCP/IP위에서 작동한다.
- HTTP는 상태를 저장하지 않는다(Stateless).
- HTTP는 Connectionless(비연결성) 방식으로 작동한다. 

+)** Stateless :** 서버는 클라이언트가 이전에 접속한 클라이언트인지 확인할 수 없다. 예를들어 웹사이트에 로그인했을 때, 다른 페이지로 이동하면 로그인이 해제되는 문제가 발생한다. 이에 대한 해결책으로 쿠키와 세션이있다. Connectionless 로 부터 파생되는 특징이다. (연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없다.)

+) **비연결성은** 클라이언트와 서버 사이에서 요청과 응답이 종료되면 연결을 끊는 성질이다. 비연결성의 장점은 연결 유지를 위한 리소스가 불필요하여 불특정 다수를 대상으로 하는 서비스에 적합한 방식이다.( 더 많은 유저의 요청을 처리 가능) 반면 동일한 클라이언트가 지속적으로 연결 해제를 반복하면 그에 따른 오버헤드가 발생하는 단점이 있다. 이에 대한 해결책으로 keep alive 속성이 있다. time out과 max connection수를 설정해 연결을 유지하여 오버헤드를 줄일 수 있다.


### HTTP 메세지 구조
StartLine, Headers, Body 등으로 구성된다.

- Request 시 StartLine 은 Method, Path, Version로 구성 되어 있다.
  - Path: 어디로 보내는지에 대한 URI 이다.
- Response 시 StartLine 은 HTTP Version, Status Code, Status text(응답 상태) 로 구성 되어 있다.
- Headers : Key -value 로 구성되어 있으며 HTTP 전송에 필요한 모든 부가정보(패킷에 대한 메타데이터)가 담겨 있다.
- Body : 메세지의 본문을 담고 있으며 생략 가능하다.


### HTTP 문제점
- HTTP 는 평문 통신이기 때문에 도청이 가능하다.
- 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
  - IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 
- 정보의 정확성을 증명할 수 없기 때문에 변조가 가능하다.
  - 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다.
  -  공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 부른다.
  
해결법 : SSL 즉 HTTPS를 사용하여 해결할 수 있다.

-  통신 자체를 암호화 : SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP 의 통신 내용을 암호화할 수 있다.
-  통신 상대를 확인 : SSL 은 상대를 확인하는 수단으로 증명서 를 제공하고 있다. 증명서는 신뢰할 수 있는 제 3 자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다.
- 정보의 정확성을 증명 : SSL 에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.

### HTTP status code
서버는 요청에 대한 처리 상태를 숫자로서 반환하는데 이것을 상태 코드라고 한다. 3자리 숫자로 만들어져 있으며, 첫번째 자리는 1에서 5까지 제공된다. 첫번째 자리가 4와 5인 경우는 정상적인 상황이 아니기 때문에 사이트 관리자가 즉시 알아야 하는 정보이다.

### 1xx (정보) 
서버가 요청을 받았으며, 서버에 연결된 클라이언트는 작업을 계속 진행하라는 의미이다. 해당 코드는 HTTP 1.0에서 지원되지 않는다.

### 2xx (성공) 
요청이 정상적으로 처리되었음을 나타내는 상태코드이다.

200 OK
요청이 성공적으로 되었다.  HTTP 메서드에 따른 응답으로 반환된다.

201 Created
요청이 성공적으로 처리되어 리소스가 만들어진 경우. 이 응답은 일반적으로 POST 요청 또는 일부 PUT 요청 이후에 따라온다.

202 Accepted
서버가 요청을 접수했지만 아직 요청을 완료하지 못했다. 다른 프로세스에서 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어졌다.

204 No Content
클라이언트의 요청은 정상적으로 처리하였지만 응답할 컨텐츠가 없는 경우(HTTP Response body가 아예 존재하지 않는 경우) 하지만 헤더는 의미있을 수 있다. DELETE Method 인 경우 많이 사용된다.
사용자-에이전트는 리소스가 캐시된 헤더를 새로운 것으로 업데이트 할 수 있습니다.

#### 3xx (리다이렉션) 
요청 완료를 위해 추가 작업 조치가 필요하다는 의미다. 주로 새 URL로 리다이렉트를 유도한다. 

300 Multiple Choice
클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환된다. 사용자 에이전트 또는 사용자는 이 중 하나를 선택해야 한다. 응답 중 하나를 선택하는 표준화된 방법이 없기 때문에, 이 응답 코드는 거의 사용되지 않는다.

301 Moved Permanently
요청한 리소스의 URI가 변경되었음을 의미한다. 해당 응답을 받으면, 브라우저는 HTTP 헤더에 들어있는 Location 필드를 찾아 해당 필드가 존재할 경우, Location 필드에 담긴 URL로 자동으로 리다이렉션한다. 

302 Found
요청된 리소스가 Location 헤더가 지정한 URL로 일시적으로 이동되었음을 나타낸다. 새롭게 변경된 URI는 나중에 만들어질 수 있으므로, 브라우저는 이 페이지로 리디렉션 되지만 검색 엔진은 리소스에 대한 링크를 업데이트하지 않는다.

307 Temporary Redirect
302와 유사하며, User-Agent가 반드시 HTTP 메소드를 변경하지 말아야 한다는 점만 다르다.

308 Permanent Redirect
301과 유사하며, User-Agent가 반드시 HTTP 메소드를 변경하지 말아야 한다는 점만 다르다.  만약 첫 요청에 POST가 사용되었다면, 두번째 요청도 반드시 POST를 사용해야 한다.

#### 4xx (클라이언트 에러) 
클라이언트의 요청이 유효하지 않아 서버가 해당 요청을 수행하지 않았다는 의미다. 주로 유효하지 않은 자원을 요청했거나, 요청의 권한이 없는 경우 발생한다.

400 Bad Request
잘못된 문법 등으로 인해 클라이언트가 올바르지 못한 요청을 보내 서버가 요청을 이해할 수 없음을 의미한다.

401 Unauthorized
인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우의 응답이다. 보통 로그인이 필요한 API를 비로그인 사용자가 호출했을 때 사용된다.

403 Forbidden
클라이언트가 콘텐츠에 접근할 권한을 가지고 있지 않음을 의미한다. 401과 다른 점은 서버가 클라이언트가 누구인지 알고 있다는 것이다. 보통 특정 IP나 국가가 차단되어 있는 사이트에 접속을 시도한 경우 사용된다.

404 Not Found
요청한 리소스가 존재하지 않음을 의미한다. 인증되지 않은 클라이언트로부터 리소스를 숨기기 위해 403 대신 이 응답을 전송하기도 한다.

405 Method Not Allowed
현재 리소스에 맞지 않는 메소드를 사용했음을 의미한다. 예로는 GET 요청만 허용되는데 POST 요청을 한 경우의 응답

408	Request Timeout	
요청에 응답하는 시간이 너무 오래 걸림을 의미

413	Payload Too Large	
요청이 너무 커서 서버가 처리할 수 없을 때의 응답

429	Too many Requests	
클라이언트가 지정된 시간에 너무 많은 요청을 보낸 경우의 응답


#### 5xx (서버 에러) 
서버 오류로 인해 요청을 수행할 수 없다는 의미다.

500	Internal Server Error	
서버 내부에서 오류가 발생하여 응답할 수 없음을 의미한다. 

502	Bad Gateway	
서버가 게이트웨이로부터 잘못된 응답을 수신했음을 의미한다. 서버의 부모 서버에서 오류가 발생한 경우의 응답이다. 보통 서버에 접속하는 사용자가 많아 과부하될 때 발생

503	Service Unavailable	
서버가 요청을 처리할 준비가 되지 않음을 의미한다. 일반적으로 유지보수를 위해 작동이 중단되거나 과부하가 걸린 경우의 응답이다.


### HTTP METHOD
클라이언트는 서버에 요청할 때 어떤 행위를 목적으로 요청을 전송하는 것인지 http메서드를 통해 명시할 수 있다.

### GET
GET은 보통 리소스를 조회할 때 사용하며 데이터를 Header(헤더)에 포함하여 전송한다. URL에 변수(데이터)를 포함시켜 요청하기 때문에 데이터를 보내는 양에 한계가 있으며 보안에 취약하다. GET방식을 사용하여 데이터를 노출시키는 경우는 개인정보가 포함되지 않는 상황에서 캐싱을 하여 속도를 높이는 경우가 많다.

### POST
주로 신규 리소스를 등록하거나 프로세스 처리에 사용된다. 메시지 바디를 통해 서버로 데이터를 전달한다. 

- 헤더필드 중 Body의 데이터타입을 명시하는 Content-Type 필드가 필요하다.
- 데이터를 Body에 포함시키는 이점 때문에 메세지 길이의 제한은 없지만 최대 요청을 받는 시간인 Time Out이 존재하므로 클라이언트에서 페이지를 요청하고 기다리는 시간이 존재한다.
- URL에 데이터가 노출되지 않으므로 즐겨찾기나 캐싱이 불가능하지만 기본 보안이 가능하다.

### PUT
PUT은 리소스가 있으면 데이터를 덮어쓰고 리소스가 없으면 생성한다. PUT은 POST와 다르게 클라이언트가 리소스의 위치를 알고 URI에 지정해 주어야 한다.

### PATCH
PATCH는 PUT과 마찬가지로 리소스를 수정할 때 사용하지만, PATCH는 리소스를 부분적으로 변경할 수 있다.

### DELETE
DELETE는 리소스를 제거할때 사용한다. 어느 자원을 삭제할 지 지정해 주어야 한다.

### HTTP 메소드의 속성

1. 안전(Safe Methods)

계속해서 메소드를 호출해도 리소스를 변경하지 않는다는 뜻이다. 주요 메소드중에는 GET 메소드가 안전하다고 볼 수 있다.

2.멱등(Idempotent Methods)

메소드를 계속 호출해도 결과가 똑같다는 뜻이다. Get, PUT, DELETE, PATCH는 멱등하다고 볼 수 있지만 POST는 멱등하다고 볼 수 없다.

3. 캐시가능(Cacheable Methods)

캐시가능하다는 말은 말 그대로 캐싱을 해서 데이터를 효율적으로 가져올 수 있다는 뜻이다. GET, HEAD, POST, PATCH가 캐시가 가능하지만 실무에서는 구현이 어렵기 때문에 GET, HEAD 정도만 캐시 하여 사용한다.
