## 로드 밸런서(Load Balancer)

점점 웹사이트 규모가 커지고 접속하는 사용자의 수가 급격히 늘어나게 되었다. 따라서 이 사용자들에 대해 모든 트래픽을 감당하기엔 1대의 서버로는 부족하다. 대응 방안으로 하드웨어의 성능을 올리거나(Scale-up) 여러대의 서버를 추가하여 요청은 나눠주는 것(Scale-out)이 있다.

하드웨어 성능을 높이는 방법은 비용이 많이 들고 서버가 여러대면 무중단 서비스를 제공하는 환경 구성이 용이하므로 Scale-out이 효과적이다. 이때 **여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 바로 로드 밸런싱이다.**

로드 밸런싱은 분산식 웹 서비스로, 클라이언트와  서버풀(Server Pool, 분산 네트워크를 구성하는 서버들의 그룹) 사이의 Load Balancer가 여러 서버에 부하(Load)를 나누어주는 역할을 한다. 

+) 트래픽(traffic)이란 서버와 스위치 등 네트워크 장치에서 일정 시간 내에 흐르는 데이터의 양을 말한다. 웹사이트에 트래픽이 많다는 것은 사용자 접속이 많아서 전송하는 데이터의 양이 많다는 것을 뜻한다.

### 로드 밸런서 알고리즘
- 라운드 로빈(Round Robin) : 서버에 들어온 요청을 순서대로 돌아가며 할당하는 방식이다. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합하다.

-  가중 라운드로빈 방식(Weighted Round Robin Method) : 각각의 서버마다 가중치(처리 용량)를 부여하고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분한다. 주로 서버의 트래픽 처리 능력이 상이한 경우 사용되는 방식

-  IP 해시 방식(IP Hash Method) : 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식이다. 사용자의 IP를 해싱해 로드를 분배하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장한다.

+) Hashing : 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 매핑하는 행위나 함수

-  최소 연결 방식(Least Connection Method) : 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분한다. 트래픽으로 인해 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합한 방식

- 최소 리스폰타임(Least Response Time Method) : 서버의 현재 연결 상태와 응답시간을 모두 고려하여 트래픽을 배분한다. 가장 적은 연결 상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 로드를 배분하는 방식

+) 서버의 부하 상태는 시험 패킷 등을 이용하여 웹 서버에 보내 응답 시간으로 판단할 수 있다.

### L4와 L7
로드 밸런싱에는  L4 로드밸런서와 L7 로드밸런서가 가장 많이 활용된다. L4 로드밸런서부터 포트(Port)정보를 바탕으로 부하를 분산하는 것이 가능하다. 


- L4 로드밸런서는 네트워크 계층(IP, IPX)이나 트랜스포트 계층(TCP, UDP)의 정보를 바탕으로 로드를 분산한다. IP, Port, Session 기반으로 트래픽을 나누는 것이 가능하다.

- L7 로드밸런서의 Application Layer에서 동작하는 스위치로 HTTP URI, FTP 파일명, 쿠키정보 packet payload(관심있는 데이터)를 분석하여 좀 더 정교한 로드밸런싱이 가능하다. L4 Load Balancer는 단지 부하를 분산시키는 것이라면, L7 Load Balancer는 패킷의 내용을 확인하고  요청의 세부적인 사항에 따라 부하를 특정 서버에 분배하는 것이 가능한 것이다. 

L7 로드밸런서의 경우 데이터 분석을 통해 특정한 패턴을 지닌 바이러스를 감지해 네트워크를 보호할 수 있으며, DoS/DDoS와 같은 비정상적인 트래픽을 필터링할 수 있어 네트워크 보안 분야에서도 활용되고 있다.
+) 행위에 따라 로드 밸런싱

상위 계층에서 사용되는 장비는 하위 계층의 장비가 갖고 있는 기능을 모두 가지고 있으며, 상위 계층으로 갈수록 더욱 정교한 로드밸런싱이 가능하다.

### 로드 밸런서 장애 대비
로드 밸런서에 장애 발생 시, 서비스 운영 중단 시간을 최소한으로 하기 위해 대기 서버를 둔다. 이를 이중화라 하며 평소에는 트래픽을 분배하지 않는다. Acitve 중인 로드밸런서와 Standby 상태의 로드밸런서가 heartbeat를 주고 받으며 서로 정상적으로 동작하는 지 health check를 한다. Ative L/B에 장애가 발생했을 경우 Standby L/B가 작업을 이어받는다.

### 로드밸런싱 유형
로드 밸런싱을 구성하는 대표적인 세가지 유형이 있다. 로드밸런서의 기능은 동일하며 상황에 맞게 동작 방식과 트래픽을 분산하는 내부 알고리즘 등이 조금씩 다르게 적용한다.

1. Load Balancing with DNS
DNS(Domain Name System)은 도메인 이름을 IP주소로 변환하는 기술이다. Load Balancing with DNS는 하나의 도메인 이름을 라운드로빈 방식으로 N개의 IP주소로 변환하여 트래픽을 분산한다. N개의 서버가 멀리 떨어져 있어서 실시간으로 헬스 체크가 어렵거나, 별도의 소프트웨어나 로드밸런싱 장비를 사용하지 않기에 적은 비용으로 구현이 필요할 때 사용한다.

2. Load Balancing with Hardware
하드웨어 로드 밸런싱은 전용 하드웨어 장비를 통해 부하를 분산한다. 하드웨어 장비로 로드밸런싱을 할 경우 가격이 비싸지만 좋은 성능을 제공한다.

3. Load Balancing with Software
소프트웨어 로드밸런서는 구매한 하드웨어 서버에 설치하거나, 클라우드 환경(AWS, Google Cloud, Azure...)에 설치하여 사용한다.

NginX : 트래픽이 많은 웹 사이트를 위해 네트워크 확장성을 주목적으로 설계한 경량 HTTP 서버로, 리버스 프록시로도 활용이 가능하다.

HAProxy(High Availability Proxy) : HAProxy는 TCP와 HTTP 기반 어플리케이션을 위해 사용된다. 오픈소스 로드밸런싱의 표준 중 하나이며, 다양한 리눅스 버전에서 사용할 수 있다. 트래픽이 굉장히 많은 경우 HAProxy를 통해 효과적인 부하 분산이 가능하다.


## Blocking & Nonblocking  

Blocking : 호출된 함수가 작업을 하는동안 호출한 함수에게 작업에 대한 제어권이 없는 상태로, 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 방식이다.
+)  Blocking I/O Model 에서 System Call이 끝날때까지 프로그램은 대기해야 하고 (Wait QueueSynchronous 에서는 System Call이 끝날때까지 기다리고 결과물을 가져온다.) System Call이 완료가 되면 그때야 Return 한다. & 자바의 Scanner

Non-Blocking : 함수를 호출할 때 호출한 함수에게 바로 제어권을 건내주어 호출한 합수가 다른 일을 진행할 수 있는 방식을 말한다.

Blocking과 Non-Blocking의 차이는 호출된 함수가 호출한 함수에게 제어권을 바로 넘기는 것의 유무이다.


## Synchronous/Asynchronous

Synchronous : Synchronous 에서는 System Call이 끝나면 그때 결과물을 가져온다. 
+) System Call의 Return을 기다리는 동안 Wait Queue에 머물 수도 아닐 수도 있다.

Asynchronous : System Call이 완료되지 않아도 나중에 완료가 되면 그때 결과물을 가져온다. 주로 Callback 함수를 통해 결과물을 가져온다.

Sync / Async 는 호출된 함수의 종료를 호출한 함수가 처리하느냐, 호출된 함수가 처리하느냐의 차이다.


Java : Sync +Block
Java Script : Async + Non-Block

