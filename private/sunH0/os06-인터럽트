## 인터럽트 개념

### 시스템 각 자원들의 상태를 확인하는 방법

**1. 풀링**
CPU가 일정한 시간 간격을 두고 각 자원들의 상태를 주기적으로 확인하는 방식

단점 :
- 폴링 주기가 적절해야 하고, 다음 주기까지 시스템 상태를 알릴 수 없다.
- 이벤트가 발생하지 않아도 CPU는 주기적으로 폴링하여야 한다.

**2. 인터럽트**
프로그램을 실행 중에 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생된 상황을 우선적으로 처리하도록 요구하는 방식
-> **(풀링 단점 해결)** CPU가 시간을 따로 들여 확인하지 않고, 이벤트 발생 시 죽시 알려서 처리한다. 즉, 발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법

+) 인터럽트는 풀링에 비해 문맥 교환에 따른 비용이 수반되기 때문에 항상 성능이 뛰어나다 할 수 없다. 빠른 하드웨어 장치라면 폴링이 자주 일어나지 않기에 더 효율적이고 느린 하드웨어 장치라면 인터럽트가 더 효율적이다.

### 인터럽트 종류
CPU 기준 발생하는 예외상황에 따라 크게 2가지로 나뉜다.

**1. 내부 인터럽트**
cpu가 처리할 수 없는 잘못된 명령이나 데이터를 사용할 때 내부적으로 발생하는 interrupt를 exception 이라고 한다.

- 프로그램 검사 인터럽트(Program check interrupt) :
0으로 나누기가 발생한 경우, OverFlow 또는  UnderFlow가 발생한경우, 프로그램에서 명령어를 잘못 사용한 경우, 부당한 기억장소의 참조

**2. 외부 인터럽트**
주로 CPU 코어 외부 요인으로,
- 전원 이상 인터럽트 : 정전, 파워 이상 등
- 기계 착오 인터럽트 : CPU의 기능적인 오류
- 외부 신호 인터럽트 : 타이머에 의해 자원 할당 시간이 종료된 경우, 키보드로 인터럽트 키를 누른 경우(ctrl + alt +delete), 외부 장치로부터 인터럽트 요청이 있는경우 발생
- 입출력 인터럽트(I/O Interrupt) :
	- 입출력장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
	- 입출력 데이터에 이상이 있는 경우

+) SVC(SuperVisor Call) 인터럽트 :
프로세스 관리 호출, 기억장치 할당 루틴 호출, 입출력 수행 루틴 호출 시에 발생하는 인터럽트로 사용자가 새로운 프로그램을 실행할 때 발생

#### 동기적 인터럽트와 비동기적 인터럽트
프로세스가 실행 중인 명령어로 인해 발생하는 인터럽트를 **동기적 인터럽트(내부 인터럽트)**라 한다. 그리고 다른 하드웨어 장치가 실행 중인 명령어와 무관하게 생성하는 인터럽트를 **비동기적 인터럽트(외부 인터럽트)**라 한다.

+) 보통 동기적인 인터럽트를 예외(Exception), 비동기적인 인터럽트를 인터럽트라고 한다,


### 인터럽트 처리 과정

1. **인터럽트 요청**
2. **프로그램 실행 중단:** 현재 실행중이던 Micro operation 까지 수행
3. **현재의 프로그램 상태 보존:** PCB(Process Control Block), PC(Program Counter) 등
4. **인터럽트 원인 판별: **
	- 인터럽트를 요청한 장치를 식별
    - Interrupt Vector 테이블을 참조하여 호출할 ISR 주소 값을 얻는다.
5. **ISR(Interrupt Service Routine) 실행**
 	- 실질적인 인터럽트 처리 작업 수행
	- 서비스루틴 수행 중 우선순위가 더 높은 인터럽트가 발생하면 또 재귀적으로 1~5를 수행한다.
	- 인터럽트 서비스 루틴을 실행할 때 인터럽트 플래그(IF)를 0으로 하면 인터럽트 발생을 방지할 수 있다.
6. **상태복구 :** 인터럽트 발생 시 저장해둔 PC(Program counter)를 다시 복구하여 이전 실행 위치로 돌아간다.
7. **중단된 프로그램 실행 재개:** PCB의 값을 이용하여 이전에 수행중이던 프로그램을 재개한다.

일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선 순위가 높고 내부 인터럽트 보다 외부 인터럽트가 **우선 순위가 높다.**

#### 인터럽트 우선순위
1. 전원 이상(Power fail)
2. 기계 착오(Machine Check)
3. 외부 신호(External)
4. 입출력(I/O)
5. 명령어 잘못
6. 프로그램 검사(Program Check)
7. SVC(SuperVisor Call)

+) 인터럽트 서비스 루틴 : 인터럽트 핸들러는 실제 인터럽트를 처리하기위한 루틴으로 인터럽트 핸들러라고도 불린다. 운영체제의 코드 영역에는 인터럽트별로 처리해야할 내용이 이미 프로그래밍되어 있다.

+) 인터럽트 백터 : 인터럽트 발생시 처리해야할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고있는 테이블

### 인터럽트와 이중 모드
일반 사용자로부터 시스템을 보호하기 위해 하드웨어적으로 이중모드를 지원한다. 이중모드는 사용자 모드와 커널 모드가 존재한다. 일반적인 프로세스는 사용자 모드에서 실행되지만, 하드디스크 입출력, 프로세스 생성  같은 특권 명령어는 커널 모드에서만 실행할 수 있다.
즉, CPU가 특권 명령을 실행하려고 하면, 사용자 모드에서 커널 모드로 전환을 해야한다. 이러한 요청을 시스템 콜이라고 한다.

+) mode bit(user mode=1, kernel mode=0)를 통해 두 모드를 구분

사용자가 커널 모드로 진입 하는 경우는 **시스템 호출을 사용 한 경우, 인터럽트를 발생 시킨 경우**로 두가지 경우가 있다.

인터럽트 라인을 읽어서 커널 함수가 실행되는 것이지, 사용자 프로그램에서 직접 OS 영역의 호출을 하지는 않는다.

### DMA (Direct Memory Access)
기존의 폴링 방식때에는 CPU만이 메모리나 주변장치에 대한 권한을 가지고 있었는데 이 권한을 일부 DMA에 위임할 수 있다.

데이터가 프로세서를 반드시 통과해야하는 컴퓨터 내의 장치들간에 데이터를 주고받는 방법을 PIO(Programmed I/O)라고 한다. CPU의 PIO 작업 중 일부를 DMA 제어기라고 불리는 특수 처리기에 위임함으로써 CPU의 일을 줄여 줄 수 있다.

#### 동작 방식
DMA 전송을 시작시키기 위해서 호스트는 메모리에 DMA 명령 블록을 쓴다. 이 블록에는 전송할 자료가 있는 곳의 포인터와 전송할 장소에 대한 포인터, 그리고 전송될 바이트 수를 기록해 놓는다. 그리고 CPU는 이 DMA명령 블록의 주소를 DMA에게 알려주고 자신은 다른 일을 한다. DMA는 CPU의 도움 없이도 자신이 직접 버스를 통해 DMA 명령 블록을 접근하여 입/출력을 수행하게 된다. 입출력 작업이 끝나면 DMA 컨트롤러가 CPU에게 인터럽트를 발생시킨다.

+) CPU와 DMA가 동시에 메모리에 접근하는 경우에는 어떻게 될까? 이 때는 비교적 작업속도가 느린 DMA가 메모리 사용권한을 가지게 되는데, 이를 CPU입장에서 사이클 훔치기 라고 한다.

 



