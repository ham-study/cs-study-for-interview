# 프로세스

## 정의

- 실행중에 있는 프로그램을 의미
- 스케줄링의 대상이 되는 작업(task)과 같은 의미
- 하드디스크의 프로그램 실행 -> 메모리할당 -> 할당된 메모리 공간으로 바이너리코드 업로드 -> 프로세스 전환
- 프로세스 내부에는 최소 하나의 스레드(Thread)를 가지고 있다

## 구조

<img src ="https://user-images.githubusercontent.com/76610357/216294139-d5a7be21-0288-4e2e-a59a-1cef398ec23e.png">
스택, 힙, 데이터, 코드로 구성

- 스택
  - 데이터를 일시적으로 저장하는 영역
  - 지역변수를 저장, 해당 변수가 범위를 벗어나면 공간 해제됨
  - 호출한 함수의 반환 주소, 반환 값, 매개 변수 등에 사용
  - 값들이 쌓일 때마다 힙이 있는 방향으로 점점 커지며 두 공간이 만나게 되면 메모리가 소진되었다는 뜻
  - 컴파일시에 크기가 결정되어 무한히 할당 할 수 없다
- 힙
  - 동적으로 메모리를 할당하는데 사용되는 영역
  - 동적 메모리 할당이 발생하면 스택이 있는 위쪽 방향으로 커짐
  - 런타임시 크기 결정
- 데이터
  - 전역변수나 정적변수를 저장하거나 할당
  - Bss 영역과 Data영역으로 구분
    - Bss : 초기화 되지 않은 데이터
    - Data : 초기화 된 변수
- 코드
  - 프로그램의 코드 자체를 저장하는 영역

## 프로세스 상태

<img src = "https://user-images.githubusercontent.com/76610357/216378197-89958a63-3797-4ed4-b65a-69cac0836a88.jpg">

### 상태

- `생성` (new) : 프로세스가 생성
- `준비` (ready) : 자원을 할당받기 위해 대기하고 있는 상태
- `실행` (running) : 자원을 할당 받아 프로세스 실행
- `대기` (waiting / blocked) : 이벤트나 대기 신호 발생하여 완료될 때까지 대기
- `종료` (terminated) : 프로세스 종료

### 상태 전이

1. `new -> ready` : 프로세스가 생성됨과 동시에 ready 상태에서 자원할당을 기다림
2. `ready -> running` : 스케줄러가 ready 상태의 프로세스 하나를 골라(우선순위에 따라) 실행 상태로 변경
3. `running -> ready` : 스케줄러가 현재 수행중인 프로세스에서 다른 프로세스에게 자원을 할당해야 한다고 결정했을 때 발생
4. `running -> blocked` : 프로세스 실행 중 이벤트 및 I/O가 발생될때 변경. 이 때 ready 프로세스 하나를 실행시킴 (문맥교환 발생)
5. `blocked -> ready` : 이벤트가 완료된 프로세스는 ready 상태로 변경

## 프로세스 제어 블록 ; PCB (Process Control Block)

<img width="600" alt="image" src="https://user-images.githubusercontent.com/71180414/148107171-40e6b1ea-5775-48f5-925a-1f210988aa8b.png">

### 정의

- 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는, 운영체제 커널의 자료구조, 즉 PCB는 운영체제가 프로세스를 표현한 것
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.

### PCB의 포함 정보

- 프로세스 식별자
- 프로세스 상태 → create, ready, running, waiting, terminated
  - 이는 Stack으로 쌓인다.
  - 외에도 suspended ready라는 유예 준비상태 혹은 suspended waiting이라는 유예대기상태도 존재하는데, 이는 Stack 이 아닌 disk에 저장된다.
- 프로그램 계수기 → 프로세스 다음에 실행할 명령어의 주소를 가리킨다.
- CPU 레지스터 및 일반 레지스터
- 스케줄링 정보 → 우선순위, 최종 시간, CPU 점유시간 등
- 메모리 관리 정보 → 해당 프로세스의 주소 공간 등
- 프로세스 계정 정보 → 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
- 입출력 상태 정보 → 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등

### 역할

- 프로세스 스케줄링을 위해 데이터베이스를 관리
- 프로세스는 작업을 수행하며 작업 진행 상황(문맥 ; context)을 PCB에 저장한다
  - 프로세스가 진행하던 작업을 저장하지 않는다면 ready 상태에서 running상태가 되었을경우 이전작업의 내용들은 저장되어있지 않게된다.
- 또한, 운영체제는 빠르게 PCB에 접근하기 위해 프로세스 테이블을 사용하여 각 프로세스의 PCB를 관리하게 된다.

## 문맥 교환 ; Context Switching

- 현재 CPU를 사용중인 프로세스의 CPU 제어권이 다른 프로세스로 이양되는 과정
- ex) `현재 프로세스 A가 CPU를 사용하고 있는 상황에서 CPU 사용시간이 끝나 다음 프로세스에게 CPU를 넘겨주어여 합니다. 스케줄링 알고리즘에 의해 다음 CPU를 받을 프로세스 B가 선택되었으며 타이머 인터럽트가 발생해 CPU의 제어권을 운영체제에게 넘어가게 됩니다.`<br>
  이 과정에서 운영체제는 타이머 인터럽트 처리 루틴으로 가서 직전까지 수행중이던 프로세스 A의 문맥(프로그램 카운터 등)을 자신의 PCB에 저장하고 프로세스 B는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원 시키는 과정을 거치게 됩니다. <br>
  여기서 문맥교환에 필요한 시간, 메모리 등을 `오버헤드`라 부릅니다.

- 하나의 프로세스가 사용자 모드에서 실행되다가 커널모드로 실행모드만 바뀌는 경우는 문맥 교환이 아니다.
- CPU를 점유하는 프로세스가 다른 프로세스로 변경되는 과정이 아니기 때문이다.
  <br>
  <img src ="https://user-images.githubusercontent.com/76610357/216389467-0e82de76-c20f-4434-9e5c-5c7db2d6ad4c.jpg">
