# TCP/UDP

- 네트워크의 전송 계층에서 사용하는 프로토콜
- 데이터를 보내기 위해 사용하는 프로토콜

## TCP

- Transmission Control Protocol
- 신뢰성 있는 데이터 전송을 지원하는 `연결 지향형 프로토콜`
- 일반적으로 IP와 함께 사용, IP가 데이터의 전송을 처리, TCP는 패킷 추적 및 관리
- 3way-handshake라는 과정을 통해 연결후 통신을 시작하고, 흐름 제어와 혼잡 제어를 지원하며 데이터의 순서를 보장
- 데이터를 여러 패킷으로 나누고 수신측에서 재조합
- 높은 신뢰성을 보장
- UDP보다 속도가 느리다

## TCP Header 구조

![TCP](https://user-images.githubusercontent.com/76610357/220272928-fa236215-be5f-445f-a100-9b7b3afd799e.png)

- `Source port` : 출발지 포트번호
- `Destination port` : 목적지 포트번호
- `Sequence Number` : byte 단위로 순서화 되는 번호(TCP 세그먼트의 첫 번째 byte에 부여됨)이며 이것을 통해 신뢰성 및 흐름제어 기능을 제공
- `Acknowledge Number` : 수신하기를 기대하는 다음 byte번호
- `Offset` : 헤더 길이 필드이며 IPv4와 마찬가지로 나누기 4 계산후 2진수로 작성됨
- `Reserved` : 예약된 필드 현재 사용되지 않음
- `Window` : 자신의 수신 버펴 여유 용랑 크기를 통보하여 얼마만큼의 데이터를 받을 수 있는지 상대방에게 알려주어 흐름제어를 수행하게 되는 필드
- `TCP Flags`
  - U (Urgent) : 긴급 비트, 내가 지금 보내는 데이터가 우선순위가 높음 Urgente Pointer와 세트
  - A (Ack) : 승인 비트, 물어 본거에 대한 응답을 해줄 때 사용
  - P (Push) : 밀어넣기 비트, TCP 버퍼가 일정한 크기 만큼 쌓여야 하는데, 상관없이 데이터를 계속 밀어 넣겠다
  - R (Reset) : 초기화 비트, 상대방과 연결이 되어있는 상태에서 어떤 문제 등이 발생하여 연결 상태를 리셋
  - S (Syn) : 동기화 비트, 상대방과 연결을 시작할때 무조건 사용되는 플레그
  - F (Fin) : 종료비트
- `Urgent Pointer` : 어디서부터 긴급값인지 알려주는 플레그

## 3way-handshake

- TCP통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정 하는 과정
- 양 쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비 되었다는것을 알 수 있도록한다.

![image](https://user-images.githubusercontent.com/71180414/150244452-57f12123-997a-400f-82d7-ad598bf77818.png)
<br>

1. 클라이언트가 서버에 접속을 요청하는 패킷 (SYN)을 보낸다
   - SYN와 ACK응답을 기다리는 SYN_SENT 상태
2. 요청을 받은 서버는 접속을 수락하는 ACK패킷과 이제 접속해 라며 SYN패킷을 보낸다
   - 서버는 클라이언트의 ACK패킷을 기다리는 SYN_RECEIVED 상태
3. 서버로부터 연결 수락과 이제 접속하라고 전달받은 클라이언트는 서버에게 최종적으로 ACK패킷을 보내고 연결을 맺는다
   - 클라이언트와 서버는 ESTABLISHED 상태

## 4way-handshake

- 연결을 해제 하는 과정

![image](https://user-images.githubusercontent.com/71180414/150244473-10f7201f-c744-4109-bd2e-92c769a9c685.png)
<br>

1. 클라이언트가 연결 종료를 알리는 FIN패킷을 보낸다
   - 이때 FIN 패킷에는 ACK 패킷도 실질적으로 포함
2. 서버는 FIN 패킷을 받아 확인했다는 ACK 패킷을 클라이언트에게 보내고 통신이 끝날때까지 TIME_WAIT상태
   서버는 클라이언트에게 응답을 보내고 CLOSE_WAIT 상태
3. 서버에서 통신이 종료됨을 알리기 위해 클라이언트로 FIN 패킷을 보낸후 승인을 기다리는 LAST_ACK 상태
4. 클라이언트에서 FIN 패킷을 받고 확인을 알리는 ACK 패킷을 보낸다

## 흐름 제어

- 전송되는 데이터의 양을 조절하는 흐름제어
- 송신측과 수신 측의 데이터 처리속도가 다를수 있다
- 송신측이 빠르면 수신측 버퍼가 넘치는 오버플로우 문제가 발생
  - 윈도우 크기로 송신측의 데이터 전송량을 조절
- stop and wait
  - 패킷을 정상적으로 수신했다는 응답을 받은 후에만 패킷을 보내는 방식
- sliding window
  - 수신측에서 윈도우 크기를 정하고 윈도우 크기만큼 확인 응답없이 패킷을 전송하는 방식
  - 송신 버퍼 범위는 수신 측의 여유 버퍼에 따라 동적으로 변경

## 혼잡 제어

- 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡 이라고 한다.

- AIMD (Additive Increase / Multiplicative Decrease)
  - 패킷을 하나씩 보내면서 윈도우 크기를 1씩 증가 시키다가 혼잡상태 발생시 윈도우를 반으로 줄인다
  - 초기 전송속도 증가가 더디고, 네트워크가 혼잡 상태가 된후에야 조치를 취한다는 단점
- Slow Start
  - 윈도우 크기를 지수적으로 증가 시키다가 임계점에 도달하면 선형적으로 증가시키고, 혼잡상태 발생시 정책에 따라 윈도우 크기를 감소
  - 혼잡제어 정책에 여러가지 요소 사용
    - Theshold : 윈도우 크기가 지수적으로 증가하는 임계점
    - 3 ACK Duplicate : ACK 패킷이 3번 중복될 경우 윈도우 크기 감소
    - Timeout : 패킷 응답 제한시간이 초과될 경우 윈도우 크기 감소
    - Fast Recovery (빠른 회복) : 혼잡상태 발생후 윈도우 크기가 줄었을경우 윈도우 크기를 빠르게 증가시키는 모드
    - Congestion avoidance (혼잡 회피) : 임계치에 도달하면 윈도우크기를 1씩 증가

## 오류 제어

- TCP는 통신중에 오류가 발생하면 해당 데이터를 재전송한다. 즉 재전송 기반 오류제어 ARQ (Automatic Repeat Request)를 사용
- 오류를 알수 있는 방법
  - 송신측이 ACK를 받지 못함 (송신측이 보낸 데이터가 유실 or 수신측이 보낸 ACK 데이터 유실)
  - 중복된 ACK
  - 수신 측이 NACK(부정응답)를 보냄
- stop and wait
  - ACK를 받고 나서 다음 데이터를 보내는 방식
    - 일정 시간을 지나 timeout이 발생하면 이전 데이터를 재전송
- Go Back N
  - 연속으로 데이터를 보내다가 오류가 발생한 지점부터 재전송하는 방식
  - 성공적으로 전송된 데이터까지 재전송 하기 때문에 조금 비요율적
- Selective Repeat
  - 오류가 발생한 데이터만 재전송 하는 방식
  - 수신측 버퍼의 데이터가 순차적이지 않아서 정렬의 과정이 추가로 필요

## UDP

- User Datagram Protocol
- 비연결형 서비스로 데이터그램 방식을 제공
  - 데이터그램이란 독립적인 관계를 지니는 패킷
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다
- TCP에 비해 속도가 빠르다
- 한두개의 프레임이 유실되도 큰 문제가 없고 빠르게 처리해야하는 실시간 서비스에 사용된다

![TCP VS UDP](https://user-images.githubusercontent.com/76610357/220282807-b3dfa456-de49-4ef9-bc11-af2870122051.png)
