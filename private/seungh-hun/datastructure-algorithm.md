:open_book: Contents
- [Datastructure](#datastructure)
  - [Linear Datastructure](#linear-datastructure)
    - [Array](#array)
    - [Dynamic Array](#dynamic-array)
    - [LinkedList](#linkedlist)
    - [Stack](#stack)
    - [Queue](#queue)
    - [Deque](#deque)
    - [Priority Queue](#priority-queue)
    - [HashTable](#hashtable)
- [Algorithm](#algorithm)
# Datastructure
## Linear Datastructure
### Array
배열은 값 또는 변수 엘리먼트의 집합으로 구성된 구조로, 하나 이상의 인덱스 또는 키로 식별된다.
- 메모리 공간 기반의 연속 방식이다
- 배열의 크기는 고정되어 있으며, 한 번 생성한 배열의 크기를 변경하는 것이 불가능하다
- 어느 위치나 O(1)에 조회할 수 있다
  - 하지만 위치를 모를 경우 O(n)에 조회한다
- 삭제가 일어날 경우 빈공간이 생길 수 있다
  - 빈공간을 없애기위해 값들을 이동하는 추가적인 연산이 필요하다
### Dynamic Array
실제 데이터는 그 크기를 가늠하기 어렵다. 하지만 배열은 크기가 고정되어있다. 이러한 문제를 해결하기 위해 동적배열이 나타났다. 동적 배열은 크기를 지정하지 않고 자동으로 리사이징하는 배열을 의미한다
- 대체로 더블링을 통해 사이즈를 늘린다
  - 파이썬은 1.125배의 그로스 팩터
  - 자바는 1.5배의 그로스 팩터
- 기존 데이터를 복사하는 작업이 필요하다(O(N))
  - 하지만 자주 발생하는 일이 아니므로 분할 상환 분석에 따른 입력 시간은 여전히 O(1)이다
### LinkedList
연결 리스트는 데이터 요소의 선형 집합으로 데이터의 순서가 메모리에 물리적인 순서대로 저장되지 않는다. 새로운 노드를 삽입하거나 삭제하기 간편하고 연결 구조를 통해 물리 메모리를 연속적으로 사용하지 않아도 되기 때문에 관리도 쉽다.

- 특정 인덱스에 접근하기 위해서는 전체를 순서대로 읽어야하므로 O(N)시간이 소요된다
- 시작과 끝 지점에 아이템을 삽입, 삭제하는 연산은 O(1)시간이 소요된다

### Stack
Last-In-First-Out로 처리되는 선형 자료구조이다. 다음과 같은 두 가지 연산을 지원한다
- push(): 요소를 컬렉션에 추가한다
- pop(): 아직 제거되지 않은 가장 최근에 삽입된 요소를 제거한다

꽉 찬 스택에 요소를 삽입하고자 할 때 스택에 요소가 넘쳐서 에러가 발생하는 것을 스택 버퍼 오버플로라고 한다.

### Queue
시퀀스의 한쪽 끝에는 엔티티를 추가하고, 다른 반대쪽 끝에넌 제거할 수 있는 엔티티 컬렉션이다. First-In-First-Out로 처리되는, 줄 서는 것에 비유할 수 있는 자료구조이다. 

### Deque
데크는 Double-Ended Queue의 줄임말고, 글자 그대로 양쪽 끝을 모두 추출할 수 있는 형태의 큐를 의미한다.

### Priority Queue
우선순위 큐는 어떤 특정 조건에 따라 우선순위가 가장 높은 요소가 추출되는 자료형이다.

### HashTable
키-값 형태로 데이터를 저장하는 자료구조이다. 해시 테이블의 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이라는 점이다.

해시 함수를 통해 어떠한 값을 변형시켜 키로 사용하는데 이러한 과정을 해싱이라한다. 하지만 생일 문제나 비둘기집 원리를 보았을 때 해싱은 반드시 충돌을 발생시킨다. 이러한 충돌을 해결하는 방법으로 개별 체이닝과 오픈 어드레싱 방식이있다.

- 개별 체이닝: 충돌이 발생하면 연결 리스트로 값들을 연결하는 방식이다.
  - 모든 해시 충돌이 발생하는 최악의 경우 탐색 시간이 O(n)이 걸린다.
  - 자바 8에서는 연결 리스트 구조를 최적화하여 레드-블랙 트리에 저장하는 형태로 병행해 사용한다

- 오픈 어드레싱: 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식이다
  - 개별 체이닝과 다르게 전체 버킷 이상의 데이터를 저장할 수 없다.
    - 따라서 로드 팩터의 비율을 넘어서게되면 그로스 팩터에 따라 더 큰 크기의 버킷을 생성한 후 새롭게 복사하는 리해싱 작업이 일어난다
  - 원소가 반드시 해싱된 값과 일치하는 곳에 저장된다는 보장이 없다
  - 연속된 데이터 그룹인 클러스터링이 생길 수 있다. 

# Algorithm