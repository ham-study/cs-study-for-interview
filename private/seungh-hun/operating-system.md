# Operating System
:open_book: Contents
- [Operating System](#operating-system)
  - [운영체제란?](#운영체제란)
    - [운영체제의 필요성](#운영체제의-필요성)
    - [운영체제의 역할](#운영체제의-역할)
  - [운영체제 구조](#운영체제-구조)
    - [커널과 인터페이스](#커널과-인터페이스)
    - [시스템 호출과 디바이스 드라이버](#시스템-호출과-디바이스-드라이버)
    - [커널의 구성](#커널의-구성)
    - [가상 머신](#가상-머신)
  - [프로세스의 개요](#프로세스의-개요)
    - [폰 노이만 구조](#폰-노이만-구조)
    - [프로그램과 프로세스](#프로그램과-프로세스)
    - [프로그램에서 프로세스로 전환](#프로그램에서-프로세스로-전환)
    - [프로세스의 상태](#프로세스의-상태)
    - [프로세스 제어 블록](#프로세스-제어-블록)
    - [문맥 교환](#문맥-교환)
    - [프로세스의 구조](#프로세스의-구조)
    - [프로세스의 생성과 복사](#프로세스의-생성과-복사)
    - [프로세스 계층 구조](#프로세스-계층-구조)
  - [스레드](#스레드)
    - [프로세스 VS 스레드](#프로세스-vs-스레드)
    - [멀티 스레드](#멀티-스레드)
    - [멀티 스레드의 장단점](#멀티-스레드의-장단점)
    - [멀티스레드 모델](#멀티스레드-모델)
  - [스케줄링](#스케줄링)
    - [스케줄링 개요](#스케줄링-개요)
    - [스케줄링 단계](#스케줄링-단계)
    - [스케줄링 목적](#스케줄링-목적)
    - [선점형과 비선점형 스케줄링](#선점형과-비선점형-스케줄링)
    - [프로세스의 우선순위](#프로세스의-우선순위)
    - [CPU 집중 프로세스와 입출력 집중 프로세스](#cpu-집중-프로세스와-입출력-집중-프로세스)
    - [전면 프로세스와 후면 프로세스](#전면-프로세스와-후면-프로세스)
    - [다중 큐](#다중-큐)
  - [CPU 스케줄링 알고리즘](#cpu-스케줄링-알고리즘)
    - [FCFS](#fcfs)
    - [SJF](#sjf)
    - [HRN](#hrn)
    - [Round Robin](#round-robin)
    - [Sortest Remaining Time](#sortest-remaining-time)
    - [우선순위](#우선순위)
    - [다단계 큐](#다단계-큐)
    - [다단계 피드백 큐](#다단계-피드백-큐)
  - [인터럽트](#인터럽트)
    - [동기적 인터럽트와 비동기적 인터럽트](#동기적-인터럽트와-비동기적-인터럽트)
    - [인터럽트 처리 과정](#인터럽트-처리-과정)
    - [인터럽트와 이중모드](#인터럽트와-이중모드)
    - [직접 메모리 접근(DMA)](#직접-메모리-접근dma)
    - [메모리 매핑 출력](#메모리-매핑-출력)
    - [사이클 훔치기](#사이클-훔치기)
  - [프로세스 동기화](#프로세스-동기화)
    - [프로세스간 통신](#프로세스간-통신)
    - [공유 자원와 임계 구역](#공유-자원와-임계-구역)
    - [뮤텍스 - 피터슨 알고리즘](#뮤텍스---피터슨-알고리즘)
    - [세마포어](#세마포어)
    - [뮤텍스 VS 세마포어](#뮤텍스-vs-세마포어)
    - [모니터](#모니터)
  - [교착 상태(Dead lock)](#교착-상태dead-lock)
    - [자원 할당 그래프](#자원-할당-그래프)
    - [교착 상태 필요조건](#교착-상태-필요조건)
    - [교착 상태 해결 방법](#교착-상태-해결-방법)
    - [다중 자원에서 교착 상태 검출](#다중-자원에서-교착-상태-검출)
    - [식사하는 철학자 문제](#식사하는-철학자-문제)
  - [메모리 관리](#메모리-관리)
    - [컴파일러와 인터프리터](#컴파일러와-인터프리터)
    - [메모리 관리자의 역할](#메모리-관리자의-역할)
  - [메모리 주소](#메모리-주소)
    - [32bit VS 64bit](#32bit-vs-64bit)
    - [절대 주소와 상대 주소](#절대-주소와-상대-주소)
  - [메모리 할당](#메모리-할당)
    - [단일 프로그래밍 환경](#단일-프로그래밍-환경)
    - [다중 프로그래밍 환경](#다중-프로그래밍-환경)
  
---

## 운영체제란?

운영체제는 사용자에게 편리한 **인터페이스 환경**을 제공하고 **컴퓨터 시스템의 자원을 효율적으로 관리**하는 **소프트웨어**이다.

### 운영체제의 필요성
초기 컴퓨터는 정해진 계산만 수행하면 됐다. 하지만 메모리, CPU의 성능이 향상되고, 여러 작업을 동시에 할 수 있는 컴퓨팅 환경이 조성되면서 사용 규칙이 필요해졌다. 이로 인해 운영체제가 나타났다.

### 운영체제의 역할
1. **자원 관리**
\
운영체제는 한정된 컴퓨팅 자원을 응용 프로그램에게 나누고 회수하며 사용자가 원활하게 작업할 수 있도록 돕는다.

2. **자원 보호**
\
운영체제는 미숙한 사용자나 악의적인 사용자로부터 컴퓨터 자원을 보호한다 

3. **하드웨어 인터페이스 제공**
\
운영체제는 복잡한 과정 없이 다양한 장치를 사용할 수 있도록 해주는 하드웨어 인터페이스를 제공한다. 운영체제는 다양한 장치를 일관된 방법으로 사용할수 있도록 지원하여 사용자는 하드웨어의 구체적인 동작 방식에 대해서 알 필요가 없다. 하드웨어 장치와 상호작용하기 위해 만들어진 컴퓨터 프로그램(하드웨어 인터페이스)을 **드라이버**라고한다.

4. **사용자 인터페이스 제공**
\
사용자 인터페이스는 사용자가 운영체제를 쉽게 사용하도록 지원한다. 운영체제는 사용자에게 GUI를 제공하여 사용자가 쉽게 작업을 수행할 수 있도록 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/147912120-3f760a8e-18c1-44a4-826f-4da45a33d92d.png width=500>
</p>

## 운영체제 구조

### 커널과 인터페이스

운영체제는 커널과 인터페이스로 나눌 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/147912449-12a72bf5-8e90-4ae6-8764-e4182ad1248a.png width=500>
</p>

**커널은** 프로세서 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아놓은 것을 말한다.

**인터페이스는** 커널에 사용자 명령을 전달하고 실행 결과를 사용자에게 알려주는 역할을 한다.

운영체제는 커널과 인터페이스를 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 가진 형태로 제작할 수 있다. 다른 인터페이스를 사용하면 사용자에게 다른 운영체제처럼 느껴질 수 있다.

### 시스템 호출과 디바이스 드라이버

**시스템 호출**은 커널이 제공하는 시스템 관련 서비스를 모아놓은 것이며 함수 형태로 제공된다. 커널은 컴퓨터 자원을 보호하기 위하여 자원에 직접 접근하는 것을 차단한다. 따라서 자원을 이용하기 위해서는 커널이 제공하는 시스템 호출을 사용해야한다.

```txt
API(Application Programming Interface)

응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스이다. 운영체제의 API를 시스템 호출이라할 수 있다.

SDK(System Developer's Kit)

프로그램 개발자를 위해 API 및 API 사용 매뉴얼, 프로그램 개발에 필요한 코드 편집기 같은 각종 개발용 응용 프로그램까지 묶어서 배포하는 개발 툴을 말한다(ex: android studio).

```

**드라이버**는 커널과 하드웨어 사이의 인터페이스이다. 커널이 모든 하드웨어에 맞는 인터페이스를 모두 개발하기 어렵다. 따라서 커널은 입출력의 기본적인 부분만 제작하고 하드웨어 특성을 반영한 소프트웨어를 하드웨어 제작자에게 받아 커널이 실행될 때 함께 실행하도록한다. 이때 하드웨어 제작자가 만든 소프트웨어를 디바이스 드라이버라고한다.

### 커널의 구성

커널은 운영체제의 핵심 기능을 모아놓은 것이다. 커널이 주로 하는 일은 아래와 같다

- 프로세스 관리
- 메모리 관리
- 파일 시스템 관리
- 입출력 관리
- 프로세스간 통신관리

커널은 이러한 기능을 구현하는 방법에 따라 단일형, 계층형, 마이크로 구조 커널로 구분된다.

- 단일형 구조 커널
  - 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성되어있다.
  - 모듈이 거의 분리되어 있지 않아 모듈간 통신 비용이 적다
  - 모듈이 분리되어있지 않아 버그나 오류를 처리하기 어렵다
  - 상호 의존성이 높아 작은 결함이 시스템 전체로 번질 수 있다

- 계층형 구조 커널
  - 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층간 통신을 통해 운영체제를 구현하는 방식이다.
  - 모듈이 계층적으로 분리되어 있어 단일형 보다 오류를 처리하거나 디버깅하기 편리하다

- 마이크로 구조 커널
  - 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공하는 커널
  - 다양한 요구를 수용하기 위해 커널이 방대해짐에 따라 나타난 구조
  - 다른 커널에 비해 운영체제의 많은 부분이 사용자 영역에 구현되어 있다.
  - 각 모듈이 독립적으로 작동하기 때문에 한 모듈의 결함이 전체로 퍼지지 않는다.

### 가상 머신
가상머신은 운영체제와 응용 프로그램 사이에서 작동하는 프로그램으로, 가상머신을 설치하면 응용 프로그램이 모두 동일한 환경에서 작동하는 것처럼 보인다. 자바 가상머신(JVM)이 여기에 해당한다.


## 프로세스의 개요

### 폰 노이만 구조
오늘날의 컴퓨터는 대부분 폰 노이만 구조를 따른다. 폰 노이만 구조란 CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조를 말한다. 폰 노이만 구조가 나오기 전까지는 컴퓨터는 전선을 바꾸며 용도를 변경해야했다. 이러한 문제를 해결하기 위해 폰 노이만이 **메모리를 사용하여 하드웨어는 그대로 두고 프로그램을 바꿔 메모리에 올리는 방식**을 제안했다.

폰 노이만 구조의 가장 큰 특징은 `모든 프로그램은 메모리에 올라와야 실행할 수 있다`는 것이다.

### 프로그램과 프로세스

현대 컴퓨터는 폰 노이만 구조를 가진다. **폰 노이만 구조**에서 프로그램이 실행된다는 것은 해당 코드가 **메모리**에 올라와서 작업이 실행된다는 것이다.

- **프로그램은** 저장장치에 저장되어 있는 정적인 상태
- **프로세스는** 실행을 위해 메모리에 올라온 동적인 상태

### 프로그램에서 프로세스로 전환

프로그램이 **메모리 위에 올라온 동적인 상태를 프로세스**라 한다. 프로그램이 프로세스로 전환되기 위해서는 메모리 위에 올라온 동시에 **프로세스 제어 블록(PCB: Process Control Block)**을 운영체제로 부터 할당 받아야한다.

따라서 다음과 같이 표현할 수 있다
- 프로그램 = 프로세스 - 프로세스 제어 블록
- 프로세스 = 프로그램 + 프로세스 제어 블록
  
프로세스 제어 블록은 프로세스의 작업 지시서와 같은 역할을 한다. PCB에는 프로세스의 다양한 정보가 포함되는데 대표적인 세 가지는 다음과 같다.

- 프로세스 구분자
\
메모리 상에서 프로세스를 구분하기 위한 구분자

- 메모리 관련 정보
\
CPU는 실행하려는 프로세스의 메모리 상의 위치를 알아야 작업이 가능하다. 따라서 PCB에 프로세스의 메모리 위치 정보가 포함된다.

- 중간 값(프로그램 카운터, 레지스터 값)
\
시분할 시스템에서 프로세스가 번갈아가며 실행된다. 따라서 프로세스가 사용했던 각종 중간 값들이 PCB에 저장된다.

프로세스가 종료되면 프로세스가 메모리에서 삭제되고 PCB도 같이 폐기된다. 중요한 점은 컴퓨터 내에는 사용자가 실행한 프로세스만 있는 것이 아니다는 것이다. 운영체제도 프로그램이기 때문에 프로세스 형태로 실행된다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148021164-8af9b9a5-59a9-4776-8eea-578d637c76e7.png width=500>
</p>

### 프로세스의 상태

**프로세스의 간단한 네 가지 상태**

- 생성 상태
\
프로세스가 메모리 위에 올라와 PCB를 할당 받아 실행 준비를 완료한 상태

- 준비 상태
\
생성된 프로세스가 CPU를 할당받아 실행될 때까지 기다리는 상태

- 실행 상태
\
준비 상태의 프로세스가 CPU를 할당 받아 실제 작업을 수행하는 상태. 실행 상태의 프로세스는 일정 시간(타임 퀀텀)동안 CPU를 사용할 권리를 가진다. 만약 작업을 완료하지 못하면 준비 상태를 오가며 작업이 완료될 때까지 실행된다.

- 완료 상태
\
프로세스가 작업을 완료하여 메모리에서 삭제되고 PCB가 폐기된 상태

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148022028-76fca84d-0d53-48da-9461-c65cc6008891.png width=500>
</p>

**프로세스의 다섯 가지 상태**

인터럽트 시스템에서 프로세스가 **입출력**을 요구하면 CPU는 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다. 입출력을 요구한 프로세스는 작업을 진행할 수 없는데, **작업의 효율성**을 높이기 위해서 프로세스를 계속 실행 상태로 두는 것이 아니라 입출력이 완료할 때까지 기다리는 **대기 상태**로 변경한다.

- 생성 상태
\
프로세스가 메모리 위에 올라와 PCB를 할당 받아 실행 준비를 완료한 상태

- 준비 상태
\
생성된 프로세스가 CPU를 할당받아 실행될 때까지 준비 큐에서 기다리는 상태. 실제로 다수의 준비 큐가 존재하며, CPU 스케줄러에 의해서 큐를 몇개 운영할 지, 어떤 프로세스의 작업을 수행할지 결정한다.

- 실행 상태
\
준비 상태의 프로세스가 CPU를 할당 받아 실제 작업을 수행하는 상태. 실행 상태의 프로세스는 일정 시간(타임 퀀텀)동안 CPU를 사용할 권리를 가진다. 만약 작업을 완료하지 못하면 준비 상태를 오가며 작업이 완료될 때까지 실행된다. 
\
\
시간을 다 사용하면 timeout(PID)가 실행되고, 작업이 완료되면 exit(PID)가 실행된다. 실행 상태의 프로세스가 입출력을 요청하면, CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)를 실행하여 프로세스를 대기 상태로 변경한다.


- 대기 상태
\
입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태. CPU는 다른 프로세스를 선정하여 작업을 진행할 수 있다.
\
\
대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다린다. 입출력이 완료되면 인터럽트가 발생하고, 대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데 이것이 wakeup(PID)이다. 그리고 해당 프로세스는 준비 상태로 변경된다.

- 완료 상태
\
프로세스가 작업을 완료하여 메모리에서 삭제되고 PCB가 폐기된 상태. 만약 비정상적으로 종료된 경우 디버깅을 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프라한다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148022485-ec4b3872-f974-4518-9eeb-85868fc6a88d.png width=500>
</p>

**휴식 상태와 보류 상태**

- 휴식 상태
\
프로세스가 작업을 일시적으로 쉬고있는 상태. 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되어 멈춘 지점에서 바로 재시작할 수 있다

- 보류 상태
\
프로세스가 메모리에서 일시적으로 쫓겨난 상태. 보류 상태의 프로세스는 **스왑 영역**에 보관된다. 보류 상태는 다시 대기 상태에서 옮겨진 **보류 대기 상태**, 준비 상태에서 옮겨진 **보류 준비 상태**로 구분된다.보류 대기 상태에서 입출력이 완료되면 보류 준비 상태로 옮겨진다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148023951-5dfbe925-b21a-40a8-9ed8-a5b2d3b360b7.png width=500>
</p>

### 프로세스 제어 블록

**프로세스 제어 블록(PCB: Process Control Block)은** 프로세스를 실행하는데 필요한 중요한 정보를 저장하는 자료구조이다.

프로세스 제어 블록의 구성은 다음과 같다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148029794-b7432a6b-e145-41c3-833e-3a0a9f3656e2.png width=200>
</p>

- 포인터: 포인터를 사용하여 PCB를 연결해 준비 상태나 대기 상태의 큐를 구현한다
- 프로세스 상태
- 프로세스 구분자
- 프로그램 카운터: 다음에 실행될 명령어의 위치를 가리킨다
- 프로세스 우선순위: 대기 큐, 준비 큐에서는 프로세스의 우선 순위에 따라 여러 줄로 서 있다.
- 레지스터 정보: 누산기, 색인 레지스터, 스택 포인터 등
- 메모리 관리 정보: 프로세스의 메모리 상 위치, 메모리 보호를 위한 경계 레지스터 값과 한계 레지스터 값, 세그먼테이션 테이블, 페이지 테이블 정보
- 할당된 자원 정보: 프로세스를 실행하기 위해 사용하는 입출력 자원 등에 대한 정보
- 계정 정보: 계정 번호, CPU 할당 시간, CPU 사용 시간
- 부모, 자식 프로세스 구분자

### 문맥 교환
**문맥 교환**은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이때 두 프로세스 제어 블록의 내용이 변경된다.

**문맥 교환의 절차**

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148030436-75dcaf3d-f669-4f98-bc95-3106e88ba0ad.png width=500>
</p>

1. 인터럽트나 시스템 콜이 발생한 경우 현재 프로세스 P0의 정보를 PCB에 저장한다
2. P0는 준비(대기) 상태로 쫓겨난다
3. P1이 실행 상태로 옮겨진다
4. CPU의 레지스터가 P1의 PCB 값으로 채워지고 작업을 수행한다.


문맥 교환이 일어나는 경우는 다양한데 대표적인 예는 다음과 같다
- 타임 아웃
- 인터럽트
- 주어진 메모리 공간을 벗어난 경우

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148382498-09f637ef-990c-4b15-8578-76df8684c209.png width=700>
</p>

인터럽트나 시스템 콜이 발생했다고 해서 반드시 문맥교환이 발생하는 것은 아니다.

인터럽트나 시스템 콜이 발생하면 사용자 모드에서 커널 모드로 변경되고 운영체제의 제어권이 커널로 넘어가지만, 이를 문맥 교환이라고 하지는 않는다. 커널의 작업이 끝나고 다시 동일한 프로세스의 작업을 수행하는 경우에는 문맥교환이 발생하지 않는 것이다.

만약 타임 아웃이나 시간이 오래 걸리는 입출력 요청이 발생한 경우 커널에게 운영체제의 제어권이 넘어가 커널 작업이 끝나면 다시 사용자 모드로 변경되고 인터럽트 발생 이전과는 다른 프로세스에게 CPU 제어권이 넘어가게 되는데, 이는 문맥교환이 발생한 것이다.

### 프로세스의 구조

프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성된다.

- 코드 영역
\
프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 한다.

- 데이터 영역
\
변수나 파일 등 각종 데이터를 모아놓은 곳이다. 일반 데이터 영역과 힙(Heap) 영역으로 나뉜다

- 스택 영역
\
프로그램이 실행되는데 부수적으로 필요한 데이터를 모아놓은 곳이다. 함수를 수행하고 돌아올 위치 등이 저장된다.

**동적 할당 영역**

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148031737-5ff188d3-24ea-471e-b963-c1213b546648.png width=200>
</p>

코드 영역과 데이터 영역은 프로세스가 실행되기 직전에 위치와 크기가 결정되고 실행되는 동안 변하지 않는 정적 영역이다.

**스택과 힙 영역**은 프로세스가 실행되는 동안 만들어지는 영역으로 크기가 변경되는 **동적인 영역**이다.

- 스택 영역
  - 스레드가 작동하는 동안 추가되거나 삭제되는 동적 할당영역이다
  - 호출한 함수가 종료되면 함수를 호출하기 전 코드로 되돌아올 메모리 주소를 스택에 저장한다
  - 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용한다. 지역 변수가 스택에 저장된다

- 힙 영역
  - 동적으로 할당되는 변수 영역이다.
  - 일부 데이터가 프로그램이 실행되는 동안 할당된다. C 언어의 `malloc()`, 자바의 `new`

### 프로세스의 생성과 복사
사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 PCB를 생성한다. 그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.

**fork()**

실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출이다.
부모-자식 관계가 형성되며 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다. 단 두 프로세스는 독립적이다.


프로세스를 새로 생성하는 것에 비해 fork()가 가진 장점은 다음과 같다

- 프로세스의 생성속도가 빠르다
- 추가 작업 없이 자원을 상속할 수 있다
- 시스템 관리를 효율적으로 할 수 있다

**exec()**

기존의 프로세스를 새로운 프로세스로 전환하는 함수이다. 프로세스의 구조체를 재활용하기 위해 사용한다. 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꿔버린다. 그리고 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다.

### 프로세스 계층 구조

fork()와 exec()를 통해서 프로세스를 계층 구조로 만들 수 있다. 계층 구조의 장점은 다음과 같다.

- 여러 작업 동시 처리
- 용이한 자원 회수

fork()로 생성된 부모-자식 프로세스는 독립적이기 때문에 어떤 프로세스가 먼저 작업이 종료될 지 모른다. 부모 프로세스가 먼저 종료되거나 자식 프로세스가 부모 프로세스와 통신이 안되는 경우를 미아 프로세스(좀비 프로세스)라 한다.

## 스레드
스레드는 프로세스에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행단위이다.

### 프로세스 VS 스레드
개개의 프로세스와 스레드는 서로에게 미치는 영향이 다르다. 프로세스끼리는 서로 약하게 연결되어 있고, 스레드끼리는 서로 강하게 연결되어있다.

**프로세스**

프로세스가 서로 약하게 연결되어 있다는 것은 서로 독립적이라는 것이다. 독립적이기 때문에 서로에게 미치는 영향이 적고 데이터를 주고 받을 때 **프로세스간 통신(IPC: Inter Process Communication)**을 이용한다

**스레드**

스레드는 서로 강하게 연결되어 있다. 따라서 한 스레드의 결함이 전체 스레드에 영향을 미칠 수 있다. 스레드는 변수나 파일 등을 공유하고 전역 변수나 함수 호출등의 방법으로 스레드 간 통신을 한다. CPU와 프로그래밍 기술이 발전하면서 여러 개의 코어를 가진 CPU가 생겨났다. 이러한 상황에서 프로세스에 **하나의 스레드만 존재한다면 여러 코어를 나누어 동시에 작업하는 것이 불가능**하다. 즉, 멀티스레드의 장점을 살릴 수 없다. 오늘 날의 운영체제는 프로세스를 다양한 스레드로 나누어 여러 개의 코어에 배분함으로써 시스템 효율을 높인다.

### 멀티 스레드

초기의 프로그래밍 언어는 순차적으로 실행되기 때문에 프로세스로 여러 적업을 동시에 수행하기 어려웠다. 여러 개의 작업을 동시에 처리하기 위해 fork() 시스템 호출을 통해 부모와 똑같은 자식 프로세스를 생성하고, exec()를 통해 프로세스를 전환했다. 하지만 fork() 시스템 호출은 낭비적인 요소가 많다. 부모 프로세스의 코드 영역과 데이터 영역의 일부가 **메모리에 중복하여 존재**하고, 부모-자식 관계이지만 **서로 독립적인 프로세스여서 낭비 요소를 제거하기 어렵다**. 스레드는 **멀티태스킹의 낭비적인 요소를 줄이기 위해 나타났다**. 비슷한 일을 하는 프로세스를 2개 만드는 대신, **코드나 데이터를 공유하면서 여러 개의 일을 하나의 프로세스 내에서 수행하는 것이다.**

프로세스의 구조는 크게 **동적인 영역과 정적인 영역**으로 나뉜다.
- 정적 영역: 코드, 전역데이터, 파일
- 동적 영역: 레지스터 값, 스택, 힙

fork() 시스템 호출을 사용하면 프로세스의 정적인 영역도 복사된다. 멀티 스레드는 프로세스의 코드, 전역 데이터, 파일, 힙 영역을 공유하여 자원의 낭비를 막는다. 그리고 스택, 프로그램 카운터는 별도로 할당하여 독립적인 실행흐름을 가진다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148177197-0516032f-b48d-4acd-a952-bd5c2631693c.png width=500>
</p>



### 멀티 스레드의 장단점

**장점**
- 응답성 향상
\
한 스레드가 입출력으로 인해 대기 상태로 변경된 경우, 다른 스레드가 작업을 계속하여 사용자의 요구에 빠르게 대응할 수 있다.
- 자원 공유
\
프로세스가 가진 자원을 공유하여 작업을 원할하게 진행할 수 있다.

-효율성 향상
\ 
불필요한 자원의 중복을 막아 시스템의 효율성이 향상된다.

- 다중 CPU 지원
\
2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스 처리 시간이 단축된다.

**단점**
- 모든 스레드가 프로세스의 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다

- 프로세스의 자원을 공유함으로써 동기화 문제가 발생할 수 있다.

### 멀티스레드 모델

**사용자 레벨 스레드**

**운영체제가 멀티스레드를 지원하지 않을 때 사용**하는 방법이다. 사용자 레벨에서 스레드를 구현하기 때문에 관련 **라이브러리**를 사용하여 구현하고, 라이브러리는 커널이 제공하는 스케줄링이나 동기화 같은 기능을 대신 구현해준다. **커널 입장에서 이 스레드는 하나의 프로세스처럼 보인다**.

- 1(커널) to N(사용자) 모델이라고 부른다
- 라이브러리가 직접 스케줄링하고 필요한 정보를 처리하기 때문에 문맥 교환이 필요없다.
- 커널 스레드가 입출력 작업을 위해 대기 상태로 들어가면, 모든 사용자 스레드가 같이 대기하게된다.
- 한 프로세스의 타임 슬라이스를 공유하기 때문에 여러 개의 CPU를 동시에 사용할 수 없다
- 공유 변수 보호 장치를 라이브러리에서 구현하기 때문에 보안에 취약하다

**커널 레벨 스레드**

커널이 멀티 스레드를 지원하는 방식이다.

- 1 to 1 모델이라고 부른다
- 스레드가 독립적으로 스케줄링 되므로 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 계속할 수 있다.
- 커널이 제공하는 보호 기능 등을 사용할 수 있다
- 멀티 CPU를 사용할 수 있다
- 문맥 교환으로인한 오버헤드가 발생한다
  - 커널 입장에서 프로세스와 스레드를 구분하지 않는다. 두가지 모두 그냥 Task로 본다.


**멀티 레벨 스레드**

사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식이다.
- M to N 모델이라 부른
- 하나의 커널 스레드가 대기 상태에 들어가면 다른 커널 스레드가 작업 하여 유연하게 작업을 처리할 수 있다
- 커널 스레드간 문맥교환으로 인해 오버헤드가 발생한다

## 스케줄링
### 스케줄링 개요

**CPU 스케줄링**은 어떤 작업에 CPU를 할당할 지 결정하는 작업이다. CPU 스케줄링이 중요한 이유는 **어떤 프로세스에 CPU를 할당하느냐에 따라서 시스템의 효율을 결정**하기 때문이다.

스케줄링 작업은 CPU 스케줄러가 수행한다. **CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태변화를 조정**한다.

### 스케줄링 단계

- 고수준 스케줄링
  - 장기 스케줄링, 작업 스케줄링이라고도 한다.
  - 시스템 내의 전체 작업 수(프로세스의 수)를 조정하는 역할을 한다.
  - 고수준 스케줄링에 따라서 동시에 실행 가능한 프로세스의 총 개수가 결정된다.
  - time sharing system에서 고수준 스케줄링은 없다

- 저수준 스케줄링
  - 단기 스케줄링이라고도 부른다.
  - 가장 작은 단위의 스케줄링이 수행된다.
  - CPU를 할당할 프로세스를 결정한다.
  - 대기 상태로 보낼 프로세스를 결정한다.
   
- 중간 수준 스케줄링
  - 고수준과 저수준 스케줄링 사이에서 일어나는 스케줄링이다.
  - 중지(Suspend)와 활성화(Active)로 전체 시스템에 활성화된 프로세스 수를 조절하여 과부하를 막는다
  - 프로세스를 보류 상태로 이동시킨다.
  - 시스템에서 Active한 프로세스의 수를 결정한다

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148339221-4e4cab80-2308-4229-bc5a-914de088d4a9.png width=700>
</p>

### 스케줄링 목적
- 공평성
- 효율성
- 안정성
- 확장성
- 반응 시간 보장
- 무한 연기 방지

### 선점형과 비선점형 스케줄링

- 선점형 스케줄링: 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
  - 대표적인 선점형 스케줄링은 인터럽트 처리
    - 인터럽트가 발생하면 커널을 깨워서 인터럽트를 처리하고 다시 원래 작업으로 돌아간다.
  - 문맥 교환과 같은 부가적인 작업으로 인한 오버헤드가 발생할 수 있다
  - 한 프로세스가 CPU를 독점할 수 없기 때문에 대화형, 시분할 시스템에 적절하다.
  - 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용한다


- 비선점형 스케줄링: 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
  - 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기까지 계속 실행된다
  - 선점형 보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적다
  - 전체 시스템의 효율이 떨어질 수 있다
  - 일괄 처리 시스템에서 적절하다

선점형 스케줄링 방식을 쓰더라도 비선점 프로세스가 존재할 수 있다. 예를 들어 시스템을 백업하는 프로세스는 비선점형으로 동작한다.

### 프로세스의 우선순위
대부분의 CPU 스케줄러는 프로세스마다 우선순위를 부여한다. 중요한 프로세스를 더 빨리, 더 자주 실행해야하기 때문이다.

따라서 커널 프로세스는 일반 프로세스보다 우선 순위가 더 높다.


### CPU 집중 프로세스와 입출력 집중 프로세스

- CPU 집중 프로세스
  - 수학 연산과 같이 CPU를 많이 사용하는 프로세스
  - CPU 버스트가 많은 프로세스

- 입출력 집중 프로세스
  - 저장 장치에서 데이터를 읽거나 쓰는 작업이 많은 프로세스
  - 입출력 버스트가 많은 프로세스

CPU 집중 프로세스와 입출력 집중 프로세스 중 입출력 집중 프로세스를 먼저 실행 시키는 것이 더 효율적이다. 입출력 집중 프로세스는 대기 상태로 옮겨져 CPU가 다른 프로세스의 작업을 수행할 수 있기 때문이다.

### 전면 프로세스와 후면 프로세스

- 전면 프로세스
  - GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
  - 현재 입력과 출력을 사용하는 프로세스
  - 사용자와 상호 작용이 가능하다

- 후면 프로세스
  - 사용자와 상호작용이 없는 프로세스

### 다중 큐

**준비 상태 다중 큐**

프로세스마다 중요도는 다르고 PCB에 그 중요도가 저장된다. CPU 스케줄러는 준비 상태의 프로세스 중 가장 높은 우선순위를 가진 프로세스를 선정해서 CPU를 할당한다. 매번 프로세스를 모두 탐색하는 것은 번거롭기 때문에 **우선순위에 따른 다중 큐**를 사용한다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148342146-dfc86a17-da32-44ad-b428-d00a1c8c748a.png 700>
</p>
 
준비 큐를 몇 개로 나눌 지, 어떤 프로세스에 CPU를 할당할 지는 스케줄링 알고리즘에 따라 달라진다.

프로세스의 우선순위를 배정하는 방식에는 고정 우선순위 방식, 변동 우선순위 방식이있다.

- 고정 우선순위
  - 운영체제가 프로세스에 우선순위를 부여한 후 변동되지 않는 방식
  - 구현은 쉽지만, 시스템의 변화에 대응하기 어렵다

- 변동 우선순위
  - 프로세스 작업 중간에 우선순위가 변경되는 방식
  - 구현하기 어렵지만, 시스템의 효율성을 높일 수 있다

우선순위가 낮은 P1프로세스가 중요한 자원을 독점하고 있다면, 이 자원을 사용하려는 다른 중요한 프로세스들은 P1의 작이 마칠때까지 대기해야한다. 하지만 P1의 우선순위를 높여 빨리 작업을 끝내게 하면 다른 중요한 프로세스가 자원을 얻어 작업을 진행할 수 있다.

낮은 우선순위의 프로세스를 높은 우선순위로 변경하는 방식을 반전 우선순위(우선순위 역전)이라 한다.

\
**대기 상태 다중 큐**

시스템 내에는 다양한 입출력 장치가 있다. 입출력이 완료된 경우 대기 상태의 모든 프로세스를 탐색하는 것은 번거롭기 때문에 시스템의 효율을 위해서 같은 입출력을 요구한 프로세스를 모아둔다.

**준비 큐는 한 번에 하나의 프로세스**를 꺼내어 CPU를 할당하는 반면, **대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮긴다**.

시스템에는 많은 입출력 시스템이 있기 때문인데, 동시에 끝나는 인터럽트 처리를 위해 **인터럽트 벡터**라는 자료 구조를 사용한다. 인터럽트 벡터에는 동시에 완료된 입출력 정보와 처리 방법이 담겨있는데, 이 정보에 따라 완료된 프로세스 제어 블록은 모두 준비 상태로 이동한다.


## CPU 스케줄링 알고리즘

- 비선점형 알고리즘: FCFS, SJF, HRN
- 선점형 알고리즘: Round Robin(RR), SRT, 다단계 큐, 다단계 피드백 큐
- 둘 다 가능: 우선순위 큐


### FCFS
First Come First Serve 스케줄링은 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 알고리즘이다. 초기 일괄처리 시스템에서 사용되었으며 큐가 하나라 모든 프로세스의 우선순위가 동일하다.

처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어질 수 있다. 이러한 현상을 **콘보이(Convoy) 혹은 호위 효과**라고한다.

### SJF
Shortest Job First 스케줄링은 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링이다. SJF가 나타난 배경에는 FCFS의 콘보이 효과를 완화하기 위함이 있다.

SJF는 작업 시간이 적은 프로세스를 먼저 실행하기 때문에 시스템의 효율은 높아질 수 있다. 하지만 다음과 같은 문제로 실질적으로 사용하기 어렵다

- 운영체제가 프로세스의 종료 시간을 정확하게 예측할 수 없다.
  - 현대 프로세스는 사용자와 상호작용이 빈번하기 때문에 프로그램 종료 시간을 파악하기 어렵다.
- 공평하지 못하다
  - 작업 시간이 긴 프로세스가 준비 큐에 위치할 경우 작업이 계속 연기될 수 있어 **아사(Starvation) 현상**이 발생할 수 있다.

두 가지 문제의 해결책과 그 한계는 다음과 같다
- 프로세스가 자신의 작업 시간을 운영체제에게 알려준다
  - 프로세스가 자신의 작업 시간을 정확히 알기 어렵고, 악의적인 프로세스가 작업 시간을 속인다면 시스템의 효율성이 나빠질 수 있다.
- 에이징
  - 에이징은 프로세스가 양보할 수 있는 상한선을 정하는 것이다.
  - 에이징 값을 어떤 기준으로 정할지 자체가 문제가 된다는 한계가 있다.

### HRN
Highest Response Ratio Next 스케줄링은 SJF에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘이다. 서비스를 받기 위한 대기 시간과 CPU 사용 시간을 고려하여 우선순위를 결정한다

```text
우선순위 = (대기시간 + CPU 사용시간) / CPU 사용시간
```

HRN 알고리즘은 대기 시간이 긴 프로세스의 우선순위를 높여 아사 현상을 완화할 수 있지만, 여전히 공평성이 위배될 수 있다.

### Round Robin
Round Robin(RR) 스케줄링은 한 프로세스가 할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식이다.

FCFS 방식과 유사하지만 가장 큰 차이점은 선점이 가능하고 타임 슬라이스가 존재한다는 것이다. 타임 슬라이스를 모두 사용한 프로세스는 강제로 준비 큐 맨 뒤로 이동하기 때문에 콘보이 효과를 완화한다.

**타임 슬라이스 크기와 문맥교환**
타임 슬라이스의 크기는 프로세스의 반응 시간뿐 아니라 시스템 전체 성능에 영향을 미칠 수 있다.

- 타임 슬라이스가 큰 경우
\
타임 슬라이스가 너무 큰 경우 FCFS와 크게 다를 것 없이 동작한다. 응답성이 하락한다.

- 타임 슬라이스가 작은 경우
\
타임 슬라이스가 너무 작은 경우 시스템 전체 성능이 떨어질 수 있다. 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업은 하지 못하는 문제가 발생한다.

### Sortest Remaining Time
Sortest Remaining Time(SRT) 스케줄링은 SJF와 라운드 로빈 스케줄링을 혼합한 방식이다. 쉽게 말하면 SJF의 선점형 방식이다.

현재 실행 중인 **프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산**해야하고, 남은 시간이 더 적은 프로세스와 **문맥 교환**해야 하므로 SJF에는 없는 작업이 추가된다. SJF와 마찬가지로 **프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 발생**할 수 있다.

### 우선순위
프로세스는 중요도에 따라 우선순위를 가지는데, 이러한 우선순위를 반영한 스케줄링 방식이 우선순위 스케줄링이다. 선점형과 비선점형 스케줄링 방식에 모두 적용이 가능하다.

우선순위 스케줄링은 고정 우선순위 알고리즘과 변동 우선순위 알고리즘으로 나뉜다.

- 고정 우선순위 알고리즘
\
한 번 우선순위를 부여 받으면 종료될 때까지 우선수위가 고정된다. 구현이 단순하지만 변하는 시스템 상황을 반영하지  못한다

- 변동 우선순위 알고리즘
\
일정 시간마다 우선순위가 변한다. 일정 시간마다 우선 순위를 변경하기 때문에 구현이 복잡하지만, 시스템의 상황을 반영하여 효율적으로 운영이 가능하다.

예를 들어, 우선순위가 낮은 프로세스 A가 다른 중요한 프로세스가 사용할 자원을 독점하고 있을 때, 프로세스 A의 우선순위를 높여 먼저 실행되도록하여 중요 자원을 반환하도록 할 수 있다. 이를 우선순위 역전이라한다.

우선순위가 높은 프로세스에 CPU를 먼저 할당하므로 **공평성을 위배**하고 아사 현상을 일으킬 수 있다. 하지만 **중요도가 높은 프로세스를 먼저 실행**할 수 있으므로 시스템이 안정적으로 운영될 수 있다.

### 다단계 큐

우선순위에 따라 준비 큐를 여러개 사용하는 스케줄링이다. 우선순위에 따라 큐가 다단계로 나누어져 있다. 우선순위는 고정형 우선순위를 사용하고, 상단 큐에 있는 모든 프로세스의 작업이 끝나야 다음 큐에 위치한 프로세스의 작업을 수행한다.

- 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식이다.
- 우선순위에 따라 타임 슬라이스를 조절하여 시스템을 효율적으로 운영할 수 있다

하지만 우선순위가 낮은 프로세스는 작업이 연기될 수 있다. 이러한 문제점을 해결하기 위해 다단계 피드백 큐 스케줄링이 나타났다.

### 다단계 피드백 큐

다단계 피드백 큐는 다단계 큐 스케줄링과 동일하게 우선순위에 따른 여러 큐를 가진다. 하지만 다단계 피드백 큐는 프로세스가 CPU를 사용하고 난 후 프로세스의 우선순위가 낮아지는 변동형 우선순위 방식을 사용한다.

우선순위에 따라 타임 슬라이스의 크기를 다르게 하여, 우선순위가 낮은 프로세스가 좀 더 오랫동안 CPU를 사용할 수 있도록 보장한다. 마지막 큐는 FCFS와 동일하게 동작한다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148675467-2d81807f-bbad-4bc7-b17f-92927f97d21a.png width=700>
</p>

프로세스가 타임 슬라이스를 모두 소진한 경우 우선순위가 낮은 큐로 이동하고, 모두 사용하지 못한 경우 원래 큐로 이동한다.

CPU 버스트가 큰 프로세스는 타임 슬라이스를 모두 소진할 확률이 높다. 따라서 타임 슬라이스를 모두 소진한 프로세스의 우선순위를 낮추고 타임 슬라이스를 크게하여 작업 시간을 보장한다. 

입출력 버스트가 큰 프로세스는 타임 슬라이스를 모두 소진하지 않을 확률이 높다. 따라서 계속 동일한 우선순위로 동작하여 사용자와의 응답성을 높일 수 있다.

하지만 여전히 우선순위가 낮은 프로세스의 작업이 지연될 수 있는데, 우선순위 역전이나 에이징 기법을 사용할 수 있다.

## 인터럽트
입출력 관리자가 입출력 작업을 완료한 뒤 이벤트를 발생시켜 운영체제에게 알려주는데 이를 인터럽트라고 한다.

과거에는 컴퓨터의 입출력 장치가 많지 않았기 떄문에 운영체제가 주기적으로 입출력 장치를 직접 확인해서 처리했다. 이러한 방식을 폴링이라 한다. 하지만 최근 컴퓨터는 수 많은 입출력 장치를 가지고 있기 때문에 이러한 방식은 비효율적이다.

### 동기적 인터럽트와 비동기적 인터럽트

인터럽트는 입출력에 국한된 개념은 아니고 광범위하게 사용된다. 프로세스가 실행 중인 **명령어로 인해 발생하는 인터럽트를 동기적 인터럽트**라 한다. 그리고 실행 중인 명령어와 무관하게 발생하는 인터럽트를 **비동기적 인터럽트**라 한다.

- 동기적 인터럽트
  - 프로그램상 문제때문에 발생하는 인터럽트
    - 오버플로, 언더플로
    - 작업 중단 인터럽트(Ctrl + c)
    - 산술 연산 중에 발생하는 인터럽트(0으로 나누는 행위)

- 비동기적 인터럽트
  - 하드디스크 읽기 오류나 메모리 불량과 같은 하드웨어적인 오류
  - 키보드, 마우스와 같은 사용자 입력에 의한 인터럽트

### 인터럽트 처리 과정

운영체제에는 인터럽트에 대한 처리 행위가 미리 정의 되어있다. 인터럽트 번호와 그 번호에 붙어 있는 함수의 쌍으로 이루어져있다. 윈도우에서는 인터럽트 번호를 IRQ(Interrupt ReQuest lines)라 한다.

그리고 인터럽트는 한 번에 하나씩 발생하는 것이 아니라 한 순간에 여러개가 동시에 발생할 수 있다. 이렇게 동시에 발생하는 인터럽트를 하나로 묶어서 처리하는 개념이 **인터럽트 벡터**이다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148740366-6283f4c5-ac54-4d05-b2c1-7e51deb7e725.jpg width=700>
</p>

**인터럽트 벡터**에는 각 인터럽트를 처리하는 함수가 연결되어있다. 이 함수를 인터럽트 핸들러라고 한다. 인터럽트 처리 과정을 정리하면 아래와 같다

1. 인터럽트가 발생하면 현재 실행 중인 프로세스는 일시 중지 되며, 재시작으로 위해 프로세스 관련 정보가 임시저장된다.
2. 인터럽트 컨트롤러가 실행되어 인터럽트 처리 순서를 결정한다. 이때 여러 개의 인터럽트가 동시에 발생했다면 인터럽트의 우선순위를 고려하여 중요한 인터럽트를 먼저 처리한다.
3. 처리할 인터럽트를 선정한 후 인터럽트 벡터에 등록된 인터럽트 핸들러가 실행된다.
4. 인터럽트 벡터에 연결된 핸들러가 인터럽트 처리를 마치면 일시 정지된 프로세스가 재실행되거나 종료된다.

### 인터럽트와 이중모드
이중모드는 커널이 스스로를 보호하기 위한 기법으로 사용자 모드와 커널 모드로 나누어 작업을 수행하는 것을 말한다. 사용자 모드는 사용자 프로세스가 실행되는 상태를 말하고, 커널 모드는 운영체제와 관련된 커널 프로세스가 실행되는 상태를 말한다.

사용자 모드에서는 입출력 같은 특권 명령을 수행하지 못한다. 따라서 커널이 제공하는 시스템 호출을 통해서 커널 모드로 전환된 후 커널이 특권 명령을 수행한다.

사용자가 커널 모드로 전환하는 경우는 첫 째 시스템 호출을 사용한 경우 둘 째 인터럽트를 발생시킨 경우다.

시스템 호출을 사용해 커널 모드로 진입하는 것은 자발적이지만, 인터럽트로 인해 커널 모드로 진입하는 것은 비자발적이다.

### 직접 메모리 접근(DMA)

입출력 관리자가 CPU의 허가 없이 메모리에 접근할 수 있는 권한을 직접 메모리 접근이라 한다.

폴링 방식에서 메모리는 CPU만 접근이 가능했다. 하지만 인터럽트 방식을 사용하면 명령을 받은 입출력 관리자는 CPU가 요청한 데이터를 메모리에 가져다 놓아야 한다. 하지만 메모리는 CPU만 접근 가능한 경우 CPU의 허가를 받아야 하므로 시스템의 효율이 떨어진다.

따라서 입출력 관리자는 CPU의 허가 없이 직접 메모리에 접근하는 권한이 필요한데 이러한 권한을 직접 메모리 접근이라한다.

### 메모리 매핑 출력

메모리의 일정 공간을 입출력에 할당하는 기법을 메모리 매핑 입출력이라고 한다.

DMA로 인해 메모리에는 CPU가 사용하는 데이터와 입출력 장치가 사용하는 데이터가 혼재될 수 있다. 이로 인해 메모리 관리가 어려워질 수 있기 때문에 CPU가 직접 사용하는 메모리 공간과 직접 메모리 접근을 통해 들어오거나 나가는 공간을 분리해야 한다.

### 사이클 훔치기
CPU와 입출력 장치가 동시에 메모리에 접근했을 때 CPU가 메모리 사용권한을 양보하는데 이를 사이클 훔치기라고 한다.

CPU 입장에서는 직접 메모리 접근이 사이클(순서)를 훔쳐 간 것이기 때문에 이렇게 부른다.

## 프로세스 동기화
### 프로세스간 통신

- 프로세스 내부 데이터 통신: 하나의 프로세스내에 2개 이상의 스레드가 존재하는 경우의 통신.
  - 전역 변수나 파일을 사용하여 통신한다
- 프로세스 간 데이터 통신: 같은 컴퓨터에 있는 여러 프로세스끼리의 통신.
  - 공용 파일 혹은 파이프를 사용하여 통신
- 네트워크를 이용한 통신: 여러 컴퓨터가 네트워크로 연결되어 있을 있을 때의 통신.
  - 소켓, 원격 프로시저 호출을 사용하여 통신

**통신 방향에 따른 분류**

- 양방향 통신: 데이터를 양쪽 방향으로 전송할 수 있는 구조
  - 일반적인 통신은 대부분 양방향 통신
  - 소켓 통신
- 반양방향 통신: 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조
  - 무전기
- 단뱡향 통신: 한쪽 방향으로만 데이터를 전송할 수 있는 구조.
  - 전역 변수, 파이프

**통신 구현 방식에 따른 분류**
- 대기가 있는 통신: 동기화를 지원하는 통신 방식. 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기상태에 머물러 있다.
  - 파이프, 소켓
- 대기가 없는 통신: 동기화를 지원하지 않는 통신 방식. 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인 
  - 전역 변수, 파일

부모-자식 관계로 연결되어 있는 프로세스끼리는 전역 변수, 파일, 이름 없는 파이프 등일 이용하여 통신한다. 서로 독립적인 프로세스끼리는 이름 있는 파이프를 사용한다. 서로 다른 시스템에 있는 프로세스끼리는 소켓을 이용하여 통신한다.

### 공유 자원와 임계 구역

프로세스는 독립적인 메모리 공간을 가지기 때문에 임계 구역 문제가 발생하지 않는다고 생각할 수 있다. 하지만 운영체제가 접근하는 순간 문제가 발생할 수 있다.

1. kernel 수행 중 인터럽트 발생
     - 인터럽트 처리 중 다른 인터럽트 발생
     - 인터럽트 처리 중에 이후에 발생한 인터럽트를 일단 disable해서 해결
2. 프로세스가 시스템 콜을 호출하여 커널모드로 작업 수행 중에 문맥교환이 발생
     - 커널모드에서 CPU를 선점할 수 없게한다
3. 멀티 프로세서에서 공유 메모리 내의 커널 데이터
    - 공유 데이터에 대한 lock/unlock


**공유 자원**

여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다. 공유 자원은 공동으로 사용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있다.

두 개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 **경쟁 조건(Race Condition)**이 발생했다고 한다.

**임계 구역**

공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 **임계구역**이라한다.

임계구역과 관련된 전통적인 문제로 **생산자-소비자 문제**가 있다. 생산자가 데이터를 생성하여 넣고, 소비자는 버퍼에 있는 데이터를 사용한다. 그리고 버퍼의 상태를 알기 위해서 `sum`이라는 변수를 사용하는데, 생산자와 소비자가 sum에 동시에 접근하면 문제가 발생할 수 있다.

생산자와 소비자가 작업 후 sum의 값을 변경하지 못했을 경우 sum에 대한 연산이 동시에 발생하여 엉뚱한 값을 읽어 작업을 수행할 수 있다.


임계구역을 해결하기 위한 조건은 다음과 같다
- 상호배제
  - 한 프로세스가 임계구역에 진입하면 다른 프로세스는 진입할 수 없다
- 한정대기
  - 어떤 프로세스도 무한 대기하지 말아야한다.
- 진행의 융통성
  - 한 프로세스가 다른 프로세스의 진입을 방해해선 안된다.

### 뮤텍스 - 피터슨 알고리즘
뮤텍스는 상호배제의 줄임말이다. lock/unlock을 사용하여 임계 구역에 단 하나의 프로세스만 접근하도록한다.

lock을 얻은 프로세스가 임계 구역에 진입해서 작업을 수행하고 lock을 놓으면 대기하고 있던 다른 프로세스가 lock을 가지고 다시 임계구역으로 진입한다.

뮤텍스가 반드시 바쁜 대기로 구현되는 것은 아니다. 아래 알고리즘은 뮤텍스 알고리즘 중 하나은 피터슨 알고리즘이다.


<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148937608-8b7cfb0b-4b7e-41a4-9777-5d71374406b3.png width=700>
</p>

`turn`은 두 프로세스가 lock(위 코드에서 flag)을 설정하여 임계구역에 못 들어가는 상황을 방지하기 위해 사용한다.

피터슨 알고리즘은 임계구역 해결 세 가지 조건을 모두 만족하지만 두 프로세스만 사용가능하다는 단점이 있다. 사실 하드웨어의 지원을 받지 못하면 애플리케이션 레벨에서 구현 해도 임계 구역을 해결할 수 없다.

### 세마포어

피터슨 알고리즘은 임계구역을 해결하기 위해 바쁜 대기를 사용한다. 바쁜 대기를 사용할 경우 자원이 낭비 될 수 있는데 세마포어를 통해 이를 해결할 수 있다.

세마포어는 공유 가능한 자원의 수(N)를 설정하고 그 수 만큼 프로세스들이 임계 구역에 진입할 수 있다.

- Semaphore(n): 현재 사용 가능한 자원의 수를 n으로 초기화
- P(): 잠금을 수행하는 코드. 0 보다 크면 1 감소 후 프로세스 진입. 0 보다 작으면 대기
- V(): 잠금 해제와 동기화를 같이 수행하는 코드. 값을 1 증가시키고 대기 중인 프로세스에게 진입 해도 좋다는 신호를 보낸다.

### 뮤텍스 VS 세마포어
- 뮤텍스는 동기화 대상이 하나, 세마포어는 동기화 대상이 하나 이상일 때 사용가능하다
- 세마포어는 뮤텍스가 될 수 있다(바이너리 세마포어). 하지만 뮤텍스는 세마포어가 될 수 없다
- 세마포어는 소유할 수 없다. 뮤텍스틑 lock을 가진 프로세스가 lock을 해제한다


### 모니터
세마포어의 가장 큰 문제점은 잘못된 사용으로 인해 임계구역이 보호 받지 못할 수 있다는 것이다.

```txt

임계구역

```

세마포어를 사용하지 않을 수도 있고

```txt
P()
임계구역
P()
```
P()를 두 번 사용할 수도 있고
```txt
V()
임계구역
P()
```
P()와 V()의 호출 순서가 바뀔 수 도 있다.


모니터는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스간 동기화 시킨다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148949345-4e430e9f-0395-4f73-b150-0b569cc85fc9.png width=700>
</p>

1. 임계구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직접 P()나 V()를 호출하지 않고 모니터에 작업을 요청한다.
2. 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 프로세스에 알려준다.


모니터는 임계구역 보호와 동기화를 위해 내부적으로 상태 변수를 사용한다. 상태 변수 기능에는 wait()와 signal()이 있다.

- wait(): 모니켜 큐에서 자신의 차례가 올 때까지 기다린다
- signal(): 모니터 큐에서 기다리는 다음 프로세스에게 순서를 넘겨준다.

## 교착 상태(Dead lock)
2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만을 기다리며 작업을 더 이상 진행하지 않는 상태를 교착 상태라고 한다.

아사 현상과는 다르다. 아사 현상은 운영체제의 잘못된 정책으로 프로세스의 작업이 지연되는 문제이고, 교착 상태는 여로 프로세스가 작업을 진행하다 보니 자연스럽게 나타나는 현상이다.

컴퓨터 시스템에서 교착 상태는 시스템 자원, 공유 변수(파일), 응용 프로그램 등을 사용하며 발생할 수 있다.
- 시스템 자원: 프린터처럼 동시에 같이 사용할 수 없는 시스템 자원을 할당 받은 후 양보하지 않는 경우
- 공유 변수: 한 변수를 할당 받은 상태에서 다른 변수를 기다리면 교착 상태 발생 가능
- 응용 프로그램: 데이터베이스는 데이터의 일관성을 위해 잠금을 사용하는데 이때 교착 상태 발생 가능

### 자원 할당 그래프
자원 할당 그래프는 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지 방향성이 있는 그래프로 표현한 것이다.
<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/149086133-78b80cb7-1926-4e97-a5a3-c371342a0513.png>
</p>

프로세스는 원으로, 자원은 사각형으로 표현한다.

### 교착 상태 필요조건

- 상호배제: 한 프로세스가 사용하는 자원은 다른 프로세스가 사용할 수 없는 배타적 자원이다.
- 점유대기: 프로세스가 어떤 자원을 할당 받은 상태에서 다른 자원을 기다리는 상태이다.
- 원형대기: 점유와 대기를 하는 프로세스의 관계가 원형을 이루어야 한다.
- 비선점: 한 프로세스가 사용 중인 자원은 다른 프로세스가 빼앗을 수 없는 비선점 자원이다.

### 교착 상태 해결 방법

- 예방: 교착 상태를 유발하는 네 가지 조건을 무력화한다.
  - 교착 상태는 네 가지 조건 모두 충족해야 발생한다. 따라서 네 가지 중 하나만 무력화 하면된다.
  - 실효성이 적어 잘 사용하지 않는다.
- 회피: 교착 상태가 발생하지 않는 수준으로 자원을 할당한다.
  - 자원을 얼마만큼 할당해야 교착 상태가 발생하지 않는다는 보장이 없기 때문에 실효성이 적다.
- 검출: 자원 할당 그래프를 사용하여 교착 상태를 발견한다.
  - 교착 상태가 발생하면 교착 상태 회복이 진행된다.
- 회복: 교착 상태를 발견한 후 해결한다.
  - 검출과 회복이 현실적인 접근 방법이다.

**교착 상태 예방**

- 상호 배제 예방: 독점적으로 사용할 수 있는 자원을 없애는 방법이다. 
  - 현실적으로 시스템의 모든 자원을 공유할 수 없다. 
  - 임계구역이 보장 받지 못하면 작업의 결과가 달라질 수 있다.
- 비선점 예방: 모든 자원을 빼앗을 수 있도록 한다.
  - 임계구역을 보호하기 위해 잠금을 사용하면 자원을 빼앗을 수 없을 뿐 아니라 상호 배제도 보장할 수 없다.
  - 우선순위가 높은 프로세스가 우선 순위가 낮은 프로세스의 자원을 빼앗을 수 있다면 아사 현상이 발생할 수 있다.
  - 에이징을 적용하더라도 결국에 마지막에는 비선점 자원이 되어 교착 상태가 발생할 수 있다.
- 점유와 대기 예방: 프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법이다.
  - 전부 할당하거나 아니면 아예 할당하지 않는 방법을 사용한다
  - 프로세스의 자원 사용 방식을 변화 시켜 교착 상태를 해결하는 방법이다.
  - 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다
  - 자원의 활용성이 떨어진다
  - 많은 자원을 사용하는 프로세스가 비교적 적은 자원을 필요하는 프로세스보다 불리하다
  - 결구 일괄 작업 방식으로 동작한다
    - 대부분의 프로세스가 필요로 하는 자원이 있는 경우(키보드, 마우스), 자원을 획득한 프로세스의 작업이 끝나아 다음 프로세스의 작업이 실행된다.
- 원형 대기 예방: 점유와 대기를 하는 프로세스들이 원형을 이루지 못하게 하는 방법이다.
  - 모든 자원에 숫자를 부여하고 숫자가 큰 방향으로만 자원을 할당한다
  - 숫자가 큰 자원을 점유하고 있는 프로세스가 숫자가 작은 자원을 요청할 경우 거부되고 가지고 있던 자원을 반환한다.
  - 프로세스 작업 진행에 유연성이 떨어진다
  - 자원의 번호를 어떻게 부여할 지 문제가 된다.

교착 상태 예방은 실질적으로 구현하기 매우 어렵고, 프로세스의 작업 방식을 제한하고 자원을 낭비하기 때문에 사용되지 않는다.

**교착 상태 회피**

프로세스에 자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는 지 파악하여 그 수준 이하로 나누어 주는 방법이다. 시스템의 운영 방식에 변겨을 가하지 않기 때문에 예방 보다는 좀 더 유연하다.


자원의 총 수와 현재 할당된 자원의 수를 기준으로 **안정 상태와 불안정 상태**로 나누고 시스템이 안정 상태를 유지하도록 자원을 할당한다. **불안정 상태에서 항상 교착 상태가 발생하는 것은 아니다**. 불안정 상태가 커질 수록 교착 상태가 발생할 가능성이 높아질 뿐이다.

- 은행원 알고리즘: 교착 상태 회피를 구현한 알고리즘이다. 최악의 경우를 기준으로 함으로써 문제 상황을 철저히 회피하여 교착상태를 막는다.
  - 자원을 다음과 같이 나눈다
    - 전체 자원(Total)
    - 가용 자원(Available)
    - 최대 자원(Max)
    - 할당 자원(Allocation)
    - 기대 자원(Expect)
  - 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크면 자원을 할당한다.
    - 가용 자원이 크지 않으면 할당하지 않는다.

교착 상태 회피의 문제점은 다음과 같다
- 프로세스가 자신이 사용할 모든 자원을 미리 선언해야한다
- 시스템의 전체 자원 수가 고정적이다.
  - 현실적으로 시스템의 전체 자원 수는 유동적이다
- 자원이 낭비된다
  - 모든 불안정 상태가 교착 상태가 되는 것이 아닌데 자원을 할당하지 않는 것은 자원의 낭비이다.

**교착 상태 검출**

예방은 현실적으로 불가능하고, 회피는 자원의 낭비가 심하다. 현실적으로 가장 적합한 것은 교착 상태를 검출하고 회복하는 것이다.

- 타임 아웃을 사용한 검출: 일정 시간 동안 작업이 진행되지 않는 프로세스를 교착 상태가 발생한 것으로 간주한다
  - 타임 아웃 시간 동안 작업을 수행하지 않는다고 반드시 교착 상태가 발생한 것은 아니다
  - 분산 시스템의 경우 적용이 어렵다. 프로세스의 응답이 없는 것이 교착 상태 때문인지, 네트워크 문제인지 알 수 없기 때문이다
  - 데이터베이스에서는 타임 아웃으로 교착 상태가 발생하면 설정한 체크 포인트로 롤백한다

- 자원 할당 그래프를 사용한 검출
  - 단일 자원의 경우 그래프에 사이클이 있으면 교착상태이다.
  - 다중 자원을 사용하는 경우 사이클이 있다고 반드시 교착상태인 것은 아니다
  - 프로세스의 작업 방식을 제한하지 않으면서 교착 상태를 정확하게 파악할 수 있다
  - 오버헤드가 크다

자원 할당 그래프를 사용할 경우 교착 상태를 정확하 파악할 수 있지만 작업이 너무 많아 오버헤드가 크다. 따라서 타임 아웃도 자주 사용한다. 타임 아웃을 사용한 검출을 '가벼운 교착 상태 검출'이라 하고, 자원 할당 그래프를 사용하는 것은 '무거운 교착 상태 검출'이라 한다.

**교착 상태 회복**

교착 상태를 유발한 프로세스를 강제 종료한다.
- 교착 상태를 일으킨 모든 프로세스를 강제 종료
  - 종료된 프로세스들이 동시에 작업을 시작하면 다시 교착 상태 발생할 확률이 높다
  - 따라서 다시 프로세스를 시작할때는 순차적으로 실행한다
    - 어떤 프로세스를 먼저 실행할 지 기준이 필요하다
- 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
  - 순서를 정하는 방법은 다음과 같다
    - 우선순위가 낮은 프로세스 먼저 종료
    - 우선순위가 같은 경우 작업 시간이 짧은 프로세스 먼저 종료 
    - 두 조건이 같은 경우 자원을 많이 사용하는 프로세스 먼저 종료

교착 상태 회복에서는 프로세스를 종료하는 것뿐 아니라 프로세스가 다시 실행되기 전에 시스템을 복구하는 일도 해야한다. 시스템 복구는 명령어가 실행될 때마다 체크 포인트를 만들어 가장 최근의 검사 시점으로 돌아가는 방식으로 한다.

### 다중 자원에서 교착 상태 검출

다중 자원의 경우 자원 할당 그래프에서 사이클이 발생했을 때 반드시 교착상태인 것은 아니다. 따라서 이경우 대기 그래프와 그래프 감소 방법을 이용한다.

대기 그래프는 자원 할당 그래프에서 프로세스와 프로세스간 기다리는 관계만 표현한 그래프이다. 그래프 감소는 대기 그래프에서 작업이 끝날 가능성이있는 프로세스의 화살표와 관련 프로세스의 화살표를 지워가는 작업이다. 작업이 끝날 가능성이있는 프로세스란 기다리는 자원이 없는 프로세스를 말한다.

그래프 감소 후에도 사이클이 남아 있으면 교착상태가 발생한 것으로 간주한다.

### 식사하는 철학자 문제
- n명의 철학자가 원형 테이블에 앉아 있고 n개의 포크가 있다
- 철학자들은 식사를 하기 위해 왼쪽에 있는 포크를 먼저 잡은 채 오른쪽 포크를 기다린다.

- 철학자들은 서로 포크를 공유할 수 없다
  - 상호배제
- 철학자들은 다른 철학자의 포크를 빼앗을 수 없다
  - 비선점
- 철학자들은 왼쪽 포크를 잡은 채 오른쪽 포크를 기다린다
  - 점유 대기
- 철학자들은 원형 테이블에 앉아있따
  - 원형 대기

**해결 방법**

- 상호 배제
  - 철학자들의 포크를 서로 공유할 수 있도록한다.
- 비선점
  - 철학자들이 다른 철학자의 포크를 빼앗을 수 있도록한다
- 점유 대기
  - 두 포크르 모두 잡지 못한 철학자는 포크를 놓도록 한다
- 원형 대기
  - 한 철학자는 왼쪽이 아닌 오른쪽 포크를 먼저 잡도록 한다

## 메모리 관리
폰 노이만 구조의 컴퓨터에서 프로그램을 실행하기 위해 먼제 메모리에 프로그램을 로드해야한다. CPU는 작업을 위해 메모리에서 데이터를 가져오거나 저장한다. 시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 위치하기 때문에 관리가 어렵다. 이러한 복잡한 메모리 관리는 **메모리 관리 시스템(MMS)**이 맡아서 한다.

초기 컴퓨터가 개발되었을 때는 메모리가 매우 비쌌다. 빠른 작업을 위해 메모리가 필요하지만 메모리가 비싸기 때문에 많은 데이터를 저장할 수는 없었다. 이를 해결하기 위해 메모리를 계층적 구조로 만든다. CPU에 가까울 수록 비싸고 빠른 저장장치를 사용하고, 멀어질 수록 저렴하고 느리지만 많은 데이터를 저장할 수 있는 저장장치를 사용한다. 이를 통해서 사용자는 메모리 만큼 속도가 빠르고 하드 디스크 만큼 저장 용량이 큰 저장장치를 사용하는 것처럼 느낄 수 있다.

### 컴파일러와 인터프리터
- 컴파일러: 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행한다. C언어, 자바 등이 이러한 방식으로 동작한다.
- 인터프리터: 소스코드를 한 행씩 번역하여 동작한다. 자바스크립트나 파이썬 등이 이렇게 동작한다.

**컴파일러의 목적**
- 오류 발견: 소스 코드에서 오류를 발견하여 실행 시 문제가 없도록 한다. 오류를 찾기위해 심벌 테이블을 사용한다. 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 타입을 모아놓은 테이블이다.
- 코드 최적화: 소스 코드에서 군더더기와 사용하지 않는 변수를 제거하는 등 최적화하여 실행속도를 높인다.

**컴파일러 VS 인터프리터**
- 컴파일러는 변수를 미리 선언한 후 코드를 작성한다
  - 변수 선언은 오류를 찾고 코드를 최적화하기 위해 필요한 작업이다
- 인터프리터는 한 줄씩 위에서 아래로 코드를 실행하기 때문에 같은 일을 반복하는 경우나 필요 없는 변수를 확인할 수 없다

따라서 큰 프로그램에서는 컴파일러를, 간단한 프로그램에서는 인터프리터를 사용한다.

**컴파일 과정**
<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/149267299-1003685b-471c-45ee-8505-96ffa628ef94.png width=700>
</p>

### 메모리 관리자의 역할
- 가져오기(fetch): 프로세스와 데이터를 메모리로 가져오는 작업.
- 배치(placement): 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을 지 결정하는 작업.
  - 메모리를 어떤 크기로 자릴 것인지가 매우 중요하다
- 재배치(replacement): 가득 찬 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업.


## 메모리 주소
### 32bit VS 64bit

CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다. 32bit CPU는 한 번에 다룰 수 있는 데이터의 최대 크기가 32bit이고, 64bit CPU는 64bit가 최대이다. 컴퓨터의 대부분 부품은 CPU 비트와 동일하다. 레지스터나 버스, 산술 논리 연산 장치 등도 비트 크기에 맞춰서 설계된다.

메모리 주소를 지정하는 레지스터인 MAR(메모리 주소 레지스터)도 CPU 비트에 의해 결정된다. 32bit CPU는 메모리 주소 범위가 0 - 2^31 - 1로 약 4GB이다. 따라서 32bit CPU 컴퓨터는 최대 4GB 메모리를 사용할 수 있다.

64bit CPU는 0 - 2^63 - 1의 크기로 약 16,777,216 TB로 거의 무한대에 가까운 메모리를 사용할 수 있다.

### 절대 주소와 상대 주소
- 절대 주소: 메모리 관리자 입장에서 바라보는 주소. 메모리 주소 레지스터가 사용하는 주소로, 실제 램 메모리의 실제 주소를 의미한다.
  - 절대 주소를 사용하면 매번 운영체제의 영역을 확인해야한다.
  - 운영체제의 경계 주소가 사용자에게 노출되면 고의적으로 운영체제 영역을 침범하는 위험이 있을 수 있다
- 상대 주소: 사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소 지정 방식. 항상 0번지부터 시작하며 사용자 프로세스 입장에서 바라본 주소이다.

상대 주소를 사용하면 상대 주소를 물리 주소로 변경하는 작업이 필요하다. 이를 메모리 관리자가 매우 빠르게 처리한다.

## 메모리 할당
### 단일 프로그래밍 환경
- 메모리 오버레이: 전체 프로그램을 메모리에 로드하지 않고 적당한 크기로 잘라서 가져오는 기법을 의미한다.
  - 실제 메모리보다 큰 프로그램을 실행할 수 있다.
  - 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행 가능하다.
- 스왑: 프로그램의 조각을 메모리에 로드할 때 가득찬 메모리에서 프로세스를 메모리 밖으로 내 쫓는데 이 영역을 스왑 영역이라한다.
  - 스왑 아웃: 스왑 영역으로 데이터를 내쫓는 것
  - 스왑 인: 스왑 영역에서 데이터를 메모리로 가져오는 것

사용자 입장에서는 메모리 크기 + 스왑 영역의 크기로 전체 메모리 공간을 사용하는 것 처럼 느낄 수 있다.


### 다중 프로그래밍 환경
- 메모리 분할 방식: 메모리를 어떤 크기로 나눌 것인가를 결정. 메모리 배치 정책에 해당한다.
  - 가변 분할 방식: 프로세스의 크기에 따라 메모리 분할
  - 고정 분할 방식: 고정된 크기에 따라 메모리 분할

**가변 분할 방식**

프로세스의 크기에 맞게 메모리가 분할된다. 한 프로세스가 연속된 공간에 배치되어 **연속 메모리 할당**이라고도 한다.
- 연속된 공간에 프로세스를 배치할 수 있다
- 외부 단편화가 발생하여 메모리 통합 등 부가적인 작업이 필요하므로 메모리 관리가 복잡하다
  - 외부 단편화: 메모리에 빈 공간이 있어도 서로 떨어져 있는 공간에 프로세스르 배치하지 못해 발생하는 메모리의 빈 조각

외부 단편화를 해결하기 위해 조각 모음과 같은 메모리 통합이나 프로세스를 메모리 상에 잘 배치 해야한다. 프로세스 배치 방식은 다음과 같다

- 최초 배치: 적재 가능한 공간을 순차적으로 찾다가 첫 번째로 발견한 공간에 배치
- 최악 배치: 메모리의 빈 공간을 모두 확인한 후 배치 가능한 공간 중 가장 큰 공간에 프로세스 배치
- 최적 배치: 메모리의 빈 공간을 모두 확인한 후 배치 가능한 공간 중 가장 작은 공간에 프로세스 배치

**고정 분할 방식**
프로세스의 크기와는 관련 없이 메모리 공간을 고정된 크기로 분할하는 방식이다. 한 프로세스가 분산되어 배치되기 때문이 **비연속 메모리 할당**이라고 한다.

- 메모리를 일정 크기로 나누어 관리하기 때문에 메모리 관리가 수월하다
- 쓸모 없는 공간으로 인해 낭비가 발생할 수 있다. 이를 내부 단편화라 한다.
  - 나누어진 메모리 공간 크기보다 작은 프로세스가 올라올 경우 메모리 낭비가 발생할 수 있다.
  - 내부 단편화를 해결하기 위한 뚜렷한 해결책은 없고, 메모리의 크기를 신중하게 결정해야한다.

**버디 시스템**
가변 분할 방식과 고정 분할 방식의 중간 지점으로 외부 단편화를 완화할 수 있다.
1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치한다
2. 나뉜 메모리의 각 구역에는 프로세스 1개만 올라간다
3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다

비슷한 크기의 덩어리가 서로 모여있어 통합하기 쉽기 때문에 가변 분할 방식보다 효과적이다. 공간관리의 효율성 측면에서 고정 분할과 버디 시스템이 비슷하지만, 고정 분할의 구현이 더 단순하다.


