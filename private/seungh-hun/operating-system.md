# Operating System
:open_book: Contents
- [Operating System](#operating-system)
  - [운영체제란?](#운영체제란)
    - [운영체제의 필요성](#운영체제의-필요성)
    - [운영체제의 역할](#운영체제의-역할)
  - [운영체제 구조](#운영체제-구조)
    - [커널과 인터페이스](#커널과-인터페이스)
    - [시스템 호출과 디바이스 드라이버](#시스템-호출과-디바이스-드라이버)
    - [커널의 구성](#커널의-구성)
    - [가상 머신](#가상-머신)
  - [프로세스의 개요](#프로세스의-개요)
    - [프로그램과 프로세스](#프로그램과-프로세스)
    - [프로그램에서 프로세스로 전환](#프로그램에서-프로세스로-전환)
    - [프로세스의 상태](#프로세스의-상태)
    - [프로세스 제어 블록](#프로세스-제어-블록)
    - [문맥 교환](#문맥-교환)
    - [프로세스의 구조](#프로세스의-구조)
    - [프로세스의 생성과 복사](#프로세스의-생성과-복사)
    - [프로세스 계층 구조](#프로세스-계층-구조)
  
---

## 운영체제란?

운영체제는 사용자에게 편리한 **인터페이스 환경**을 제공하고 **컴퓨터 시스템의 자원을 효율적으로 관리**하는 **소프트웨어**이다.

### 운영체제의 필요성
초기 컴퓨터는 정해진 계산만 수행하면 됐다. 하지만 메모리, CPU의 성능이 향상되고, 여러 작업을 동시에 할 수 있는 컴퓨팅 환경이 조성되면서 사용 규칙이 필요해졌다. 이로 인해 운영체제가 나타났다.

### 운영체제의 역할
1. **자원 관리**
\
운영체제는 한정된 컴퓨팅 자원을 응용 프로그램에게 나누고 회수하며 사용자가 원활하게 작업할 수 있도록 돕는다.

2. **자원 보호**
\
운영체제는 미숙한 사용자나 악의적인 사용자로부터 컴퓨터 자원을 보호한다 

3. **하드웨어 인터페이스 제공**
\
운영체제는 복잡한 과정 없이 다양한 장치를 사용할 수 있도록 해주는 하드웨어 인터페이스를 제공한다. 운영체제는 다양한 장치를 일관된 방법으로 사용할수 있도록 지원하여 사용자는 하드웨어의 구체적인 동작 방식에 대해서 알 필요가 없다. 하드웨어 장치와 상호작용하기 위해 만들어진 컴퓨터 프로그램(하드웨어 인터페이스)을 **드라이버**라고한다.

4. **사용자 인터페이스 제공**
\
사용자 인터페이스는 사용자가 운영체제를 쉽게 사용하도록 지원한다. 운영체제는 사용자에게 GUI를 제공하여 사용자가 쉽게 작업을 수행할 수 있도록 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/147912120-3f760a8e-18c1-44a4-826f-4da45a33d92d.png width=500>
</p>

## 운영체제 구조

### 커널과 인터페이스

운영체제는 커널과 인터페이스로 나눌 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/147912449-12a72bf5-8e90-4ae6-8764-e4182ad1248a.png width=500>
</p>

**커널은** 프로세서 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아놓은 것을 말한다.

**인터페이스는** 커널에 사용자 명령을 전달하고 실행 결과를 사용자에게 알려주는 역할을 한다.

운영체제는 커널과 인터페이스를 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 가진 형태로 제작할 수 있다. 다른 인터페이스를 사용하면 사용자에게 다른 운영체제처럼 느껴질 수 있다.

### 시스템 호출과 디바이스 드라이버

**시스템 호출**은 커널이 제공하는 시스템 관련 서비스를 모아놓은 것이며 함수 형태로 제공된다. 커널은 컴퓨터 자원을 보호하기 위하여 자원에 직접 접근하는 것을 차단한다. 따라서 자원을 이용하기 위해서는 커널이 제공하는 시스템 호출을 사용해야한다.

```txt
API(Application Programming Interface)

응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스이다. 운영체제의 API를 시스템 호출이라할 수 있다.

SDK(System Developer's Kit)

프로그램 개발자를 위해 API 및 API 사용 매뉴얼, 프로그램 개발에 필요한 코드 편집기 같은 각종 개발용 응용 프로그램까지 묶어서 배포하는 개발 툴을 말한다(ex: android studio).

```

**드라이버**는 커널과 하드웨어 사이의 인터페이스이다. 커널이 모든 하드웨어에 맞는 인터페이스를 모두 개발하기 어렵다. 따라서 커널은 입출력의 기본적인 부분만 제작하고 하드웨어 특성을 반영한 소프트웨어를 하드웨어 제작자에게 받아 커널이 실행될 때 함께 실행하도록한다. 이때 하드웨어 제작자가 만든 소프트웨어를 디바이스 드라이버라고한다.

### 커널의 구성

커널은 운영체제의 핵심 기능을 모아놓은 것이다. 커널이 주로 하는 일은 아래와 같다

- 프로세스 관리
- 메모리 관리
- 파일 시스템 관리
- 입출력 관리
- 프로세스간 통신관리

커널은 이러한 기능을 구현하는 방법에 따라 단일형, 계층형, 마이크로 구조 커널로 구분된다.

- 단일형 구조 커널
  - 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성되어있다.
  - 모듈이 거의 분리되어 있지 않아 모듈간 통신 비용이 적다
  - 모듈이 분리되어있지 않아 버그나 오류를 처리하기 어렵다
  - 상호 의존성이 높아 작은 결함이 시스템 전체로 번질 수 있다

- 계층형 구조 커널
  - 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층간 통신을 통해 운영체제를 구현하는 방식이다.
  - 모듈이 계층적으로 분리되어 있어 단일형 보다 오류를 처리하거나 디버깅하기 편리하다

- 마이크로 구조 커널
  - 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공하는 커널
  - 다양한 요구를 수용하기 위해 커널이 방대해짐에 따라 나타난 구조
  - 다른 커널에 비해 운영체제의 많은 부분이 사용자 영역에 구현되어 있다.
  - 각 모듈이 독립적으로 작동하기 때문에 한 모듈의 결함이 전체로 퍼지지 않는다.

### 가상 머신
가상머신은 운영체제와 응용 프로그램 사이에서 작동하는 프로그램으로, 가상머신을 설치하면 응용 프로그램이 모두 동일한 환경에서 작동하는 것처럼 보인다. 자바 가상머신(JVM)이 여기에 해당한다.


## 프로세스의 개요

### 프로그램과 프로세스

현대 컴퓨터는 폰 노이만 구조를 가진다. **폰 노이만 구조**에서 프로그램이 실행된다는 것은 해당 코드가 **메모리**에 올라와서 작업이 실행된다는 것이다.

- **프로그램은** 저장장치에 저장되어 있는 정적인 상태
- **프로세스는** 실행을 위해 메모리에 올라온 동적인 상태

### 프로그램에서 프로세스로 전환

프로그램이 **메모리 위에 올라온 동적인 상태를 프로세스**라 한다. 프로그램이 프로세스로 전환되기 위해서는 메모리 위에 올라온 동시에 **프로세스 제어 블록(PCB: Process Control Block)**을 운영체제로 부터 할당 받아야한다.

따라서 다음과 같이 표현할 수 있다
- 프로그램 = 프로세스 - 프로세스 제어 블록
- 프로세스 = 프로그램 + 프로세스 제어 블록
  
프로세스 제어 블록은 프로세스의 작업 지시서와 같은 역할을 한다. PCB에는 프로세스의 다양한 정보가 포함되는데 대표적인 세 가지는 다음과 같다.

- 프로세스 구분자
\
메모리 상에서 프로세스를 구분하기 위한 구분자

- 메모리 관련 정보
\
CPU는 실행하려는 프로세스의 메모리 상의 위치를 알아야 작업이 가능하다. 따라서 PCB에 프로세스의 메모리 위치 정보가 포함된다.

- 중간 값(프로그램 카운터, 레지스터 값)
\
시분할 시스템에서 프로세스가 번갈아가며 실행된다. 따라서 프로세스가 사용했던 각종 중간 값들이 PCB에 저장된다.

프로세스가 종료되면 프로세스가 메모리에서 삭제되고 PCB도 같이 폐기된다. 중요한 점은 컴퓨터 내에는 사용자가 실행한 프로세스만 있는 것이 아니다는 것이다. 운영체제도 프로그램이기 때문에 프로세스 형태로 실행된다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148021164-8af9b9a5-59a9-4776-8eea-578d637c76e7.png width=500>
</p>

### 프로세스의 상태

**프로세스의 간단한 네 가지 상태**

- 생성 상태
\
프로세스가 메모리 위에 올라와 PCB를 할당 받아 실행 준비를 완료한 상태

- 준비 상태
\
생성된 프로세스가 CPU를 할당받아 실행될 때까지 기다리는 상태

- 실행 상태
\
준비 상태의 프로세스가 CPU를 할당 받아 실제 작업을 수행하는 상태. 실행 상태의 프로세스는 일정 시간(타임 퀀텀)동안 CPU를 사용할 권리를 가진다. 만약 작업을 완료하지 못하면 준비 상태를 오가며 작업이 완료될 때까지 실행된다.

- 완료 상태
\
프로세스가 작업을 완료하여 메모리에서 삭제되고 PCB가 폐기된 상태

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148022028-76fca84d-0d53-48da-9461-c65cc6008891.png width=500>
</p>

**프로세스의 다섯 가지 상태**

인터럽트 시스템에서 프로세스가 **입출력**을 요구하면 CPU는 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다. 입출력을 요구한 프로세스는 작업을 진행할 수 없는데, **작업의 효율성**을 높이기 위해서 프로세스를 계속 실행 상태로 두는 것이 아니라 입출력이 완료할 때까지 기다리는 **대기 상태**로 변경한다.

- 생성 상태
\
프로세스가 메모리 위에 올라와 PCB를 할당 받아 실행 준비를 완료한 상태

- 준비 상태
\
생성된 프로세스가 CPU를 할당받아 실행될 때까지 준비 큐에서 기다리는 상태. 실제로 다수의 준비 큐가 존재하며, CPU 스케줄러에 의해서 큐를 몇개 운영할 지, 어떤 프로세스의 작업을 수행할지 결정한다.

- 실행 상태
\
준비 상태의 프로세스가 CPU를 할당 받아 실제 작업을 수행하는 상태. 실행 상태의 프로세스는 일정 시간(타임 퀀텀)동안 CPU를 사용할 권리를 가진다. 만약 작업을 완료하지 못하면 준비 상태를 오가며 작업이 완료될 때까지 실행된다. 
\
\
시간을 다 사용하면 timeout(PID)가 실행되고, 작업이 완료되면 exit(PID)가 실행된다. 실행 상태의 프로세스가 입출력을 요청하면, CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)를 실행하여 프로세스를 대기 상태로 변경한다.


- 대기 상태
\
입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태. CPU는 다른 프로세스를 선정하여 작업을 진행할 수 있다.
\
\
대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다린다. 입출력이 완료되면 인터럽트가 발생하고, 대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데 이것이 wakeup(PID)이다. 그리고 해당 프로세스는 준비 상태로 변경된다.

- 완료 상태
\
프로세스가 작업을 완료하여 메모리에서 삭제되고 PCB가 폐기된 상태. 만약 비정상적으로 종료된 경우 디버깅을 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프라한다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148022485-ec4b3872-f974-4518-9eeb-85868fc6a88d.png width=500>
</p>

**휴식 상태와 보류 상태**

- 휴식 상태
\
프로세스가 작업을 일시적으로 쉬고있는 상태. 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되어 멈춘 지점에서 바로 재시작할 수 있다

- 보류 상태
\
프로세스가 메모리에서 일시적으로 쫓겨난 상태. 보류 상태의 프로세스는 **스왑 영역**에 보관된다. 보류 상태는 다시 대기 상태에서 옮겨진 **보류 대기 상태**, 준비 상태에서 옮겨진 **보류 준비 상태**로 구분된다.보류 대기 상태에서 입출력이 완료되면 보류 준비 상태로 옮겨진다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148023951-5dfbe925-b21a-40a8-9ed8-a5b2d3b360b7.png width=500>
</p>

### 프로세스 제어 블록

**프로세스 제어 블록(PCB: Process Control Block)은** 프로세스를 실행하는데 필요한 중요한 정보를 저장하는 자료구조이다.

프로세스 제어 블록의 구성은 다음과 같다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148029794-b7432a6b-e145-41c3-833e-3a0a9f3656e2.png width=200>
</p>

- 포인터: 포인터를 사용하여 PCB를 연결해 준비 상태나 대기 상태의 큐를 구현한다
- 프로세스 상태
- 프로세스 구분자
- 프로그램 카운터: 다음에 실행될 명령어의 위치를 가리킨다
- 프로세스 우선순위: 대기 큐, 준비 큐에서는 프로세스의 우선 순위에 따라 여러 줄로 서 있다.
- 레지스터 정보: 누산기, 색인 레지스터, 스택 포인터 등
- 메모리 관리 정보: 프로세스의 메모리 상 위치, 메모리 보호를 위한 경계 레지스터 값과 한계 레지스터 값, 세그먼테이션 테이블, 페이지 테이블 정보
- 할당된 자원 정보: 프로세스를 실행하기 위해 사용하는 입출력 자원 등에 대한 정보
- 계정 정보: 계정 번호, CPU 할당 시간, CPU 사용 시간
- 부모, 자식 프로세스 구분자

### 문맥 교환
**문맥 교환**은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이때 두 프로세스 제어 블록의 내용이 변경된다.

**문맥 교환의 절차**

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148030436-75dcaf3d-f669-4f98-bc95-3106e88ba0ad.png width=500>
</p>

1. 인터럽트나 시스템 콜이 발생한 경우 현재 프로세스 P0의 정보를 PCB에 저장한다
2. P0는 준비(대기) 상태로 쫓겨난다
3. P1이 실행 상태로 옮겨진다
4. CPU의 레지스터가 P1의 PCB 값으로 채워지고 작업을 수행한다.


문맥 교환이 일어나는 경우는 다양한데 대표적인 예는 다음과 같다
- 타임 아웃
- 인터럽트
- 주어진 메모리 공간을 벗어난 경우

### 프로세스의 구조

프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성된다.

- 코드 영역
\
프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 한다.

- 데이터 영역
\
변수나 파일 등 각종 데이터를 모아놓은 곳이다. 일반 데이터 영역과 힙(Heap) 영역으로 나뉜다

- 스택 영역
\
프로그램이 실행되는데 부수적으로 필요한 데이터를 모아놓은 곳이다. 함수를 수행하고 돌아올 위치 등이 저장된다.

**동적 할당 영역**

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/148031737-5ff188d3-24ea-471e-b963-c1213b546648.png width=200>
</p>

코드 영역과 데이터 영역은 프로세스가 실행되기 직전에 위치와 크기가 결정되고 실행되는 동안 변하지 않는 정적 영역이다.

**스택과 힙 영역**은 프로세스가 실행되는 동안 만들어지는 영역으로 크기가 변경되는 **동적인 영역**이다.

- 스택 영역
  - 스레드가 작동하는 동안 추가되거나 삭제되는 동적 할당영역이다
  - 호출한 함수가 종료되면 함수를 호출하기 전 코드로 되돌아올 메모리 주소를 스택에 저장한다
  - 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용한다. 지역 변수가 스택에 저장된다

- 힙 영역
  - 동적으로 할당되는 변수 영역이다.
  - 일부 데이터가 프로그램이 실행되는 동안 할당된다. C 언어의 `malloc()`, 자바의 `new`

### 프로세스의 생성과 복사
사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 PCB를 생성한다. 그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.

**fork()**

실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출이다.
부모-자식 관계가 형성되며 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다. 단 두 프로세스는 독립적이다.


프로세스를 새로 생성하는 것에 비해 fork()가 가진 장점은 다음과 같다

- 프로세스의 생성속도가 빠르다
- 추가 작업 없이 자원을 상속할 수 있다
- 시스템 관리를 효율적으로 할 수 있다

**exec()**

기존의 프로세스를 새로운 프로세스로 전환하는 함수이다. 프로세스의 구조체를 재활용하기 위해 사용한다. 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꿔버린다. 그리고 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다.

### 프로세스 계층 구조

fork()와 exec()를 통해서 프로세스를 계층 구조로 만들 수 있다. 계층 구조의 장점은 다음과 같다.

- 여러 작업 동시 처리
- 용이한 자원 회수

fork()로 생성된 부모-자식 프로세스는 독립적이기 때문에 어떤 프로세스가 먼저 작업이 종료될 지 모른다. 부모 프로세스가 먼저 종료되거나 자식 프로세스가 부모 프로세스와 통신이 안되는 경우를 미아 프로세스(좀비 프로세스)라 한다.