# Network
:open_book: Contents
- [Network](#network)
  - [OSI 7계층](#osi-7계층)
    - [1계층(피지컬 계층)](#1계층피지컬-계층)
    - [2계층(데이터 링크 계층)](#2계층데이터-링크-계층)
    - [3계층(네트워크 계층)](#3계층네트워크-계층)
    - [4계층(트랜스포트 계층)](#4계층트랜스포트-계층)
    - [5계층(세션 계층)](#5계층세션-계층)
    - [6계층(프레젠테이션 계층)](#6계층프레젠테이션-계층)
    - [7계층(애플리케이션 계층)](#7계층애플리케이션-계층)
    - [인캡슐레이션과 디캡슐레이션](#인캡슐레이션과-디캡슐레이션)
    - [TCP/IP](#tcpip)
  - [TCP와 UDP](#tcp와-udp)
  - [TCP](#tcp)
    - [패킷 순서, 응답 번호](#패킷-순서-응답-번호)
    - [윈도 사이즈와 슬라이딩 윈도](#윈도-사이즈와-슬라이딩-윈도)
    - [오류제어](#오류제어)
    - [흐름제어](#흐름제어)
    - [혼잡 제어](#혼잡-제어)
    - [3way-handshake](#3way-handshake)
    - [4way-handshake](#4way-handshake)
  - [UDP](#udp)
  - [IP 주소](#ip-주소)
    - [IP 주소 체계](#ip-주소-체계)
    - [클래스풀(Classful)](#클래스풀classful)
    - [클래스리스(Classless)](#클래스리스classless)
    - [서브넷 마스크](#서브넷-마스크)
    - [서브 네팅](#서브-네팅)
    - [공인IP와 사설IP](#공인ip와-사설ip)
  - [IPv4 VS IPv6](#ipv4-vs-ipv6)
    - [IPv4](#ipv4)
    - [IPv6](#ipv6)
  - [HTTP 개요](#http-개요)
    - [HTTP 문제점](#http-문제점)
  - [HTTP Method](#http-method)
    - [GET](#get)
    - [POST](#post)
    - [PUT](#put)
    - [DELETE](#delete)
    - [PATCH](#patch)
    - [멱등성](#멱등성)
  - [HTTP Status Code](#http-status-code)
    - [1XX](#1xx)
    - [2XX](#2xx)
    - [3XX](#3xx)
    - [4XX](#4xx)
    - [5XX](#5xx)
  - [HTTP1.1 VS HTTP2.0](#http11-vs-http20)
    - [HTTP 지연의 원인 - TCP 네트워크 지연](#http-지연의-원인---tcp-네트워크-지연)
    - [HTTP 커넥션](#http-커넥션)
    - [HTTP1.1](#http11)
    - [HTTP2](#http2)
  - [HTTPS](#https)
    - [HTTPS 커넥션](#https-커넥션)
    - [대칭키 암호화 방식](#대칭키-암호화-방식)
    - [공개키 암호화 방식](#공개키-암호화-방식)
    - [디지털 인증서](#디지털-인증서)
    - [SSL 동작 방식](#ssl-동작-방식)
    - [HTTPS의 통신 흐름 과정](#https의-통신-흐름-과정)
    - [HTTPS의 장단점](#https의-장단점)
  - [RESTful API](#restful-api)
    - [REST 구성](#rest-구성)
    - [REST 디자인 원칙](#rest-디자인-원칙)
    - [REST API 동작 방식](#rest-api-동작-방식)

---

## OSI 7계층


<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149924509-b280d9b2-f44a-4fe9-8ed1-3cc3f310c10d.png width=700>
</p>

- 5 ~ 7계층: 애플리케이션 계층, 상위 계층
  - 데이터를 잘 표현하는 역할
- 1 ~ 4계층: 데이터 플로 계층, 하위 계층
  - 데이터를 상대방에게 잘 전달하는 역할

### 1계층(피지컬 계층)
- 물리 계층으로 물리적 연결과 관련된 정보를 정의한다.
- 주로 전기 신호를 전달하는 데 초점이 맞추어져있다.
- 주요 장비로 허브, 리피터, 케이블, 커넥터, 트랜시버, 탭이 있다
- 주소의 개념이 없어 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 전송한다

### 2계층(데이터 링크 계층)
- 전기 신호를 모아 알아볼 수 있는 데이터 형태로 처리한다
- 주소 정보를 정의하고 정확한 주소로 통신이 이루어지는 데 초점이 맞추어져 있다
- 출발지와 도착지 정보를 확인하고 데이터를 처리하거나 폐기한다
- MAC 주소 체계를 가진다
- 주요 장비로 네트워크 인터페이스 카드와 스위치가 있다.
- 스위치는 MAC 주소를 보고 통신해야 할 포트를 지정해 보낸다

### 3계층(네트워크 계층)
- IP주소와 같은 논리적 주소가 정의된다.
- IP주소는 사용자가 환경에 맞게 변경해 사용할 수 있고, 네트워크 주소와 호스트 주소 부분으로 나뉜다
- 주요 장비로는 라우터가 있다.
  - 라우터는 IP 주소를 이해하고, IP 주소를 이용하여 최적의 경로를 찾아주고 그 경로로 패킷을 전송한다

### 4계층(트랜스포트 계층)
- 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다
  - 1 ~ 3계층은 데이터를 올바른 위치로 보내고 신호를 잘 만들어내는데 집중한다
- 중간에 패킷이 유실되거나 순서가 뒤바뀌는 것을 바로잡아준다
- 주요 장비로 로드 밸런서와 방화벽이 있다.
- 패킷에 보내는 순서를 명시한 것이 시퀀스 번호, 받는 순서를 나타낸 것이 ACK 번호이다.
- 장치 내의 많은 애플리케이션을 구분할 수 있도록 포트 번호를 사용한다

### 5계층(세션 계층)
- 양 끝단의 응용 프로세스가 연결을 성립하고 유지하고 종료하는 역할을 한다
- TCP/IP 세션을 만들고 없애는 책임을 진다
- 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다

### 6계층(프레젠테이션 계층)
- 애플리케이션이나 시스템 간 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다
- 응용 계층에서 데이터의 형식상 차이를 다루는 부담을 덜어준다
- MIME 인코딩, 암호화, 압축, 코드 변환과 같은 동작이 이루어진다

### 7계층(애플리케이션 계층)
- 애플리케이션 프로세스를 정의하고 애플리케이션 서비스를 수행한다.
- FTP, HTTP, SMTP, TELNET 같은 프로토콜이 있다

### 인캡슐레이션과 디캡슐레이션

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149927589-a1f2bb01-e6f6-425c-963d-d3c27ccb9fe4.png width=700>
</p>

- 인캡슐레이션: 데이터를 내보내는 과정
- 디캡슐레이션: 데이터를 받는 과정

송신측에서는 데이터가 계층을 내려가면서 헤더에 정보가 추가되고, 수신측에서는 계층을 올라가면서 각 계층에서 헤더 정보를 읽으며 벗겨낸다. 헤더에는 반드시 두 가지 정보는 포함되어야 한다.

- 현재 계층에서 정의하는 정보
- 상위 프로토콜 지시자
  - 2계층: MAC 주소
  - 3계층: IP 주소
  - 4계층: 포트 번호

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149928222-ac677753-683b-4f9a-a474-76fb7f80326f.png width=700>
</p>

인캡슐레이션 과정에서는 상위 프토콜지시자가 필요없지만, 디캡슐레이션 하면서 어떤 상위 프로토콜로 올려보내야 할지 결정하기위해 상위 프로토콜 지시자가 필요하다.

### TCP/IP

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149928544-2629dd3b-d53e-41f4-9b77-d72230120b12.png width=700>
</p>

TCP/IP는 이론보다 실용성에 중점을 프로토콜이다. OSI 레퍼런스 모델은 7계층으로 이루어진 반면에 TCP/IP 모델은 4계층으로 구분한다. 이는 데이터를 만드는 애플리케이션 부분과 데이터를 잘 전달하는 데 집중하는 하부 계층으로 구분하는 것이 목적이었다.

TCP/IP 프로토콜은 상위 3개의 계층을 하나로 묶고, 물리 계층과 데이터 링크 계층을 하나의 네트워크 계층으로 구분한다.

## TCP와 UDP

2, 3 계층은 주소를 사용하여 목적지를 정확하게 찾아가는 것이 목표였다. 4계층에서 동작하는 프로토콜은 목적지 단말 안에서 동작하는 여러 애플리케이션 중 통신해야 할 **목적지 프로세스**를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해서 원래 데이터를 만들어내기 위한 역할을 한다.

4계층의 프로토콜인 TCP와 UDP는 포트 번호를 통해 출발지와 목적지를 표현한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140883809-c054cc33-04ad-465c-9477-e250acaa555b.png width=700>
</p>

## TCP
TCP는 신뢰할 수 없는 공용망에서 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 패킷이 잘 전송되었는지 확인하는 기능이있다.

패킷에 번호(Sequence Number)를 부여하고 잘 전송되었는지에 대해 응답(Ackowledge Number)한다. 얼마나 보내야 수신자가 잘 처리할 수 있는지 전송 크기(Window Size)까지 고려해 전송한다.

### 패킷 순서, 응답 번호
TCP는 분할된 패킷을 수신측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다. 패킷의 순서를 시퀀스 번호, 응답 번호를 부여하는 것을 ACK라고한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140884669-6524e2de-e569-4e73-afdd-67cfa68e2954.png width=500>
</p>

1. 출발지에서 시퀀스 번호를 0으로 보낸다
2. 수신 측에서 0번 패킷을 잘 받았다는 의미로 응답 번호(ACK)에 1을 적어 응답한다.
   - 수신 측에서는 자신이 처음 보내는 패킷이므로 자신 패킷 시퀀스 번호는 0번을 부여한다.
3. 송신 측은 시퀀스 번호를 1로, ACK는 0번 패킷을 잘 받았다는 의미로 1로 부여해 전송한다.

### 윈도 사이즈와 슬라이딩 윈도
송수산자간 패킷을 주고 받을 때 거리가 멀리 떨어져있으면 왕복 지연시간이 늘어나므로 응답을 기다리는 시간이 지연된다.

따라서 한 번에 많은 패킷을 보내고 한꺼번에 응답을 받아야한다. 한 번에 받을 수 있는 데이터의 크기를 윈도 사이즈라고 하고 네트워크 상황에 따라 윈도 사이즈를 조절하는 것을 슬라이딩 윈도라고 한다.

### 오류제어
ARQ(Automatic Repeat Request) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다.

- Stop and Wait ARQ: 송신측에서 패킷을 전송하고 NAK를 받을 경우 재전송하는 기법이다.
  - 데이터나 ACK를 유실했을 경우 타임 아웃이 발생해 재전송된다.

- Go-Back-n ARQ: 전송된 프레임이 손실되거나 유실되어 타임 아웃이 발생한 경우 마지막으로 확인된 패킷 이후의 전체 패킷을 재전송한다

- Selective-Reject ARQ: 손실되거나 유실된 프레임만 재전송하는 기법이다. 프레임의 재정렬을 수행해야하므로 별도의 버퍼가 필요하다.

### 흐름제어
송신측과 수신측 사이의 데이터 처리 속도 차이를 제어하기 위한 기법이다.

- 정지-대기: 매번 전송한 패킷에 대한 응답을 받아야 다음 패킷을 전송할 수 있다
  
- 슬리이딩 윈도우: 수신측에서 설정한 윈도우 크기만큼 확인 응답 없이 한 번에 여러 패킷을 전송할 수 있다.

### 혼잡 제어
- **Addictive Increase**
\
전송한 패킷에 대해서 ACK를 받은 경우 윈도우 사이즈를 1씩 증가시키는 방법

- **Multiplicative Decrease**
\
ACK를 받지 못한 경우 윈도우 사이즈를 절반으로 줄이는 방법

- **Slow start**
\
윈도우 사이즈를 1로 시작한다. 전송에 성공한 패킷의 수 만큼 윈도우 사이즈를 증가시키는 방법이다. 즉 윈도우 크기가 1, 2, 4, 8 , 16, ... 2의 지수승 만큼증가한다.
\
그리고 네트워크 혼잡이 감지된 경우 그때 윈도우 사이즈를 Threshold로 기억하고 윈도우 사이즈를 1로 줄인다. 다시 윈도우를 2의 지수만큼 증가하다가 Threshold의 절반 크기가 된 경우 윈도우 사이즈를 1씩 늘린다.

- **Fast Retransmit**
\
패킷 하나가 중간에 유실된 경우 수신측은 유실된 패킷의 다음 시퀀스를 ACK에 실어 보낸다. 수신측은 유실된 패킷의 시퀀스를 중복적으로 보내고 시퀀스가 3번이 중복되면 송신측은 해당 패킷을 재전송한다.

- **Fast Recovery**
\
네트워크 혼잡이 감지되면 윈도우 사이즈를 1이 아닌 절반으로 줄이고 선형증가하는 방법이다. 이 정책은 처음 혼잡 상황을 겪은 뒤에는 계속 선형증가한다.


### 3way-handshake

TCP는 유실없는 안전한 통신을 위해 사전 연결 작업을 수행한다. 패킷 네트워크에서는 동시에 많은 상대방과 통신하므로 정확한 통신을 위해서 통신 전, 각 통신에 필요한 리소스를 미리 확보하는 것이 중요하다. 3번의 패킷 교환을 통해 통신을 준비하여 3way handshake라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140899565-9a7169dd-74db-4219-a656-996bd5529cdd.png width=500>
</p>

1. 송신자가 SYN 필드를 1로 표기해 패킷을 전송한다
   - 이때 자신이 사용할 패킷의 첫 시퀀스 번호를 적어보낸다.
   - 포트 번호는 유한 범위내에서 설정되므로 시퀀스 번호를 순차적으로 설정할 경우 이전 통신의 패킷으로 오해할 수 있기 때문이다.

2. 수신자는 ACK와 SYN 필드를 1로 표기해 응답한다
   - 자신이 보내는 첫 패킷이므로 SYN을 함께 보낸다
   - 연결 신호를 허락하는 의미로 전달한다.

3. 송신자가 ACK를 1로 표기해 전달한다.

### 4way-handshake
TCP는 세션을 안전하게 종료하기 위해 4개의 패킷을 교환한다. 이를 4way-handshake라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149465776-7bdece24-58b2-4fdc-9cc4-25810c9d8999.png width=500>
</p>

1. 송산자가 연결을 종료하기 위해 FIN에 1을 부여하여 패킷을 전송한다
2. 수신자는 요청 확인의 의미로 ACK에 1을 표기하여 패킷을 전송한다.
3. 수신자는 연결 종료 준비를 완료한 후 FIN에 1을 표기하여 송신자에게 패킷을 전송한다
4. 송신자는 연결 종료 확인의 의미로 ACK에 1을 표기하여 패킷을 전송한다
5. 송신자는 아직 도착하지 못한 패킷이 있을 경우를 대비해 기다렸다가 연결을 종료한다.

## UDP
UDP는 4계층에서 가져야할 특징을 거의 가지고 있지 않다. UDP는 신뢰성있는 데이터의 전송을 보장하지 않는다. 손상되거나 유실된 데이터에 대한 조치를 하지 않으므로 헤더가 가볍다.

UDP는 실시간 스트리밍과 같이 시간에 민감한 애플리케이션을 사용하거나 사내 방송과 같은 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 주로 사용된다. 보통 음성이나 동영상과 같은 데이터를 전송할 때 사용된다. 30 프레임의 동영상에 1 프레임이 빠져도 크게 이상한점을 느끼지 못하기 때문이다.

UDP는 TCP와 달리 연결을 사전에 확립하는 작업이 없다. 대신 UDP에서 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용한다. 따라서 연결 확립은 TCP로 하고 애플리케이션끼리 모든 준비를 마친 후 실제 데이터만 UDP를 사용한다.

같은 동영상 스트리밍이더라도 넷플릭스처럼 시간에 민감하지 않는 단일 시청자를 위한 연결은 TCP를 사용한다. 원활한 시청을 위해 미리 데이터를 받아 놓고 네트워크에 문제가 생기더라도 동영상이 끊기지 않도록 캐시에 저장한다. 실시간 화상 회의와 같은 시간에 민감한 데이터에서는 UDP를 사용한다.

## IP 주소

3계층의 논리적 주소이다. IP 주소를 포함한 3계층의 주소는 다음과 같은 특징을 가진다.
- 사용자가 변경이 가능한 주소이다.
- 주소에 레벨이 있다. 그룹을 의미하는 네트워크 주소와 호스트 주소로 나뉜다.

### IP 주소 체계
흔히 사용하는 IP주소는 32비트 주소인 IPv4이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140734693-6256d764-3fb6-4985-be96-0c093ab6d774.png width=500>
</p>

IP는 v4, v6 두 체계가 있고 v6은 128비트 주소 체계이다. MAC 주소가 16진수로 표기된 것과 다르게 IP주소는 10진수로 표기한다.

- 네트워크 주소: 호스트들을 모은 네트워크를 지징하는 주소이다. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라 한다.
- 호스트 주소: 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소이다.

IP주소는 MAC주소가 고정적인 크기로 분할되는 것과 다르게 유동적으로 네트워크와 호스트 주소가 분할된다.

### 클래스풀(Classful)
**네트워크 주소 범위를 클래스 별로 설정**하여 각 조직에 배분하는 방식을 클래풀이라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140877655-2454a524-9dfc-479b-9e01-fc2c6d242fba.png width=500>
</p>

- A클래스: 네트워크 주소 1옥텟 + 호스트 주소 3옥텟
- B클래스: 네트워크 주소 2옥텟 + 호스트 주소 2옥텟
- C클래스: 네트워크 주소 3옥텟 + 호스트 주소 1옥텟

클래스 기반의 IP주소 체계에서는 옥텟의 위치를 통해 클래스를 구분할 수 있다. 

### 클래스리스(Classless)
클래스풀 IP 주소는 네트워크 주소와 호스트 주소를 구분 짓는 구분자인 서브넷 마스크가 필요하지 않다. 맨 앞자리 주소만 보고 해당 주소가 어느 클래스에 위치한 지 알 수 있기 때문이다.

하지만 인터넷이 상용화되면서 클래스풀 주소 체계는 급속도로 늘어나는 IP 주소에 대한 요구를 감당할 수 없었고, 다음과 같은 문제점들이 있었다.

- 하나의 네트워크에서 IP를 사용하면 다른 네트워크에서 그 IP를 사용하지 못했다
- IPv4의 크기가 작았다.
- 상위 클래스(A class)를 할당 받은 조직이 주소를 제대로 활용하지 않았다.

이러한 문제점의 해결책으로 다음 3가지가 제안되었다.
- 단기: 클래스 리스기반 주소체계
- 중기: NAT와 사설 IP 주소
- 장기: IPv6


클래스의 개념을 버린 클래스리스기반 주소체계는 맨 앞의 숫자를 통해 네트워크 주소와 호스트 주소를 구분할 수 없었다. 클래스리스 네트워크에서는 별도의 구분자를 사용하는데 이를 **서브넷 마스크**라한다.

### 서브넷 마스크
서브넷 마스크는 IP 주소와 네트워크 주소를 구분할 때 사용하는 구분자이다. 2진수 숫자 1은 네트워크 주소, 0은 호스트 주소로 표시한다.

클래스를 서브넷 마스크로 나타내면 아래와 같다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879111-f3f2bb02-595a-4880-9965-6bb7e377794c.png width=500>
</p>

IP 주소를 서브넷 마스크와 `& 연산`하면 네트워크 주소를 확인할 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879606-770c5aee-994d-4e6a-aabb-db2321c084c1.png width=500>
</p>

### 서브 네팅
네트워크-호스트 구분 기준을 사용자가 정해, 원래 클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것을 서브 네팅이라한다.

부여된 주소를 다시 잘라 사용해 서브네팅이라 부르는데 현대 클래스리스 네트워크의 가장 큰 특징이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140881269-85bfe37f-e68b-4615-8512-b49420378e1a.png width=500>
</p>

### 공인IP와 사설IP

인터넷에 접속하기 위해서는 IP 주소가 필요하고 이 IP는 전세계에서 유일해야 하는 식별자이다. 이러한 IP 주소를 **공인IP**라고 한다.

인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 공인IP 주소를 할당 받지 않고도 네트워크를 구축할 수 있다. 이때 사용하는 주소를 **사설IP 주소**라고 한다.

주로 인터넷에 접속하지 않거나 NAT(Network Address Translation)기술을 사용할 경우 사설IP 주소를 사용한다. 공유기가 대표적인 NAT 장비 중 하나이다.

NAT 기술을 사용하더라도 다른 사용자에게 이미 부여된 IP를 사설 IP 주소로 사용하면 안된다. 

## IPv4 VS IPv6
### IPv4
가장 대중적인 3계층의 프로토콜이다. 패킷 전송과정에서 오류가 발생할 수 있고, 전송된 패킷 간에 순서가 보장되지 않는다. 즉, 비신뢰적 비연결지향형 프로토콜이다. 데이터의 전송에만 초점을 두고 있으며, IPv4에서 패킷을 데이터그램이라고도 한다.

### IPv6
IPv4보다 더 많은 주소를 표현할 수 있고 전송 효율을 높인 인터넷 프로토콜이다. IPv4가 32비트 주소 체계인 반면, IPv6는 128비트 주소 체계이다. Base Header와 Extension Header를 분리함으로써 라우터간 전송 과정에서 불필요한 과정을 줄여 전송 효율을 높였다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/150665998-3969e0af-4984-432d-b0e4-02eec09ea538.png width=500>
</p>

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/150666030-2cf57d64-31d7-43ec-9f47-6e56ef7e2308.png width=500>
</p>

Source Routing에 거쳐야할 라우터들을 리스트 형태로 저장한다

IPv6에서는 Destination IP Address가 아닌 경우 Base header만 참조하므로 IPv4와 다르게 단편화, 헤더 오류 탐지 등의 과정이 생략되면서 전송과정이 빨라졌다.

## HTTP 개요
HTTP(HyperText Transfer Protocol)은 HTML과 같은 문서를 웹 상에서 클라이언트와 서버간 요청/응답(Request/Response)으로 주고 받을 수 있는 프로토콜이다.

- 주로 HTML 문서를 주고 받는데 사용한다.
- TCP와 UDP를 사용하며, 80번 포트를 사용한다.
- 비연결(Connectionless) 프로토콜이다.
- 무상태(Stateless)프로토콜이다.

**비연결(Connectionless)**
클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊어진다.

**무상태(Stateless)**
연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

**HyperText**
참조를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트

### HTTP 문제점

- HTTP는 평문 통신이기 때문에 도청이 가능하다.
- 통신 상태를 확인하지 않기 때문에 위장이 가능하다.
- 완전성을 증명할 수 없기 때문에 변조가 가능하다.

## HTTP Method

### GET
- 정보를 조회(SELECT)하기 위한 메서드이다. CRUD를 예로들 경우 R에 해당한다.
- URL의 끝에 '?'가 붙고, 요청 정보가 'key=value' 형태의 쌍을 이루어 '? 뒤에 붙어 서버로 전송된다.
- 요청 정보가 여러 개일 경우 '&'로 구분한다.

**특징**

- URL에 요청 정보를 붙여서 전송한다.
- URL에 정보를 이어 붙이기 때문에 길이의 제한이 있다.
- 요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다. 이로 인해 POST보다 보안에 취약하다.
- HTTP 패킷에 body는 비어 있는 상태로 전송한다.
- POST 방식 보다 빠르다. GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐시된다.

### POST
- 서버의 값이나 상태를 바꾸기위한 용도의 메서드이다. CRUD 관점에서 C에 해당한다.
- 단 Update나 Delete에도 사용이 가능하다.
- 요청 정보를 HTTP 패킷 안의 body에 숨겨서 서버로 전송한다.
- Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다.

**특징**

- Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다
- 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
- GET 방식 보다 안전하다.

### PUT
- 새로운 리소스를 생성하거나, 대상 리소스를 나타내는 데이터를 수정하는데 사용한다.
- CRUP 관점에서 U에 해당한다.
- 자원의 식별자를 미리 알고 있어야한다.
- 자원의 식별자가 존재하는 지는 영향이 없고, 자원이 존재하는 경우는 대체하고, 존재하지 않는 경우는 새로 생성한다.

**POST와 차이**

- POST는 Request 메세지에 포함된 엔티티를 이용해 새로운 자원을 생성한다.
- PUT은 Request 메세지에 함께 넘어온 식별자를 자원으로 만든다.
- POST는 동일한 요청이 2번 전달되면, 2개의 자원을 생성한다.
- PUT은 동일한 요청이 2번 전달되면, 첫 번째 요청에서 자원이 존재하지 않으면 새로 생성하고, 두 번째 요청에서는 자원이 이미 존재하기 때문에 대체한다.

### DELETE

- 지정한 리소스를 삭제한다.
- CRUD 관점에서 D에 해당한다.
- 어느 자원을 삭제할 지 URL에 드러난다.

### PATCH

- 리소스의 부분을 수정하는데 사용한다. 의미론적으로 U에 해당한다.

**PUT과 차이**
- PUT은 자원의 전체를 교체하지만, PATCH는 자원의 일부만을 교체하는 역할을 수행합니다.

### 멱등성
멱등성은 여러번 적용하더라도 결과가 달라지지 않는 것을 말한다.

멱등성을 보장하는 메서드는
- GET
- PUT
- PATCH
- DELETE

멱등성을 보장하지 않는 메서드는
- POST

POST는 요청마다 서버에 엔티티를 생성하기 때문에 멱등하지 않다

## HTTP Status Code

### 1XX
요청이 수신되어 처리중임을 나타내는 상태 코드이다. 현재는 거의 사용되지 않는다.

### 2XX
요청이 정상적으로 처리되었음을 나타내는 상태코드이다.
- 200(OK)
  - GET과 같은 조회 요청에 성공적으로 응답하는 경우
- 201(Created)
  - POST와 같은 생성요청으로 리소스가 정상적으로 생성 된 경우
  - 응답 헤더에 생성된 리소스의 식별자가 `Location`에 추가된다
- 202(Accepted)
  - 요청은 서버에서 받았으나 아직 처리되지 않은 경우
  - 배치 프로세스가 이에 해당한다
- 204(No Content)
  - 서버에서 요청은 정상적으로 수행했지만 응답 메세지 바디에 담을 데이터가 없는 경우
  - 웹 문서 편집기에서 SAVE요청 같은 것

### 3XX
요청을 완료하기 위해 추가적인 행동이 필요한 경우를 나타내는 상태 코드이다. 웹 브라우저는 3XX 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다.
**영구 리다이렉션**
\
특정 리소스의 URI가 영구적으로 이동한다.
- 301(Moved Permanantly)
  - 리다이렉트시 요청 메서드가 GET으로 변경된다
  - 본문이 변경될 수 있다
- 308(Permanent Redirect)
  - 301과 기능은 동일하다
  - 응답 메세지의 본문과 요청 메서드가 유지된다

**임시 리다이렉션**
\
특정 리소스의 URI가 일시적으로 변경된다.
- 302(Found)
  - 리다이렉트시 요청 메서드가 GET으로 변경된다.
  - 본문이 제거될 수 있다
- 307(Temporary Redirect)
  - 302와 기능은 같다
  - 응답 메세지의 본문과 요청 메서드가 유지된다(MUST)
- 303(See Other)
  - 302와 기능은 같다
  - 리다이렉트 요청 메서드가 GET으로 변경된다


**PRG(Post-Redirect-GET) Pattern**
\
페이지 새로고침은 요청을 다시 보내는 것이다. 따라서 멱등하지 않은 요청인 POST에 새로고침을 하면 여러 엔티티가 생성될 수 있다. 예를 들어, 주문 요청 중간에 새로고침을 하면 주문이 여러개 생성될 수 있다. 따라서 리다이렉션해야한다
응답 코드로 302, 303 등을 사용하면 자연스럽게 리다이렉션시 메서드가 GET으로 변경되어 문제를 해결할 수 있다.


초기 302 스펙의 의도는 HTTP 메서드를 유지하기 위한 것이었다. 하지만 대부분의 브라우조가 GET으로 바꾸어버렸고, 애매한 302를 대신하여 307, 303이 등장했다.

스펙으로는 307과 303을 권장하지만 현실적으로는 302를 대다수 사용한다. 따라서 자동 리다이렉션시 GET으로 메서드를 변경해도 상관이 없으면 그냥 302를 사용한다.


**캐시 목적**
- 304(Not Modified)
  - 캐시를 목적으로 사용한다
  - 클라이언트에 리소스가 수정되지 않았음을 알린다
  - 304 응답은 메세지 바디를 사용하면 안된다
  - 조건부 GET, HEAD 요청시 사용한다

### 4XX
\
클라이언트에서 잘못된 스펙으로 데이터를 보냈거나 인증, 인가가 만족되지 않아 서버에서 요청을 수행할 수 없음을 나타내는 응답코드이다.
- 400(Bad Request)
  - 클라이언트의 요청 포맷이나 데이터에 문제가 있을 경우
- 401(Unauthorized)
  - 인증이 되지 않은 클라이언트에서 리소스에 접근하는 경우
  - WWW-Authenticate 헤더와 함께 인증 방법을 설명
- 403(Forbidden)
  - 인증자격은 있지만 해당 리소스에 접근할 권한이 없는 경우
- 404(Not Found)
  - 요청 리소스를 찾을 수 없는 경우

### 5XX
- 500(Internal Server Error)
  - 서버 내부 문제가 발생한 경우
  - 서버측 로직에서 발생하는 대다수의 예외나 에러는 모두 500
  - 비즈니스 로직과 같이 시스템이 아닌 로직 상의 문제가 발생할 때 500 응답 코드를 반환해서는 안된다
- 503(Service Unavailable)
  - 서버에 트래픽문제 혹은 점검으로 잠시 요청을 처리할 수 없는 경우

## HTTP1.1 VS HTTP2.0
### HTTP 지연의 원인 - TCP 네트워크 지연
HTTP 지연의 원인 중 대부분은 TCP 네트워크 지연으로 인해 발생한다. HTTP 통신에 많은 영향을 주는 TCP 관련 지연 요소는 다음과 같다.

- TCP 커넥션 지연
- Slow start
- 네이글 알고리즘
- 확인응답 지연 알고리즘

**TCP 커넥션 지연**
\
TCP에서 클라이언트-서버는 3way-handshaking 과정을 통해 커넥션을 맺는다. 이 때 SYN-SYN/ACK-ACK으로 3번의 패킷 교환 과정이 이루어진다. 처음 두 번의 패킷 교환(SYN-SYN/ACK)에서 패킷에 HTTP 요청 메시지를 담을 수 없기 때문에 지연이 발생한다. 만약 304 응답과 같이 HTTP 통신의 데이터가 작은 경우에는 TCP 커넥션 지연이 전체 통신에서 차지하는 비중이 크다.

**확인 응답 지연**
\
TCP는 송출 데이터 패킷에 확인 응답을 편승(piggyback)하여 네트워크를 좀 더 효율적으로 사용한다. 확인 응답 지연은 송출할 확인응답을 특정 시간동안 지연하고 편승하기 위한 송출 데이터를 찾는 것으로 인해 발생한다. 

**Slow start**
\
TCP는 네트워크 혼잡을 피하기 위해서 Slow start 기법을 사용한다. Slow start는 TCP가 한 번에 전송할 수 있는 패킷의 수를 제한한다. 전송한 패킷의 확인응답을 받으면 다음 전송에는 2배로 늘려서 패킷을 전송하는 방식이다. 이로 인해 새로 생성된 TCP 커넥션은 이미 튜닝된 TCP 커넥션 보다 더 적은 데이터를 전송한다.

**네이글 알고리즘**
\
네트워크 효율을 위해서 여러 개의 패킷을 모아서 한 번에 전송하는 기법이다. 작은 패킷을 모아 한 번에 많이 보내기 때문에 데이터의 전송 횟수가 줄어들어 네트워크를 효율적으로 사용할 수 있다. 하지만 크기가 매우 작은 HTTP 메시지는 패킷을 모두 채우지 못해 전송이 지연될 수 있다.

### HTTP 커넥션

**순차적인 트랜잭션 처리에 의한 지연**
\
클라이언트-서버간 트랜잭션마다 커넥션을 순차적으로 생성하는 방법이다. 이러한 방식은 웹 페이지를 구성하는 데이터들 (HTML, Javascript, Image)이 동시에 로드되지 않아 사용자로 하여금 심리적인 지연을 느끼게 할 수 있다. 이러한 순차적인 트랜잭션 처리를 해결하기 위해서 다음과 같은 해결책이 나왔다

- 병렬 커넥션
- 지속 커넥션
- 파이프라인 커넥션
- 다중 커넥션

**병렬 커넥션**
\
클라이언트가 여러 개의 커넥션을 맺음으로 여러 개의 HTTP 트랜잭션을 병렬적으로 처리할 수 있게하는 방식이다. 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고 데이터를 동시에 전달받아 빠르게 웹 페이지에 로드할 수 있다.

하지만 클라이언트의 대역폭이 좁을 때는 병렬 커넥션이 항상 빠르지 않을 수 있다. 그리고 다수의 커넥션은 메모리를 많이 소비하고, 서버가 관리할 커넥션이 많아져 부하가 커질 수 있다.

**지속 커넥션**
\
HTTP 트랜잭션 처리가 완료된 후도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용하는 방법이다. 커넥션을 재사용하기 때문에 핸드세이킹으로 인한 지연과 Slow start로 인한 지연을 줄일 수 있다.

HTTP1.1에서는 지속 커넥션이 기본적으로 활성화 되어 있어 별도로 설정하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급한다.

**파이프라인 커넥션**
\
여러 개의 요청은 응답이 도창하기 전까지 큐에 쌓인다. 그리고 첫 번째 요청이 서버로 전달되면 이어서 두 번째, 세 번째 요청이 전달된다. 이는 네트워크의 왕복으로 인한 지연을 줄여준다.

파이프라인 커넥션은 지속 커넥션이 확인되지 않는 경우 사용할 수 없고, POST 요청과 같은 비멱등 요청에서 사용해서는 안된다.

치명적인 단점으로 Head Of Line Blocking이 있다. HTTP는 패킷의 순서를 보장하는 기능이 없기 때문에 요청 순서에 따라 응답을 받아야한다. 따라서 서버에서는 요청 1, 2, 3을 전달 받아 요청 2의 작업을 먼저 처리했더라도 요청1의 작업이 끝날 때까지 기다려야 하는 것이다.

### HTTP1.1
HTTP1.0에서는 순차적으로 트랜잭션을 처리하였다. 한 커넥션에서 하나의 요청-응답이 이루어졌다. HTTP는 기본적으로 TCP를 사용하기 떄문에 TCP 커넥션의 handshaking, slow start로 인한 지연에 영향을 받는다. 이러한 지연을 해결하기 위해 병렬 커넥션, 지속 연결, 파이프라인 커넥션 기능을 제공했다.

- 병렬 커넥션: 한 커넥션을 맺을 때 다수의 커넥션을 한 번에 맺는 것
  - 커넥션 지연시간을 겹치게 할 수 있고, 데이터를 병렬적으로 전달 받을 수 있다
  - 클라이언트의 대역폭이 작으면 병렬 커넥션의 장점을 누릴 수 없다
- 지속 커넥션: 커넥션을 맺은 후 바로 종료하는 것이 아니라 커넥션을 유지하고 다음 요청에 재사용 하는 방법
  - handshaking, slow start으로 인한 지연을 줄일 수 있다
- 파이프라이닝 커넥션: 한 요청에 대한 응답을 기다리지 않고 다음 요청을 전달하는 방식
  - HTTP는 응답의 순서를 보장하지 않기 때문에 서버측에서는 먼저 온 요청을 처리할 때까지 다음 요청은 작업이 완료되더라도 기다려야함
  - 이를 Head Of Line Blocking이라 함

그리고 HTTP1.1의 헤더에는 많은 데이터들이 저장되어있다. 클라이언트가 서버로 보내는 매 요청마다 중복된 헤더 값을 전송해야 한다.

### HTTP2
기존의 HTTP1.1 버전의 성능 향상에 초점을 맞춘 프로토콜이다.

HTTP1.1의 회전 지연(RTT)을 줄이기 위해 헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄였으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능을 가지고 있다. 

**스트림, 메시지, 프레임**
\
줄바꿈으로 구분되는 일반적인 텍스틀르 사용하는 HTTP1.1과 달리 HTTP/2 통신에서는 메시지와 프레임으로 분할되며 바이너리 형식으로 인코딩된다. 

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/150754799-de63e862-3190-48a3-9ba5-0eaa8a6bd1be.png width=700>
</p>

따라서 HTTP/2는 HTTP 프로토콜 통신을 바이너리 인코딩된 프레임의 교환으로 세분화된다. 그런 다음 이 프레임은 특정 스트림에 속하는 메시지에 매핑되며, 모든 프레임은 단일 TCP 연결 내에서 다중된다.

- 스트림: 구성된 연결 내에서 전달되는 바이트의 양방향 흐름이며 하나 이상의 메시지가 전달될 수 있다
- 메시지: 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스
- 프레임: HTTP/2에서 통신의 최소 단위이며 각 최소 단위에는 하나의 프레임 헤더가 포함된다. 이 프레임 헤더는 최소한으로 프레임이 속하는 스트림을 식별한다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/150754976-41e78fbd-7360-48dc-875b-4466373dca2a.png width=700>
</p>

**요청, 응답 다중화**
\
HTTP/2의 다중화는 HTTP1.1의 HOL 현상과 기본 TCP 연결의 비효율적인 사용을 해결한다. 클라이언트와 서버는 HTTP 메시지를 독립된 프레임으로 세분화하고, 이 프레임을 인터리빙한 다음 다른 쪽에서 다시 조립하도록 허용한다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/150755845-fac11733-9704-4e69-8541-9422f41940a6.png width=700>
</p>

위 그림은 동일한 연결 내의 여러 스트림을 나타낸 그림이다. 서버는 스트림1과 스트림3의 인터리빙된 프레임 시퀀스를 클라이언트에 전송 중이며 클라이언트는 서버에 스트림5의 프레임을 전달하고 있다. 따라서 3개의 병렬 스트림이 존재한다.

**서버 푸시**
\
클라이언트가 명시적으로 요청하지 않아도 서버가 추가적인 리소스를 클라이언트에 전송하는 것이다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/150756722-94e53af6-bd79-48ae-a05f-b135b5511fdd.png width=700>
</p>

웹 페이지를 구성하는 다양한 리소스가 있기 때문에 서버는 클라이언트가 해당 리소스를 요청하기까지 기다리지 않고 필요한 리소스를 먼저 클라이언트에 푸시하므로써 웹 페이지 로딩 시간을 줄일 수 있다.

**헤더 압축**
\
HTTP 통신에서는 리소스와 그 리소스의 메타데이터인 헤더를 전달한다. HTTP1.1에서는 헤더가 항상 일반 텍스트로 전송되어 전송당 500~800 바이트의 오버헤드가 추가되었고, 쿠키를 사용하면 더 많은 오버헤드가 발생한다.

HTTP/2에서는 헤더로인한 오버헤드를 줄이기 위해 HPACK 압축 형식을 사용한다. HPACK 형식에서는 헤더를 정적 테이블과 동적 테이블로 나눈다. 정적 테이블에는 모든 연결에서 사용될 가능성이 있는 공용 HTTP 헤더 필드를 담아둔다. 동적 테이블에는 특정 연결에서 교환되는 값에 따라 갱신된다. 따라서 동적 테이블에 대해서는 Huffman 코딩을 사용하여 압축하고 정적 테이블에 대해서는 값을 인덱스로 대체하여 각 요청의 크기를 줄일 수 있다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/150757980-48b102c6-3cb3-497d-bd46-7909b3278ec7.png width=700>
</p>

## HTTPS

HTTP는 평문 통신이기 때문에 도청이 가능하며, 통신 상태를 확인하지 않기 때문에 위장이 가능하고 완전성을 증명할 수 없기 때문에 변조가 가능하다. 이러한 문제점을 해결하기 위해 HTTPS는 인터넷상에서 정보를 암호화하는 SSL(Secure Socket Layer) 프로토콜을 이용한다.

HTTPS의 기본적인 특징은 다음과 같다
- HTTPS의 기본 TCP/IP 포트는 443번이다.
- HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에 웹 상에서 정보를 암호화하는 SSL이나 TSL 프로토콜을 사용해 세션 데이터를 암호화한다.
- HTTPS의 SSL에서는 대칭키 암호화 방식과 공개키 암호화 방식을 모두 사용한다.

TSL 프로토콜은 SSL 프로토콜에서 발전한 것으로 두 프로토콜의 목적은 기밀성, 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것이다.

### HTTPS 커넥션
HTTPS의 커넥션 절차는 HTTP보다 조금 더 까다롭다. 먼저 443포트에 TCP 커넥션을 맺고, SSL 핸드셰이크를 통해 SSL을 초기화 한 후 클라이언트에서 암호화된 요청을 보낼 수 있다. SSL 핸드셰이크를 간략화 하면 아래와 같다.

1. 클라이언트가 암호 후보들을 보내고 인증서를 요구한다
2. 서버는 선택된 암호와 인증서를 보낸다
3. 클라이언트가 비밀정보를 보낸다. 클라이언트와 서버는 키를 만든다
4. 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해준다.

### 대칭키 암호화 방식

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/150938641-2f38b0ee-2f59-451c-b583-ac6e8b517f43.png width=700>
</p>

- 암호화에 사용되는 키와 복호화에 사용되는 키가 동일한 암호화 기법이다
- 대칭키 방식으로 암호화한 정보를 누군가에게 보낼 때, 암호키도 함께 보내야한다
- 암호키 자체는 암호화되지 않은 평문으로 타인에게 노출되면 보안에 매우 취약할 수 있다
- 키 전달 및 관리에 어려움이 있지만, 암호화 연산 속도가 빠르다는 장점이있다.

### 공개키 암호화 방식
대칭키 암호화 방식의 키 전달 취약점을 해결하기 위해 나온 방식이다. 암호화에 사용되는 키와 복호화에 사용되는 키를 분리했다. 따라서 비대칭키 암호화라고도 불린다.

자신이 가지고있는 고유한 암호키로만 복호화 할 수 있는 암호키를 대중에게 공개한다.

<p align=middle>
  <img src=https://user-images.githubusercontent.com/60502370/150938730-f3d07b54-a713-4980-a4b0-80db354761bc.png width=700>
</p>

- 사용자는 공개키와 개인키를 가지고있다. 공개키로 데이터를 암호화하면 개인키로 복호화할 수 있다.
- 사용자A는 사용자B의 공개키로 데이터를 암호화하여 전달한다
- 사용자B는 전달받은 데이터를 자신의 개인키로 복호화하여 데이터를 확인한다.
- 대칭키 암호화 방식의 키 전달 문제를 해결했지만, 복호화를 위해 복잡한 수학 연산을 수행하기 때문에 대칭키 방식에 비해 속도가 느리고 복잡하다


최근에는 대칭키와 공개키 암호화 방식을 모두 채택한 하이브리드 방식을 사용한다. 대칭키로 큰 데이터를 암호화하고 대칭키를 다시 공개키로 암호화하여 대상에게 전달하는 방식이다. 하지만 암호화에 사용하는 공개키가 특정 사용자의 공개키가 맞는 지 보장할 수 없다는 단점도 있는데 이를 해결하기 위해서 인증서를 도입한다.

### 디지털 인증서
디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고있다. 

HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름과 같은 정보를 담고 있다.


### SSL 동작 방식
1. 애플리케이션 서버를 운영하는 기업은 HTTPS 적용을 위해 공개키와 개인키를 만든다
2. 신뢰할 수 있는 CA 기업을 선택하고 인증서 생성을 요청한다
3. CA는 서버의 공개키, 암호화 방법등의 정보를 담은 인증서를 만들고 CA의 개인키로 암호화하여 서버에게 제공한다
4. 클라이언트가 SSL로 암호화된 페이지를 요청시 서버는 인증서를 전송한다.

### HTTPS의 통신 흐름 과정
1. 클라이언트가 SSL로 암호화된 페이지를 요청한다
2. 서버는 클라이언트에게 인증서를 전송한다
3. 클라이언트는 인증서가 CA로부터 서명된 것인지 판단한다. 브라우저는 CA리스트와 해당 CA의 공개키를 가지고있다. 공개키를 활용하여 인증서가 복호화 가능하다면 접속한 사이트가 CA에의해 검토되었다는 것을 의미한다. 이렇게 공개키가 데이터를 제공한 사람의 신원을 보장해주는 것을 전자 서명이라한다.
4. 클라이언트는 CA의 공개키를 이용해 인증서를 복호화하고 서버의 공개키를 획득한다
5. 클라이언트는 서버의 공개키를 사용해 랜덤 대칭 암호화키, 데이터 등을 암호화하여 서버로 전송한다
6. 서버는 자신의 개인키를 이용해 복호화하고 랜덤 대칭 암호화키, 데이터 등을 획득한다
7. 서버는 랜덤 대칭 암호화키로 클라리언트의 요청에 대한 응답을 암호화하여 전달한다
8. 클라이언트는 랜덤 대칭 암호화키를 이용해 복호화하고 데이터를 이용한다.

### HTTPS의 장단점
- 장점
  - 네트워크 상에서 열람 및 수정이 불가능하므로 안전하다
- 단점
  - 암호화를 하는 과정이 웹 서버에 부하를 준다
  - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 든다
  - HTTP에 비해서 느리다
  - 인터넷의 연결이 끊긴 경우 재인증 시간이 소요된다
    - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다
    - HTTPS는 소켓 자체에서 인증을 하기 때문에 인터넷이 끊기면 소켓도 끊겨 다시 HTTPS 인증이 필요하다

## RESTful API
API는 애플리케이션이나 디바이스가 서로 간에 연결하여 통신할 수 있는 방법을 정의한 규칙이다. REST(REpresentational State Transfer) API는 REST 디자인 원칙을 준수한 API이다. 이러한 이유로 REST API를 RESTful API라고도 한다.

### REST 구성
- 자원: HTTP URI
- 행위: HTTP METHOD
- 표현: JSON, XML

### REST 디자인 원칙
- Uniform Interface
  - 요청이 어디에서 오던지 동일한 리소스에 대한 모든 API 요청은 동일하게 응답해야한다. REST API는 동일한 데이터는 오직 하나의 URI를 가져야한다
- Client-Server Coupling
  - 클라이언트와 서버는 서로간 완전히 독립적이어야 한다
  - 서버와 클라이언트는 오직 HTTP 요청과 응답으로 통신해야한다
- Stateless
  - 각 요청에서 처리에 필요한 모든 데이터를 포함해야한다
  - 즉 REST API는 서버측에서 클라이언트의 상태를 관리하지 않는다
- Cacheable
  - 가급적 클라이언트 혹은 서버측에서 리소스를 캐싱할 수 있어야한다
  - 그리고 서버의 응답에 대해서 캐시 가능한 지 여부도 포함되어야한다.
- Layered Architecture
  - 클라이언트와 서버의 요청과 응답 중간에 다른 중개자가 있을 수 있다
  - 하지만 엔드 포인트에서는 이러한 사실을 몰라야한다
- Code on demand
  - 특정한 경우에는 응답에 실행 코드를 포함할 수도 있다.

### REST API 동작 방식

REST API는 HTTP 요청을 통해 통신함으로써 데이터를 생성, 조회, 삭제, 수정하는 등의 표준 데이터베이스 기능을 수행한다. GET을 통해 리소스를 조회하고, POST를 통해 리소스를 생성하고, PUT을 통해 리소스를 수정하고, DELETE를 통해 리소스를 삭제한다.

데이터는 JSON, HTML, XML 등으로 표현될 수 있다. 


