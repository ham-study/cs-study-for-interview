# Network
:open_book: Contents
- [Network](#network)
  - [OSI 7계층](#osi-7계층)
    - [1계층(피지컬 계층)](#1계층피지컬-계층)
    - [2계층(데이터 링크 계층)](#2계층데이터-링크-계층)
    - [3계층(네트워크 계층)](#3계층네트워크-계층)
    - [4계층(트랜스포트 계층)](#4계층트랜스포트-계층)
    - [5계층(세션 계층)](#5계층세션-계층)
    - [6계층(프레젠테이션 계층)](#6계층프레젠테이션-계층)
    - [7계층(애플리케이션 계층)](#7계층애플리케이션-계층)
    - [인캡슐레이션과 디캡슐레이션](#인캡슐레이션과-디캡슐레이션)
    - [TCP/IP](#tcpip)
  - [TCP와 UDP](#tcp와-udp)
  - [TCP](#tcp)
    - [패킷 순서, 응답 번호](#패킷-순서-응답-번호)
    - [윈도 사이즈와 슬라이딩 윈도](#윈도-사이즈와-슬라이딩-윈도)
    - [오류제어](#오류제어)
    - [흐름제어](#흐름제어)
    - [혼잡 제어](#혼잡-제어)
    - [3way-handshake](#3way-handshake)
    - [4way-handshake](#4way-handshake)
  - [UDP](#udp)
  - [IP 주소](#ip-주소)
    - [IP 주소 체계](#ip-주소-체계)
    - [클래스풀(Classful)](#클래스풀classful)
    - [클래스리스(Classless)](#클래스리스classless)
    - [서브넷 마스크](#서브넷-마스크)
    - [서브 네팅](#서브-네팅)
    - [공인IP와 사설IP](#공인ip와-사설ip)

---

## OSI 7계층


<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149924509-b280d9b2-f44a-4fe9-8ed1-3cc3f310c10d.png width=700>
</p>

- 5 ~ 7계층: 애플리케이션 계층, 상위 계층
  - 데이터를 잘 표현하는 역할
- 1 ~ 4계층: 데이터 플로 계층, 하위 계층
  - 데이터를 상대방에게 잘 전달하는 역할

### 1계층(피지컬 계층)
- 물리 계층으로 물리적 연결과 관련된 정보를 정의한다.
- 주로 전기 신호를 전달하는 데 초점이 맞추어져있다.
- 주요 장비로 허브, 리피터, 케이블, 커넥터, 트랜시버, 탭이 있다
- 주소의 개념이 없어 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 전송한다

### 2계층(데이터 링크 계층)
- 전기 신호를 모아 알아볼 수 있는 데이터 형태로 처리한다
- 주소 정보를 정의하고 정확한 주소로 통신이 이루어지는 데 초점이 맞추어져 있다
- 출발지와 도착지 정보를 확인하고 데이터를 처리하거나 폐기한다
- MAC 주소 체계를 가진다
- 주요 장비로 네트워크 인터페이스 카드와 스위치가 있다.
- 스위치는 MAC 주소를 보고 통신해야 할 포트를 지정해 보낸다

### 3계층(네트워크 계층)
- IP주소와 같은 논리적 주소가 정의된다.
- IP주소는 사용자가 환경에 맞게 변경해 사용할 수 있고, 네트워크 주소와 호스트 주소 부분으로 나뉜다
- 주요 장비로는 라우터가 있다.
  - 라우터는 IP 주소를 이해하고, IP 주소를 이용하여 최적의 경로를 찾아주고 그 경로로 패킷을 전송한다

### 4계층(트랜스포트 계층)
- 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다
  - 1 ~ 3계층은 데이터를 올바른 위치로 보내고 신호를 잘 만들어내는데 집중한다
- 중간에 패킷이 유실되거나 순서가 뒤바뀌는 것을 바로잡아준다
- 주요 장비로 로드 밸런서와 방화벽이 있다.
- 패킷에 보내는 순서를 명시한 것이 시퀀스 번호, 받는 순서를 나타낸 것이 ACK 번호이다.
- 장치 내의 많은 애플리케이션을 구분할 수 있도록 포트 번호를 사용한다

### 5계층(세션 계층)
- 양 끝단의 응용 프로세스가 연결을 성립하고 유지하고 종료하는 역할을 한다
- TCP/IP 세션을 만들고 없애는 책임을 진다
- 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다

### 6계층(프레젠테이션 계층)
- 애플리케이션이나 시스템 간 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다
- 응용 계층에서 데이터의 형식상 차이를 다루는 부담을 덜어준다
- MIME 인코딩, 암호화, 압축, 코드 변환과 같은 동작이 이루어진다

### 7계층(애플리케이션 계층)
- 애플리케이션 프로세스를 정의하고 애플리케이션 서비스를 수행한다.
- FTP, HTTP, SMTP, TELNET 같은 프로토콜이 있다

### 인캡슐레이션과 디캡슐레이션

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149927589-a1f2bb01-e6f6-425c-963d-d3c27ccb9fe4.png width=700>
</p>

- 인캡슐레이션: 데이터를 내보내는 과정
- 디캡슐레이션: 데이터를 받는 과정

송신측에서는 데이터가 계층을 내려가면서 헤더에 정보가 추가되고, 수신측에서는 계층을 올라가면서 각 계층에서 헤더 정보를 읽으며 벗겨낸다. 헤더에는 반드시 두 가지 정보는 포함되어야 한다.

- 현재 계층에서 정의하는 정보
- 상위 프로토콜 지시자
  - 2계층: MAC 주소
  - 3계층: IP 주소
  - 4계층: 포트 번호

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149928222-ac677753-683b-4f9a-a474-76fb7f80326f.png width=700>
</p>

인캡슐레이션 과정에서는 상위 프토콜지시자가 필요없지만, 디캡슐레이션 하면서 어떤 상위 프로토콜로 올려보내야 할지 결정하기위해 상위 프로토콜 지시자가 필요하다.

### TCP/IP

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149928544-2629dd3b-d53e-41f4-9b77-d72230120b12.png width=700>
</p>

TCP/IP는 이론보다 실용성에 중점을 프로토콜이다. OSI 레퍼런스 모델은 7계층으로 이루어진 반면에 TCP/IP 모델은 4계층으로 구분한다. 이는 데이터를 만드는 애플리케이션 부분과 데이터를 잘 전달하는 데 집중하는 하부 계층으로 구분하는 것이 목적이었다.

TCP/IP 프로토콜은 상위 3개의 계층을 하나로 묶고, 물리 계층과 데이터 링크 계층을 하나의 네트워크 계층으로 구분한다.

## TCP와 UDP

2, 3 계층은 주소를 사용하여 목적지를 정확하게 찾아가는 것이 목표였다. 4계층에서 동작하는 프로토콜은 목적지 단말 안에서 동작하는 여러 애플리케이션 중 통신해야 할 **목적지 프로세스**를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해서 원래 데이터를 만들어내기 위한 역할을 한다.

4계층의 프로토콜인 TCP와 UDP는 포트 번호를 통해 출발지와 목적지를 표현한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140883809-c054cc33-04ad-465c-9477-e250acaa555b.png width=700>
</p>

## TCP
TCP는 신뢰할 수 없는 공용망에서 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 패킷이 잘 전송되었는지 확인하는 기능이있다.

패킷에 번호(Sequence Number)를 부여하고 잘 전송되었는지에 대해 응답(Ackowledge Number)한다. 얼마나 보내야 수신자가 잘 처리할 수 있는지 전송 크기(Window Size)까지 고려해 전송한다.

### 패킷 순서, 응답 번호
TCP는 분할된 패킷을 수신측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다. 패킷의 순서를 시퀀스 번호, 응답 번호를 부여하는 것을 ACK라고한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140884669-6524e2de-e569-4e73-afdd-67cfa68e2954.png width=500>
</p>

1. 출발지에서 시퀀스 번호를 0으로 보낸다
2. 수신 측에서 0번 패킷을 잘 받았다는 의미로 응답 번호(ACK)에 1을 적어 응답한다.
   - 수신 측에서는 자신이 처음 보내는 패킷이므로 자신 패킷 시퀀스 번호는 0번을 부여한다.
3. 송신 측은 시퀀스 번호를 1로, ACK는 0번 패킷을 잘 받았다는 의미로 1로 부여해 전송한다.

### 윈도 사이즈와 슬라이딩 윈도
송수산자간 패킷을 주고 받을 때 거리가 멀리 떨어져있으면 왕복 지연시간이 늘어나므로 응답을 기다리는 시간이 지연된다.

따라서 한 번에 많은 패킷을 보내고 한꺼번에 응답을 받아야한다. 한 번에 받을 수 있는 데이터의 크기를 윈도 사이즈라고 하고 네트워크 상황에 따라 윈도 사이즈를 조절하는 것을 슬라이딩 윈도라고 한다.

### 오류제어
ARQ(Automatic Repeat Request) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다.

- Stop and Wait ARQ: 송신측에서 패킷을 전송하고 NAK를 받을 경우 재전송하는 기법이다.
  - 데이터나 ACK를 유실했을 경우 타임 아웃이 발생해 재전송된다.

- Go-Back-n ARQ: 전송된 프레임이 손실되거나 유실되어 타임 아웃이 발생한 경우 마지막으로 확인된 패킷 이후의 전체 패킷을 재전송한다

- Selective-Reject ARQ: 손실되거나 유실된 프레임만 재전송하는 기법이다. 프레임의 재정렬을 수행해야하므로 별도의 버퍼가 필요하다.

### 흐름제어
송신측과 수신측 사이의 데이터 처리 속도 차이를 제어하기 위한 기법이다.

- 정지-대기: 매번 전송한 패킷에 대한 응답을 받아야 다음 패킷을 전송할 수 있다
  
- 슬리이딩 윈도우: 수신측에서 설정한 윈도우 크기만큼 확인 응답 없이 한 번에 여러 패킷을 전송할 수 있다.

### 혼잡 제어
- **Addictive Increase**
\
전송한 패킷에 대해서 ACK를 받은 경우 윈도우 사이즈를 1씩 증가시키는 방법

- **Multiplicative Decrease**
\
ACK를 받지 못한 경우 윈도우 사이즈를 절반으로 줄이는 방법

- **Slow start**
\
윈도우 사이즈를 1로 시작한다. 전송에 성공한 패킷의 수 만큼 윈도우 사이즈를 증가시키는 방법이다. 즉 윈도우 크기가 1, 2, 4, 8 , 16, ... 2의 지수승 만큼증가한다.
\
그리고 네트워크 혼잡이 감지된 경우 그때 윈도우 사이즈를 Threshold로 기억하고 윈도우 사이즈를 1로 줄인다. 다시 윈도우를 2의 지수만큼 증가하다가 Threshold의 절반 크기가 된 경우 윈도우 사이즈를 1씩 늘린다.

- **Fast Retransmit**
\
패킷 하나가 중간에 유실된 경우 수신측은 유실된 패킷의 다음 시퀀스를 ACK에 실어 보낸다. 수신측은 유실된 패킷의 시퀀스를 중복적으로 보내고 시퀀스가 3번이 중복되면 송신측은 해당 패킷을 재전송한다.

- **Fast Recovery**
\
네트워크 혼잡이 감지되면 윈도우 사이즈를 1이 아닌 절반으로 줄이고 선형증가하는 방법이다. 이 정책은 처음 혼잡 상황을 겪은 뒤에는 계속 선형증가한다.


### 3way-handshake

TCP는 유실없는 안전한 통신을 위해 사전 연결 작업을 수행한다. 패킷 네트워크에서는 동시에 많은 상대방과 통신하므로 정확한 통신을 위해서 통신 전, 각 통신에 필요한 리소스를 미리 확보하는 것이 중요하다. 3번의 패킷 교환을 통해 통신을 준비하여 3way handshake라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140899565-9a7169dd-74db-4219-a656-996bd5529cdd.png width=500>
</p>

1. 송신자가 SYN 필드를 1로 표기해 패킷을 전송한다
   - 이때 자신이 사용할 패킷의 첫 시퀀스 번호를 적어보낸다.
   - 포트 번호는 유한 범위내에서 설정되므로 시퀀스 번호를 순차적으로 설정할 경우 이전 통신의 패킷으로 오해할 수 있기 때문이다.

2. 수신자는 ACK와 SYN 필드를 1로 표기해 응답한다
   - 자신이 보내는 첫 패킷이므로 SYN을 함께 보낸다
   - 연결 신호를 허락하는 의미로 전달한다.

3. 송신자가 ACK를 1로 표기해 전달한다.

### 4way-handshake
TCP는 세션을 안전하게 종료하기 위해 4개의 패킷을 교환한다. 이를 4way-handshake라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149465776-7bdece24-58b2-4fdc-9cc4-25810c9d8999.png width=500>
</p>

1. 송산자가 연결을 종료하기 위해 FIN에 1을 부여하여 패킷을 전송한다
2. 수신자는 요청 확인의 의미로 ACK에 1을 표기하여 패킷을 전송한다.
3. 수신자는 연결 종료 준비를 완료한 후 FIN에 1을 표기하여 송신자에게 패킷을 전송한다
4. 송신자는 연결 종료 확인의 의미로 ACK에 1을 표기하여 패킷을 전송한다
5. 송신자는 아직 도착하지 못한 패킷이 있을 경우를 대비해 기다렸다가 연결을 종료한다.

## UDP
UDP는 4계층에서 가져야할 특징을 거의 가지고 있지 않다. UDP는 신뢰성있는 데이터의 전송을 보장하지 않는다. 손상되거나 유실된 데이터에 대한 조치를 하지 않으므로 헤더가 가볍다.

UDP는 실시간 스트리밍과 같이 시간에 민감한 애플리케이션을 사용하거나 사내 방송과 같은 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 주로 사용된다. 보통 음성이나 동영상과 같은 데이터를 전송할 때 사용된다. 30 프레임의 동영상에 1 프레임이 빠져도 크게 이상한점을 느끼지 못하기 때문이다.

UDP는 TCP와 달리 연결을 사전에 확립하는 작업이 없다. 대신 UDP에서 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용한다. 따라서 연결 확립은 TCP로 하고 애플리케이션끼리 모든 준비를 마친 후 실제 데이터만 UDP를 사용한다.

같은 동영상 스트리밍이더라도 넷플릭스처럼 시간에 민감하지 않는 단일 시청자를 위한 연결은 TCP를 사용한다. 원활한 시청을 위해 미리 데이터를 받아 놓고 네트워크에 문제가 생기더라도 동영상이 끊기지 않도록 캐시에 저장한다. 실시간 화상 회의와 같은 시간에 민감한 데이터에서는 UDP를 사용한다.

## IP 주소

3계층의 논리적 주소이다. IP 주소를 포함한 3계층의 주소는 다음과 같은 특징을 가진다.
- 사용자가 변경이 가능한 주소이다.
- 주소에 레벨이 있다. 그룹을 의미하는 네트워크 주소와 호스트 주소로 나뉜다.

### IP 주소 체계
흔히 사용하는 IP주소는 32비트 주소인 IPv4이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140734693-6256d764-3fb6-4985-be96-0c093ab6d774.png width=500>
</p>

IP는 v4, v6 두 체계가 있고 v6은 128비트 주소 체계이다. MAC 주소가 16진수로 표기된 것과 다르게 IP주소는 10진수로 표기한다.

- 네트워크 주소: 호스트들을 모은 네트워크를 지징하는 주소이다. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라 한다.
- 호스트 주소: 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소이다.

IP주소는 MAC주소가 고정적인 크기로 분할되는 것과 다르게 유동적으로 네트워크와 호스트 주소가 분할된다.

### 클래스풀(Classful)
**네트워크 주소 범위를 클래스 별로 설정**하여 각 조직에 배분하는 방식을 클래풀이라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140877655-2454a524-9dfc-479b-9e01-fc2c6d242fba.png width=500>
</p>

- A클래스: 네트워크 주소 1옥텟 + 호스트 주소 3옥텟
- B클래스: 네트워크 주소 2옥텟 + 호스트 주소 2옥텟
- C클래스: 네트워크 주소 3옥텟 + 호스트 주소 1옥텟

클래스 기반의 IP주소 체계에서는 옥텟의 위치를 통해 클래스를 구분할 수 있다. 

### 클래스리스(Classless)
클래스풀 IP 주소는 네트워크 주소와 호스트 주소를 구분 짓는 구분자인 서브넷 마스크가 필요하지 않다. 맨 앞자리 주소만 보고 해당 주소가 어느 클래스에 위치한 지 알 수 있기 때문이다.

하지만 인터넷이 상용화되면서 클래스풀 주소 체계는 급속도로 늘어나는 IP 주소에 대한 요구를 감당할 수 없었고, 다음과 같은 문제점들이 있었다.

- 하나의 네트워크에서 IP를 사용하면 다른 네트워크에서 그 IP를 사용하지 못했다
- IPv4의 크기가 작았다.
- 상위 클래스(A class)를 할당 받은 조직이 주소를 제대로 활용하지 않았다.

이러한 문제점의 해결책으로 다음 3가지가 제안되었다.
- 단기: 클래스 리스기반 주소체계
- 중기: NAT와 사설 IP 주소
- 장기: IPv6


클래스의 개념을 버린 클래스리스기반 주소체계는 맨 앞의 숫자를 통해 네트워크 주소와 호스트 주소를 구분할 수 없었다. 클래스리스 네트워크에서는 별도의 구분자를 사용하는데 이를 **서브넷 마스크**라한다.

### 서브넷 마스크
서브넷 마스크는 IP 주소와 네트워크 주소를 구분할 때 사용하는 구분자이다. 2진수 숫자 1은 네트워크 주소, 0은 호스트 주소로 표시한다.

클래스를 서브넷 마스크로 나타내면 아래와 같다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879111-f3f2bb02-595a-4880-9965-6bb7e377794c.png width=500>
</p>

IP 주소를 서브넷 마스크와 `& 연산`하면 네트워크 주소를 확인할 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879606-770c5aee-994d-4e6a-aabb-db2321c084c1.png width=500>
</p>

### 서브 네팅
네트워크-호스트 구분 기준을 사용자가 정해, 원래 클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것을 서브 네팅이라한다.

부여된 주소를 다시 잘라 사용해 서브네팅이라 부르는데 현대 클래스리스 네트워크의 가장 큰 특징이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140881269-85bfe37f-e68b-4615-8512-b49420378e1a.png width=500>
</p>

### 공인IP와 사설IP

인터넷에 접속하기 위해서는 IP 주소가 필요하고 이 IP는 전세계에서 유일해야 하는 식별자이다. 이러한 IP 주소를 **공인IP**라고 한다.

인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 공인IP 주소를 할당 받지 않고도 네트워크를 구축할 수 있다. 이때 사용하는 주소를 **사설IP 주소**라고 한다.

주로 인터넷에 접속하지 않거나 NAT(Network Address Translation)기술을 사용할 경우 사설IP 주소를 사용한다. 공유기가 대표적인 NAT 장비 중 하나이다.

NAT 기술을 사용하더라도 다른 사용자에게 이미 부여된 IP를 사설 IP 주소로 사용하면 안된다. 
