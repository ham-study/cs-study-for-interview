# Network
:open_book: Contents
- [Network](#network)
  - [OSI 7계층](#osi-7계층)
    - [1계층(피지컬 계층)](#1계층피지컬-계층)
    - [2계층(데이터 링크 계층)](#2계층데이터-링크-계층)
    - [3계층(네트워크 계층)](#3계층네트워크-계층)
    - [4계층(트랜스포트 계층)](#4계층트랜스포트-계층)
    - [5계층(세션 계층)](#5계층세션-계층)
    - [6계층(프레젠테이션 계층)](#6계층프레젠테이션-계층)
    - [7계층(애플리케이션 계층)](#7계층애플리케이션-계층)
    - [인캡슐레이션과 디캡슐레이션](#인캡슐레이션과-디캡슐레이션)
    - [TCP/IP](#tcpip)
  - [TCP와 UDP](#tcp와-udp)
  - [TCP](#tcp)
    - [패킷 순서, 응답 번호](#패킷-순서-응답-번호)
    - [윈도 사이즈와 슬라이딩 윈도](#윈도-사이즈와-슬라이딩-윈도)
    - [오류제어](#오류제어)
    - [흐름제어](#흐름제어)
    - [혼잡 제어](#혼잡-제어)
    - [3way-handshake](#3way-handshake)
    - [4way-handshake](#4way-handshake)
  - [UDP](#udp)
  - [IP 주소](#ip-주소)
    - [IP 주소 체계](#ip-주소-체계)
    - [클래스풀(Classful)](#클래스풀classful)
    - [클래스리스(Classless)](#클래스리스classless)
    - [서브넷 마스크](#서브넷-마스크)
    - [서브 네팅](#서브-네팅)
    - [공인IP와 사설IP](#공인ip와-사설ip)
  - [IPv4 VS IPv6](#ipv4-vs-ipv6)
    - [IPv4](#ipv4)
    - [IPv6](#ipv6)
  - [HTTP 개요](#http-개요)
    - [HTTP 문제점](#http-문제점)
  - [HTTP Method](#http-method)
    - [GET](#get)
    - [POST](#post)
    - [PUT](#put)
    - [DELETE](#delete)
    - [PATCH](#patch)
    - [멱등성](#멱등성)
  - [HTTP Status Code](#http-status-code)
    - [1XX](#1xx)
    - [2XX](#2xx)
    - [3XX](#3xx)
    - [4XX](#4xx)
    - [5XX](#5xx)

---

## OSI 7계층


<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149924509-b280d9b2-f44a-4fe9-8ed1-3cc3f310c10d.png width=700>
</p>

- 5 ~ 7계층: 애플리케이션 계층, 상위 계층
  - 데이터를 잘 표현하는 역할
- 1 ~ 4계층: 데이터 플로 계층, 하위 계층
  - 데이터를 상대방에게 잘 전달하는 역할

### 1계층(피지컬 계층)
- 물리 계층으로 물리적 연결과 관련된 정보를 정의한다.
- 주로 전기 신호를 전달하는 데 초점이 맞추어져있다.
- 주요 장비로 허브, 리피터, 케이블, 커넥터, 트랜시버, 탭이 있다
- 주소의 개념이 없어 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 전송한다

### 2계층(데이터 링크 계층)
- 전기 신호를 모아 알아볼 수 있는 데이터 형태로 처리한다
- 주소 정보를 정의하고 정확한 주소로 통신이 이루어지는 데 초점이 맞추어져 있다
- 출발지와 도착지 정보를 확인하고 데이터를 처리하거나 폐기한다
- MAC 주소 체계를 가진다
- 주요 장비로 네트워크 인터페이스 카드와 스위치가 있다.
- 스위치는 MAC 주소를 보고 통신해야 할 포트를 지정해 보낸다

### 3계층(네트워크 계층)
- IP주소와 같은 논리적 주소가 정의된다.
- IP주소는 사용자가 환경에 맞게 변경해 사용할 수 있고, 네트워크 주소와 호스트 주소 부분으로 나뉜다
- 주요 장비로는 라우터가 있다.
  - 라우터는 IP 주소를 이해하고, IP 주소를 이용하여 최적의 경로를 찾아주고 그 경로로 패킷을 전송한다

### 4계층(트랜스포트 계층)
- 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다
  - 1 ~ 3계층은 데이터를 올바른 위치로 보내고 신호를 잘 만들어내는데 집중한다
- 중간에 패킷이 유실되거나 순서가 뒤바뀌는 것을 바로잡아준다
- 주요 장비로 로드 밸런서와 방화벽이 있다.
- 패킷에 보내는 순서를 명시한 것이 시퀀스 번호, 받는 순서를 나타낸 것이 ACK 번호이다.
- 장치 내의 많은 애플리케이션을 구분할 수 있도록 포트 번호를 사용한다

### 5계층(세션 계층)
- 양 끝단의 응용 프로세스가 연결을 성립하고 유지하고 종료하는 역할을 한다
- TCP/IP 세션을 만들고 없애는 책임을 진다
- 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다

### 6계층(프레젠테이션 계층)
- 애플리케이션이나 시스템 간 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다
- 응용 계층에서 데이터의 형식상 차이를 다루는 부담을 덜어준다
- MIME 인코딩, 암호화, 압축, 코드 변환과 같은 동작이 이루어진다

### 7계층(애플리케이션 계층)
- 애플리케이션 프로세스를 정의하고 애플리케이션 서비스를 수행한다.
- FTP, HTTP, SMTP, TELNET 같은 프로토콜이 있다

### 인캡슐레이션과 디캡슐레이션

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149927589-a1f2bb01-e6f6-425c-963d-d3c27ccb9fe4.png width=700>
</p>

- 인캡슐레이션: 데이터를 내보내는 과정
- 디캡슐레이션: 데이터를 받는 과정

송신측에서는 데이터가 계층을 내려가면서 헤더에 정보가 추가되고, 수신측에서는 계층을 올라가면서 각 계층에서 헤더 정보를 읽으며 벗겨낸다. 헤더에는 반드시 두 가지 정보는 포함되어야 한다.

- 현재 계층에서 정의하는 정보
- 상위 프로토콜 지시자
  - 2계층: MAC 주소
  - 3계층: IP 주소
  - 4계층: 포트 번호

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149928222-ac677753-683b-4f9a-a474-76fb7f80326f.png width=700>
</p>

인캡슐레이션 과정에서는 상위 프토콜지시자가 필요없지만, 디캡슐레이션 하면서 어떤 상위 프로토콜로 올려보내야 할지 결정하기위해 상위 프로토콜 지시자가 필요하다.

### TCP/IP

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149928544-2629dd3b-d53e-41f4-9b77-d72230120b12.png width=700>
</p>

TCP/IP는 이론보다 실용성에 중점을 프로토콜이다. OSI 레퍼런스 모델은 7계층으로 이루어진 반면에 TCP/IP 모델은 4계층으로 구분한다. 이는 데이터를 만드는 애플리케이션 부분과 데이터를 잘 전달하는 데 집중하는 하부 계층으로 구분하는 것이 목적이었다.

TCP/IP 프로토콜은 상위 3개의 계층을 하나로 묶고, 물리 계층과 데이터 링크 계층을 하나의 네트워크 계층으로 구분한다.

## TCP와 UDP

2, 3 계층은 주소를 사용하여 목적지를 정확하게 찾아가는 것이 목표였다. 4계층에서 동작하는 프로토콜은 목적지 단말 안에서 동작하는 여러 애플리케이션 중 통신해야 할 **목적지 프로세스**를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해서 원래 데이터를 만들어내기 위한 역할을 한다.

4계층의 프로토콜인 TCP와 UDP는 포트 번호를 통해 출발지와 목적지를 표현한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140883809-c054cc33-04ad-465c-9477-e250acaa555b.png width=700>
</p>

## TCP
TCP는 신뢰할 수 없는 공용망에서 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 패킷이 잘 전송되었는지 확인하는 기능이있다.

패킷에 번호(Sequence Number)를 부여하고 잘 전송되었는지에 대해 응답(Ackowledge Number)한다. 얼마나 보내야 수신자가 잘 처리할 수 있는지 전송 크기(Window Size)까지 고려해 전송한다.

### 패킷 순서, 응답 번호
TCP는 분할된 패킷을 수신측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다. 패킷의 순서를 시퀀스 번호, 응답 번호를 부여하는 것을 ACK라고한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140884669-6524e2de-e569-4e73-afdd-67cfa68e2954.png width=500>
</p>

1. 출발지에서 시퀀스 번호를 0으로 보낸다
2. 수신 측에서 0번 패킷을 잘 받았다는 의미로 응답 번호(ACK)에 1을 적어 응답한다.
   - 수신 측에서는 자신이 처음 보내는 패킷이므로 자신 패킷 시퀀스 번호는 0번을 부여한다.
3. 송신 측은 시퀀스 번호를 1로, ACK는 0번 패킷을 잘 받았다는 의미로 1로 부여해 전송한다.

### 윈도 사이즈와 슬라이딩 윈도
송수산자간 패킷을 주고 받을 때 거리가 멀리 떨어져있으면 왕복 지연시간이 늘어나므로 응답을 기다리는 시간이 지연된다.

따라서 한 번에 많은 패킷을 보내고 한꺼번에 응답을 받아야한다. 한 번에 받을 수 있는 데이터의 크기를 윈도 사이즈라고 하고 네트워크 상황에 따라 윈도 사이즈를 조절하는 것을 슬라이딩 윈도라고 한다.

### 오류제어
ARQ(Automatic Repeat Request) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다.

- Stop and Wait ARQ: 송신측에서 패킷을 전송하고 NAK를 받을 경우 재전송하는 기법이다.
  - 데이터나 ACK를 유실했을 경우 타임 아웃이 발생해 재전송된다.

- Go-Back-n ARQ: 전송된 프레임이 손실되거나 유실되어 타임 아웃이 발생한 경우 마지막으로 확인된 패킷 이후의 전체 패킷을 재전송한다

- Selective-Reject ARQ: 손실되거나 유실된 프레임만 재전송하는 기법이다. 프레임의 재정렬을 수행해야하므로 별도의 버퍼가 필요하다.

### 흐름제어
송신측과 수신측 사이의 데이터 처리 속도 차이를 제어하기 위한 기법이다.

- 정지-대기: 매번 전송한 패킷에 대한 응답을 받아야 다음 패킷을 전송할 수 있다
  
- 슬리이딩 윈도우: 수신측에서 설정한 윈도우 크기만큼 확인 응답 없이 한 번에 여러 패킷을 전송할 수 있다.

### 혼잡 제어
- **Addictive Increase**
\
전송한 패킷에 대해서 ACK를 받은 경우 윈도우 사이즈를 1씩 증가시키는 방법

- **Multiplicative Decrease**
\
ACK를 받지 못한 경우 윈도우 사이즈를 절반으로 줄이는 방법

- **Slow start**
\
윈도우 사이즈를 1로 시작한다. 전송에 성공한 패킷의 수 만큼 윈도우 사이즈를 증가시키는 방법이다. 즉 윈도우 크기가 1, 2, 4, 8 , 16, ... 2의 지수승 만큼증가한다.
\
그리고 네트워크 혼잡이 감지된 경우 그때 윈도우 사이즈를 Threshold로 기억하고 윈도우 사이즈를 1로 줄인다. 다시 윈도우를 2의 지수만큼 증가하다가 Threshold의 절반 크기가 된 경우 윈도우 사이즈를 1씩 늘린다.

- **Fast Retransmit**
\
패킷 하나가 중간에 유실된 경우 수신측은 유실된 패킷의 다음 시퀀스를 ACK에 실어 보낸다. 수신측은 유실된 패킷의 시퀀스를 중복적으로 보내고 시퀀스가 3번이 중복되면 송신측은 해당 패킷을 재전송한다.

- **Fast Recovery**
\
네트워크 혼잡이 감지되면 윈도우 사이즈를 1이 아닌 절반으로 줄이고 선형증가하는 방법이다. 이 정책은 처음 혼잡 상황을 겪은 뒤에는 계속 선형증가한다.


### 3way-handshake

TCP는 유실없는 안전한 통신을 위해 사전 연결 작업을 수행한다. 패킷 네트워크에서는 동시에 많은 상대방과 통신하므로 정확한 통신을 위해서 통신 전, 각 통신에 필요한 리소스를 미리 확보하는 것이 중요하다. 3번의 패킷 교환을 통해 통신을 준비하여 3way handshake라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140899565-9a7169dd-74db-4219-a656-996bd5529cdd.png width=500>
</p>

1. 송신자가 SYN 필드를 1로 표기해 패킷을 전송한다
   - 이때 자신이 사용할 패킷의 첫 시퀀스 번호를 적어보낸다.
   - 포트 번호는 유한 범위내에서 설정되므로 시퀀스 번호를 순차적으로 설정할 경우 이전 통신의 패킷으로 오해할 수 있기 때문이다.

2. 수신자는 ACK와 SYN 필드를 1로 표기해 응답한다
   - 자신이 보내는 첫 패킷이므로 SYN을 함께 보낸다
   - 연결 신호를 허락하는 의미로 전달한다.

3. 송신자가 ACK를 1로 표기해 전달한다.

### 4way-handshake
TCP는 세션을 안전하게 종료하기 위해 4개의 패킷을 교환한다. 이를 4way-handshake라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149465776-7bdece24-58b2-4fdc-9cc4-25810c9d8999.png width=500>
</p>

1. 송산자가 연결을 종료하기 위해 FIN에 1을 부여하여 패킷을 전송한다
2. 수신자는 요청 확인의 의미로 ACK에 1을 표기하여 패킷을 전송한다.
3. 수신자는 연결 종료 준비를 완료한 후 FIN에 1을 표기하여 송신자에게 패킷을 전송한다
4. 송신자는 연결 종료 확인의 의미로 ACK에 1을 표기하여 패킷을 전송한다
5. 송신자는 아직 도착하지 못한 패킷이 있을 경우를 대비해 기다렸다가 연결을 종료한다.

## UDP
UDP는 4계층에서 가져야할 특징을 거의 가지고 있지 않다. UDP는 신뢰성있는 데이터의 전송을 보장하지 않는다. 손상되거나 유실된 데이터에 대한 조치를 하지 않으므로 헤더가 가볍다.

UDP는 실시간 스트리밍과 같이 시간에 민감한 애플리케이션을 사용하거나 사내 방송과 같은 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 주로 사용된다. 보통 음성이나 동영상과 같은 데이터를 전송할 때 사용된다. 30 프레임의 동영상에 1 프레임이 빠져도 크게 이상한점을 느끼지 못하기 때문이다.

UDP는 TCP와 달리 연결을 사전에 확립하는 작업이 없다. 대신 UDP에서 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용한다. 따라서 연결 확립은 TCP로 하고 애플리케이션끼리 모든 준비를 마친 후 실제 데이터만 UDP를 사용한다.

같은 동영상 스트리밍이더라도 넷플릭스처럼 시간에 민감하지 않는 단일 시청자를 위한 연결은 TCP를 사용한다. 원활한 시청을 위해 미리 데이터를 받아 놓고 네트워크에 문제가 생기더라도 동영상이 끊기지 않도록 캐시에 저장한다. 실시간 화상 회의와 같은 시간에 민감한 데이터에서는 UDP를 사용한다.

## IP 주소

3계층의 논리적 주소이다. IP 주소를 포함한 3계층의 주소는 다음과 같은 특징을 가진다.
- 사용자가 변경이 가능한 주소이다.
- 주소에 레벨이 있다. 그룹을 의미하는 네트워크 주소와 호스트 주소로 나뉜다.

### IP 주소 체계
흔히 사용하는 IP주소는 32비트 주소인 IPv4이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140734693-6256d764-3fb6-4985-be96-0c093ab6d774.png width=500>
</p>

IP는 v4, v6 두 체계가 있고 v6은 128비트 주소 체계이다. MAC 주소가 16진수로 표기된 것과 다르게 IP주소는 10진수로 표기한다.

- 네트워크 주소: 호스트들을 모은 네트워크를 지징하는 주소이다. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라 한다.
- 호스트 주소: 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소이다.

IP주소는 MAC주소가 고정적인 크기로 분할되는 것과 다르게 유동적으로 네트워크와 호스트 주소가 분할된다.

### 클래스풀(Classful)
**네트워크 주소 범위를 클래스 별로 설정**하여 각 조직에 배분하는 방식을 클래풀이라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140877655-2454a524-9dfc-479b-9e01-fc2c6d242fba.png width=500>
</p>

- A클래스: 네트워크 주소 1옥텟 + 호스트 주소 3옥텟
- B클래스: 네트워크 주소 2옥텟 + 호스트 주소 2옥텟
- C클래스: 네트워크 주소 3옥텟 + 호스트 주소 1옥텟

클래스 기반의 IP주소 체계에서는 옥텟의 위치를 통해 클래스를 구분할 수 있다. 

### 클래스리스(Classless)
클래스풀 IP 주소는 네트워크 주소와 호스트 주소를 구분 짓는 구분자인 서브넷 마스크가 필요하지 않다. 맨 앞자리 주소만 보고 해당 주소가 어느 클래스에 위치한 지 알 수 있기 때문이다.

하지만 인터넷이 상용화되면서 클래스풀 주소 체계는 급속도로 늘어나는 IP 주소에 대한 요구를 감당할 수 없었고, 다음과 같은 문제점들이 있었다.

- 하나의 네트워크에서 IP를 사용하면 다른 네트워크에서 그 IP를 사용하지 못했다
- IPv4의 크기가 작았다.
- 상위 클래스(A class)를 할당 받은 조직이 주소를 제대로 활용하지 않았다.

이러한 문제점의 해결책으로 다음 3가지가 제안되었다.
- 단기: 클래스 리스기반 주소체계
- 중기: NAT와 사설 IP 주소
- 장기: IPv6


클래스의 개념을 버린 클래스리스기반 주소체계는 맨 앞의 숫자를 통해 네트워크 주소와 호스트 주소를 구분할 수 없었다. 클래스리스 네트워크에서는 별도의 구분자를 사용하는데 이를 **서브넷 마스크**라한다.

### 서브넷 마스크
서브넷 마스크는 IP 주소와 네트워크 주소를 구분할 때 사용하는 구분자이다. 2진수 숫자 1은 네트워크 주소, 0은 호스트 주소로 표시한다.

클래스를 서브넷 마스크로 나타내면 아래와 같다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879111-f3f2bb02-595a-4880-9965-6bb7e377794c.png width=500>
</p>

IP 주소를 서브넷 마스크와 `& 연산`하면 네트워크 주소를 확인할 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879606-770c5aee-994d-4e6a-aabb-db2321c084c1.png width=500>
</p>

### 서브 네팅
네트워크-호스트 구분 기준을 사용자가 정해, 원래 클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것을 서브 네팅이라한다.

부여된 주소를 다시 잘라 사용해 서브네팅이라 부르는데 현대 클래스리스 네트워크의 가장 큰 특징이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140881269-85bfe37f-e68b-4615-8512-b49420378e1a.png width=500>
</p>

### 공인IP와 사설IP

인터넷에 접속하기 위해서는 IP 주소가 필요하고 이 IP는 전세계에서 유일해야 하는 식별자이다. 이러한 IP 주소를 **공인IP**라고 한다.

인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 공인IP 주소를 할당 받지 않고도 네트워크를 구축할 수 있다. 이때 사용하는 주소를 **사설IP 주소**라고 한다.

주로 인터넷에 접속하지 않거나 NAT(Network Address Translation)기술을 사용할 경우 사설IP 주소를 사용한다. 공유기가 대표적인 NAT 장비 중 하나이다.

NAT 기술을 사용하더라도 다른 사용자에게 이미 부여된 IP를 사설 IP 주소로 사용하면 안된다. 

## IPv4 VS IPv6
### IPv4
가장 대중적인 3계층의 프로토콜이다. 패킷 전송과정에서 오류가 발생할 수 있고, 전송된 패킷 간에 순서가 보장되지 않는다. 즉, 비신뢰적 비연결지향형 프로토콜이다. 데이터의 전송에만 초점을 두고 있으며, IPv4에서 패킷을 데이터그램이라고도 한다.

### IPv6
IPv4보다 더 많은 주소를 표현할 수 있고 전송 효율을 높인 인터넷 프로토콜이다. IPv4가 32비트 주소 체계인 반면, IPv6는 128비트 주소 체계이다. Base Header와 Extension Header를 분리함으로써 라우터간 전송 과정에서 불필요한 과정을 줄여 전송 효율을 높였다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/150665998-3969e0af-4984-432d-b0e4-02eec09ea538.png width=500>
</p>

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/150666030-2cf57d64-31d7-43ec-9f47-6e56ef7e2308.png width=500>
</p>

Source Routing에 거쳐야할 라우터들을 리스트 형태로 저장한다

IPv6에서는 Destination IP Address가 아닌 경우 Base header만 참조하므로 IPv4와 다르게 단편화, 헤더 오류 탐지 등의 과정이 생략되면서 전송과정이 빨라졌다.

## HTTP 개요
HTTP(HyperText Transfer Protocol)은 HTML과 같은 문서를 웹 상에서 클라이언트와 서버간 요청/응답(Request/Response)으로 주고 받을 수 있는 프로토콜이다.

- 주로 HTML 문서를 주고 받는데 사용한다.
- TCP와 UDP를 사용하며, 80번 포트를 사용한다.
- 비연결(Connectionless) 프로토콜이다.
- 무상태(Stateless)프로토콜이다.

**비연결(Connectionless)**
클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊어진다.

**무상태(Stateless)**
연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

**HyperText**
참조를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트

### HTTP 문제점

- HTTP는 평문 통신이기 때문에 도청이 가능하다.
- 통신 상태를 확인하지 않기 때문에 위장이 가능하다.
- 완전성을 증명할 수 없기 때문에 변조가 가능하다.

## HTTP Method

### GET
- 정보를 조회(SELECT)하기 위한 메서드이다. CRUD를 예로들 경우 R에 해당한다.
- URL의 끝에 '?'가 붙고, 요청 정보가 'key=value' 형태의 쌍을 이루어 '? 뒤에 붙어 서버로 전송된다.
- 요청 정보가 여러 개일 경우 '&'로 구분한다.

**특징**

- URL에 요청 정보를 붙여서 전송한다.
- URL에 정보를 이어 붙이기 때문에 길이의 제한이 있다.
- 요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다. 이로 인해 POST보다 보안에 취약하다.
- HTTP 패킷에 body는 비어 있는 상태로 전송한다.
- POST 방식 보다 빠르다. GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐시된다.

### POST
- 서버의 값이나 상태를 바꾸기위한 용도의 메서드이다. CRUD 관점에서 C에 해당한다.
- 단 Update나 Delete에도 사용이 가능하다.
- 요청 정보를 HTTP 패킷 안의 body에 숨겨서 서버로 전송한다.
- Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다.

**특징**

- Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다
- 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
- GET 방식 보다 안전하다.

### PUT
- 새로운 리소스를 생성하거나, 대상 리소스를 나타내는 데이터를 수정하는데 사용한다.
- CRUP 관점에서 U에 해당한다.
- 자원의 식별자를 미리 알고 있어야한다.
- 자원의 식별자가 존재하는 지는 영향이 없고, 자원이 존재하는 경우는 대체하고, 존재하지 않는 경우는 새로 생성한다.

**POST와 차이**

- POST는 Request 메세지에 포함된 엔티티를 이용해 새로운 자원을 생성한다.
- PUT은 Request 메세지에 함께 넘어온 식별자를 자원으로 만든다.
- POST는 동일한 요청이 2번 전달되면, 2개의 자원을 생성한다.
- PUT은 동일한 요청이 2번 전달되면, 첫 번째 요청에서 자원이 존재하지 않으면 새로 생성하고, 두 번째 요청에서는 자원이 이미 존재하기 때문에 대체한다.

### DELETE

- 지정한 리소스를 삭제한다.
- CRUD 관점에서 D에 해당한다.
- 어느 자원을 삭제할 지 URL에 드러난다.

### PATCH

- 리소스의 부분을 수정하는데 사용한다. 의미론적으로 U에 해당한다.

**PUT과 차이**
- PUT은 자원의 전체를 교체하지만, PATCH는 자원의 일부만을 교체하는 역할을 수행합니다.

### 멱등성
멱등성은 여러번 적용하더라도 결과가 달라지지 않는 것을 말한다.

멱등성을 보장하는 메서드는
- GET
- PUT
- PATCH
- DELETE

멱등성을 보장하지 않는 메서드는
- POST

POST는 요청마다 서버에 엔티티를 생성하기 때문에 멱등하지 않다

## HTTP Status Code

### 1XX
요청이 수신되어 처리중임을 나타내는 상태 코드이다. 현재는 거의 사용되지 않는다.

### 2XX
요청이 정상적으로 처리되었음을 나타내는 상태코드이다.
- 200(OK)
  - GET과 같은 조회 요청에 성공적으로 응답하는 경우
- 201(Created)
  - POST와 같은 생성요청으로 리소스가 정상적으로 생성 된 경우
  - 응답 헤더에 생성된 리소스의 식별자가 `Location`에 추가된다
- 202(Accepted)
  - 요청은 서버에서 받았으나 아직 처리되지 않은 경우
  - 배치 프로세스가 이에 해당한다
- 204(No Content)
  - 서버에서 요청은 정상적으로 수행했지만 응답 메세지 바디에 담을 데이터가 없는 경우
  - 웹 문서 편집기에서 SAVE요청 같은 것

### 3XX
요청을 완료하기 위해 추가적인 행동이 필요한 경우를 나타내는 상태 코드이다. 웹 브라우저는 3XX 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다.
**영구 리다이렉션**
\
특정 리소스의 URI가 영구적으로 이동한다.
- 301(Moved Permanantly)
  - 리다이렉트시 요청 메서드가 GET으로 변경된다
  - 본문이 변경될 수 있다
- 308(Permanent Redirect)
  - 301과 기능은 동일하다
  - 응답 메세지의 본문과 요청 메서드가 유지된다

**임시 리다이렉션**
\
특정 리소스의 URI가 일시적으로 변경된다.
- 302(Found)
  - 리다이렉트시 요청 메서드가 GET으로 변경된다.
  - 본문이 제거될 수 있다
- 307(Temporary Redirect)
  - 302와 기능은 같다
  - 응답 메세지의 본문과 요청 메서드가 유지된다(MUST)
- 303(See Other)
  - 302와 기능은 같다
  - 리다이렉트 요청 메서드가 GET으로 변경된다


**PRG(Post-Redirect-GET) Pattern**
\
페이지 새로고침은 요청을 다시 보내는 것이다. 따라서 멱등하지 않은 요청인 POST에 새로고침을 하면 여러 엔티티가 생성될 수 있다. 예를 들어, 주문 요청 중간에 새로고침을 하면 주문이 여러개 생성될 수 있다. 따라서 리다이렉션해야한다
응답 코드로 302, 303 등을 사용하면 자연스럽게 리다이렉션시 메서드가 GET으로 변경되어 문제를 해결할 수 있다.


초기 302 스펙의 의도는 HTTP 메서드를 유지하기 위한 것이었다. 하지만 대부분의 브라우조가 GET으로 바꾸어버렸고, 애매한 302를 대신하여 307, 303이 등장했다.

스펙으로는 307과 303을 권장하지만 현실적으로는 302를 대다수 사용한다. 따라서 자동 리다이렉션시 GET으로 메서드를 변경해도 상관이 없으면 그냥 302를 사용한다.


**캐시 목적**
- 304(Not Modified)
  - 캐시를 목적으로 사용한다
  - 클라이언트에 리소스가 수정되지 않았음을 알린다
  - 304 응답은 메세지 바디를 사용하면 안된다
  - 조건부 GET, HEAD 요청시 사용한다

### 4XX
\
클라이언트에서 잘못된 스펙으로 데이터를 보냈거나 인증, 인가가 만족되지 않아 서버에서 요청을 수행할 수 없음을 나타내는 응답코드이다.
- 400(Bad Request)
  - 클라이언트의 요청 포맷이나 데이터에 문제가 있을 경우
- 401(Unauthorized)
  - 인증이 되지 않은 클라이언트에서 리소스에 접근하는 경우
  - WWW-Authenticate 헤더와 함께 인증 방법을 설명
- 403(Forbidden)
  - 인증자격은 있지만 해당 리소스에 접근할 권한이 없는 경우
- 404(Not Found)
  - 요청 리소스를 찾을 수 없는 경우

### 5XX
- 500(Internal Server Error)
  - 서버 내부 문제가 발생한 경우
  - 서버측 로직에서 발생하는 대다수의 예외나 에러는 모두 500
  - 비즈니스 로직과 같이 시스템이 아닌 로직 상의 문제가 발생할 때 500 응답 코드를 반환해서는 안된다
- 503(Service Unavailable)
  - 서버에 트래픽문제 혹은 점검으로 잠시 요청을 처리할 수 없는 경우