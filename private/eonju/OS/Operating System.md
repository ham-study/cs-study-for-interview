# 운영체제 소개

## 운영체제 필요성

- 효율성
  : 메모리나 CPU같은 컴퓨터 자원을 효율적으로 이용하기 위해서

## 운영체제 정의

: 사용자가 편리하게 컴퓨터를 이용할 수 있도록 컴퓨터 자원을 관리하는 소프트웨어

## 운영체제 역할

1. 자원 관리
2. 자원 보호
3. 하드웨어의 인터페이스 제공
4. 사용자 인터페이스 제공

# 운영체제 구조

- 단일형 : 초기의 운영체제 구조, 작고 간단하며 시스템 기능이 제한되어있음.
    - 새로운 기능을 추가하거나 유지보수하는데 힘듦.
- 계층형 : 다수의 계층으로 구성
    - 사용자 프로세서의 요청을 수행하는데 많은 계층을 거쳐야해서 성능이 저하됨.
- 마이크로형

## 커널

: 운영체제의 핵심 부분, 컴퓨터의 자원의 접근을 제어하는 것

## 시스템 호출

: 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스

- 사용자 모드 <> 운영체제 모드 를 바뀌게 하는 것.
- 호출 유형
    - 프로세스 제어(process control)
    - 파일 조작(file manipulation)
    - 장치 관리(device management)
    - 정보 유지(information maintenance)
    - 통신(communication)

# 프로세스

## 프로세스 개념

: 실행중인 프로그램, 메모리 공간에 올라와 CPU의 대기를 받는 상태, 최소 하나 이상의 쓰레드를 들고 있음

## 프로세스 상태

![img](https://t1.daumcdn.net/cfile/tistory/99E85E3A5C460F1906)

## 프로세스 제어 블록

: 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영 체제 커널의 자료 구조

- 포함된 내용

1) 프로세스 식별자(Process ID)

2) 프로세스 상태(Process State) : 생성(create), 준비(ready), 실행 (running), 대기(waiting), 완료(terminated) 상태가
   있습니다.

3) 프로그램 계수기(Program Counter) : 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.

4) CPU 레지스터 및 일반 레지스터

5) CPU 스케줄링 정보 : 우선 순위, 최종 실행시각, CPU 점유시간 등

6) 메모리 관리 정보 : 해당 프로세스의 주소 공간 등

7) 프로세스 계정 정보 : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등

8) 입출력 상태 정보 : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등

9) 포인터 : 부모프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등.

## 프로세스 문맥 교환

새로운 프로세스를 실행하기 위해 인터럽트가 발생할 때, 진행 중인 프로그램의 레지스터 문맥을 PCB에 저장하고, 앞으로 실행될 프로세스의 상태 정보를 설정한 다음에 CPU를
할당하여 실행되도록 하는 작업을 문맥 교환

# 스레드

## 스레드 개념

: 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.

## 멀티스레드의 구조

![img](https://wayhome25.github.io/assets/post-img/cs/thread.png)

## 멀티스레드의 장단점

장점

- 프로그램의 일부분(스레드)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속 되어 사용자에 대한 응답성이 증가한다.

단점

- Critical Section 문제가 발생할 수 있다. (병목현상, 데드락)

## 멀티 프로세스 VS 멀티 스레드

- 멀티 스레드가 속도면에서 유리
    - 멀티 프로세스 : Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모되는 등 오버헤드가 발생한다.
    - 멀티 스레드 : 스레드 사이 작업량이 작아 Context Switching이 빠르다. (캐시 메모리를 비울 필요가 없다.)
- 멀티 프로세스 장점
    - 독립된 구조로 안전성이 높은 장점이 있다.
    - 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업속도가 느려지는 손해정도는 생기지만 정지되거나 하는 문제는 발생하지 않는다.

# 예상 질문

- 교착 상태의 조건이 뭔가요?
    1. 상호 배제(Mutual Exclusion) : 한 자원에 대한 여러 프로세스의 동시 접근은 불가능하다. 즉, 하나의 자원을 특정 시기에 하나의 프로세스나 스레드만
       소유할 수 있는 형태.

    2. 점유와 대기(Hold and Wait) : 하나의 자원을 소유하고 다른 프로세스 혹은 스레드의 자원을 요청하는 상태이다.

    3. 비선점(Non preemptive) : 하나의 프로세스나 스레드에게 주어진 자원은 해당 프로세스나 스레드가 스스로 놓기 전에는 놓게 만들 수 없는 상태. 즉, 다른
       프로세스에서 자원을 사용하는 동안 자원을 강제로 가져올 수 없다.

    4. 환형 대기(Circle wait) : 각 프로세스가 다음 프로세스가 요구하는 자원을 가지고 있는 것을 말한다. 두 개의 프로세스나 스레드의 경우, A -> B, B
       -> C, C -> A에게 서로 자원을 요청하고 기다리는 상황

- 뮤 텍스란 무엇입니까?
    - 프로세스 혹은 스레드 간의 통신 시에 shared memory 등을 쓰는 경우 하나의 자원에 두 개 이상의 프로세스 혹은 스레드가 접근하는 경우에 문제가 발생한다. 이를
      제어하기 위해 스레드는 뮤 텍스를 사용하고, 프로세스에서는 세마포어를 사용한다.
    - 뮤 텍스 : 상호 배제라고도 하며, Critical Section을 가진 스레드의 Running Time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술이다. 뮤
      텍스는 상태가 0, 1 두 개뿐인 이진 세마포어. synchronized 또는 lock을 통해 해결한다.

- 세마포어란 무엇입니까?
    - 세마포어는 사용 중인 리소스를 잠그는 데 사용되는 보호된 변수 또는 추상 데이터 유형이다. 공유된 자원의 데이터를 여러 '프로세스'에서 접근하는 것을 막는다. 세마포어의
      값은 공통 자원의 상태를 나타냅니다. 리소스 상태를 나타내는 간단한 카운터이다. 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할
      수 있다.

- 뮤 텍스와 세마포어의 차이?
    - 가장 큰 차이는 동기화 대상의 개수이다. 뮤 텍스는 동기화 대상이 하나뿐이고, 세마포어는 동기화 대상이 하나 이상일 때.

- 운영 체제에서 기아(Starvation) 란 무엇입니까?
    - 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태이다. 기아상태는 자원 관리 문제이다. 이 문제에서 대기 중인 프로세스는 리소스가 다른
      프로세스에 할당되어 있기 때문에 오랫동안 필요한 리소스를 얻지 못한다.

- 운영 체제에서 에이징(Aging)은 무엇입니까?
    - 에이징은 자원 스케줄링 시스템에서 기아를 방지하기 위해 사용되는 기술이다. 특정 프로세스의 우선순위가 낮아 무한정 기다리게 되는 경우, 한번 양보하거나 기다린 시간에
      비례하여 일정 시간이 지나면 우선순위를 한 단계씩 높여 가까운 시간 안에 자원을 할당받도록 하는 기법을 말한다.

- 운영 체제에서 페이징(Paging)은 무엇입니까?
    - 세그먼테이션과 가상 메모리를 고정된 크기로 나누어 메모리(가상 메모리)를 관리하는 기법을 말한다. 자세하게 말하자면 커다란 크기의 작업을 일정한 크기로 나누어 잘게
      쪼개어 처리하는 것이다. 따라서 불연속적인 메모리 요청 등에 유연하게 처리할 수 있다. 세그먼테이션은 논리적 블록을 필요에 따라 다른 크기로 할당한 것이라면, 페이징은
      고정된 크기로 나누는 것이다. 외부 단편화는 해결하지만, 내부 단편화가 발생할 수 있다.

- 페이징의 장점과 단점은?
    - 장점: 메모리를 페이지 단위로 가져와서, 프로세스의 효율적인 운영이 가능하다. 단점: 페이지 크기별, 단위별로 페이지 폴트 현상이 발생할 수 있다.

- 세그먼테이션(Segmentation) 이란?
    - 메모리를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(segment)로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다. 미리 분할하는 것이
      아니라 메모리를 사용할 시점에 할당된다. 내부 단편화는 없지만 외부 단편화가 발생할 수 있다.


4/4(월) 피드백
- 쓰레드 메모리 구조는 꼭 알아야한다.

프로세스 구조는 크게 Code영역, Data영역, Stack영역, Heap영역, 이 있습니다.
Code영역은 프로그램의 코드가 기계어 형태로 저장된 공간으로 Read-only로 되어있습니다.
Data영역은 전역 변수와 static 변수들이 저장된 공간입니다.
Stack영역은 함수 호출과 관련된 지역변수와 매개 변수가 저장된 공간입니다. 함수가 끝나면 반환됩니다.
Heap영역은 동적 메모리 영역으로 메모리 주소값에 의해서만 참조되고 사용되는 영역입니다.
이 외에도 쓰레드 레지스터가 존재하는데 쓰레드 레지스터는 쓰레드의 정보를 저장하고 있습니다.
