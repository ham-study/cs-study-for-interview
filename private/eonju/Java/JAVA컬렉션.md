## JAVA Collection?

: 컬렉션 프레임워크란, **데이터를 쉽고 효과적으로 처리하기 위해 표준화된 방법을 제공하는 클래스의 집합**입니다.

컬렉션 프레임워크는 크게 3가지의 유형으로 나뉩니다.

- List
    - 특징 : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
    - 구현 클래스 : ArrayList, LinkedList, Stack ...
- Set
    - 특징 : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다.
    - 구현 클래스 : HashSet, LinkedHashSet, TreeSet ...
- Map
    - 특징 : 키(Key)와 값(Value)의 쌍(Pair)으로 이루어진 데이터의 집합입니다.  
      키 중복 허용 X, 값의 중복 허용 O, 순서 유지 X
    - 구현 클래스 : HashMap, Hashtable, LinkedHashMap, TreeMap ...

## HashCode() & Equals()
### HashCode()
: 해시코드란, **객체를 식별하는 하나의 정수값**입니다.  
Object의 hashCode() 메소드는 **객체가 저장된 메모리의 번지수를 활용**하여 해시코드를 만들어냅니다.  
- **사용하는 경우** : 두 객체가 동일한지 판결할 경우 사용할 수 있음.
- **객체를 비교할 떄 hashCode()와 Equals()를 오버라이딩하는 이유**  
객체 내부의 값은 같으나 해시코드에 의해 다른 객체로 판별하기 때문이다.

### Equals() vs ==
**Eqauls** : 논리적으로 동등한가를 비교하는 것, 즉 참조값이 다르더라도 내부의 **값이 같은 경우 true를 반환**한다.  
String.equals()의 경우 내부의 값을 비교한다.  
**==** : 객체의 **주소값을 비교**한다.

### primitive 타입이 == 비교를 통해 값 비교가 가능한 이유
**변수 선언부**는 Java Runtime Data Area의 **Stack 영역에 저장**이 되고,
해당 **변수에 저장된 상수**는 **Runtime Constant Pool에 저장**되어있다. 
Stack의 **변수 선언부**는 해당 **Runtime Contant Pool의 주소값**을 가지게 되고,
만약 **다른 변수도 같은 상수를 저장**하고 있다면,
이 다른 변수도 같은 **Runtime Contant Pool의 주소값**을 가지게 때문에 엄밀히 말하면
**primitive type 역시 주소값 비교**가 되는 것이다.

## ThreadSafe & Syncronized
### ThreadSafe
**Thread** : 메모리를 할당받아 실행 중인 프로그램을 프로세스라고 하는데 하나의 프로세스 내에서  
해당 프로세스 내에서 하나의 실행 흐름을 쓰레드라고 합니다.

**ThreadSafe** : 멀티 스레딩에서 일반적으로 어떤 함수나 변수, 혹은 객체가 **여러 스레드로부터 동시에 접근이 이루어져도
프로그램의 실행에 문제가 없음을 뜻합니다.**

**Thread-safe를 지키기 위한 방법**
1. Re-entrancy  
어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다.
2. Thread-local storage  
공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다.
이 방식은 동기화 방법과 관련되어 있고, 또한 공유상태를 피할 수 없을 때 사용하는 방식이다.
3. Mutual exclusion  
공유 자원을 꼭 사용해야 할 경우 해당 자원의 접근을 세마포어 등의 락으로 통제한다.
4. Atomic operations  
공유 자원에 접근할 때 원자 연산을 이용하거나 '원자적'으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현할 수 있다.
5. Immutable Object  
객체 생성 이후에 값을 변경할 수 없도록 만듭니다.
- ArrayList는 Thread safe 하지 않고, Vector는 Thread safe 하다.

### Syncronized
: 스레드 동기화를 할 때 사용하는 대표적인 기법

- 스레드 동기화의 두가지 관점  
  1. 실행 순서의 동기화
  : 스레드의 실행순서를 정의하고, 반드시 이 순서를 따르도록 하는 것
  2. 메모리 접근의 동기화
  : 데이터 영역과 힙 영역과 같이 한 순간에 하나의 쓰레드만 접근하도록 하는 것이 메모리 접근에 대한 동기화
- 동기화를 위한 두 가지 방법
  1. **유저모드 동기화** : 동기화가 진행되는 과정에서 커널의 힘을 빌리지 않는 (커널 코드가 실행되지 않는) 동기화 기법
     - 커널 모드로의 전환이 불필요해 성능상의 이점
     - 그러나 그만큼 기능상의 제한
     - 예시 : 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화
  2. **커널모드 동기화** : 커널에서 제공하는 동기화 기능을 활용하는 방법
     - 동기화에 관련된 함수가 호출될 때마다 커널 모드로의 변경이 필요, 즉 성능의 저하가 이어짐.
     - 유저 모드 동기화에서 제공하지 못하는 기능을 제공받을 수 있다.
     - 예시 : 뮤텍스 기반의 동기화, 세마포어 기반의 동기화, 이름있는 뮤텍스 기반의 프로세스 동기화, 이벤트 기반의 동기화

## String
: 자바에서 제공하는 문자열 클래스로 문자열과 관련된 다양한 유용한 기능들을 제공하는 클래스입니다.
- String 인스턴스는 한번 생성되면 읽기만 가능하며 수정하는 것은 불가합니다.
- 불변 객체(Immutable Object)입니다. 

### String vs StringBuffer vs StringBuilder
#### StringBuffer
: 내부적으로 버퍼(buffer)라고 하는 독립적인 공간을 가집니다. 버퍼 크기는 기본적으로 16 문자를 저장할 수 있으며,
생성자를 통해 별도로 크기를 지정할 수 있습니다.
**주요 메소드 종류**  
- append()
- capacity() : 현재의 버퍼 크기를 반환
- delete(int start, int end) : 해당 문자열의 start ~ (end-1) 인덱스에 해당하는 문자 제거
**String vs StringBuffer**  
  String 클래스는 변경이 불가한 반면,
  StringBuffer 클래스의 인스턴스는 그 값을 변경할 수도 있고, 추가할 수도 있습니다.  
  따라서 공간 낭비가 String에 비해 적고, 속도도 빨라집니다.  
  이유 : 덧셈(+) 연산자를 이용해 String 인스턴스의 문자열을 결합하면, 내용이 합쳐진 새로운 String 인스턴스를 생성합니다.
### Immutable Object
: 생성 후 그 상태를 바꿀 수 없는 객체.
- ex ) String, Integer, Boolean
- 장점
  - 객체에 대한 신뢰도가 높아집니다. 객체가 한번 생성되어서 그게 변하지 않는다면 transaction 내에서 그 객체가 변하지 않기에 우리가 믿고 쓸 수 있기 때문입니다.
  - 생성자, 접근메소드에 대한 방어 복사가 필요없습니다.
  - 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있습니다.
- 단점 
  - 객체가 가지는 값마다 새로운 객체가 필요합니다.
  - 따라서 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능저하를 발생시킬 수 있습니다.

### StringBuilder vs SringBuffer
#### StringBuilder가 유리한 점
- **단일 스레드 환경**에서의 비번한 추가, 수정, 삭제가 일어나는 경우 StringBuffer에 비해 효율적

#### StringBuffer가 유리한 점
- **멀티 스레드 환경**에서의 빈번한 추가, 수정, 삭제가 일어나는 경우 StringBuilder에 비해 효율적

### String a = "" vs String a = new String("")
#### String a = new String("") - new 연산자를 이용하는 방식
- Heap 영역에 메모리가 할당
- 같은 문자열이라도 다른 객체라서 선언한 만큼의 새로운 객체가 메모리에 할당

#### String a = "" - 리터럴을 이용하는 방식
- String을 리터럴로 선언하면 내부적으로 String의 intern() 메소드가 호출됩니다.  
intern() 메소드는 주어진 문자열이 String Constant Pool에 존재하는 검색합니다.  
만약 있다면 그 주소값을 반환하고 없다면 여기에 새로 하나 만들고 그 주소값을 반환해줍니다.


