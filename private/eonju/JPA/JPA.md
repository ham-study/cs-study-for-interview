## 영속성 컨텍스트
: 엔티티를 영구 저장하는 환경
- 애플리케이션과 데이터베이스 사이에 위치
- 엔티티 매니저를 통해 엔티티들을 영속성 컨텍스트에 저장하거나 조회한다.
- 엔티티 매니저가 하나 생성될 때 영속성 컨텍스트가 하나가 생성됩니다.

- 영속성 컨텍스트 특징
    1. 데이터 베이스의 기본키를 사용해 영속성 컨텍스트의 엔티티는 반드시 식별자를 가진다.
       - 조회시 식별자 값으로 구분한다.
       
- 영속성 컨텍스트 이점  
  1. 1차 캐시가 있다. -> DB에 직접 접근하는 횟수 줄어듬.
     - 1차 캐시 조회 과정
       1. 조회 시 처음 1차 캐시에 해당 데이터가 있는지 탐색을 한다. -> 만약 있으면 바로 리턴
       2. 조회 결과 1차 캐시에 데이터가 없으면 데이터베이스에 접근해 값을 탐색한다.
       3. 탐색 결과를 바로 리턴하는 것이 아닌 다음 탐색에서 재사용할 수 있도록 1차 캐시에 저장한다.
     - EntityManager는 트랜잭션 단위이기 때문에 트랜잭션이 끝나면 1차 캐시도 지워버린다.

  2. 영속 엔티티의 동일성을 보장한다.(==)
     : 1차 캐시내에서 값을 가져오기 때문에 동일성이 보장된다.
  
  3. 쓰기 지연
     - 엔티티들을 1차 캐시에 저장시 '쓰기 지연 SQL 저장소'에 SQL문도 함께 저장
     - 저장하고 있다가, 트랜잭션 커밋시 저장소의 SQL문들을 한번에 실행한다.
     
  4. 변경 감지
     - JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터를 변경하면 된다.
     - 단, 영속 상태인 엔티티들만 가능하다.
     - 변경감지의 흐름
       1. 트랙잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.
       2. 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾는다.
       3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 저장한다.
       4. 쓰기 지연 저장소의 SQL을 플러시한다.
       5. 데이터베이스 트랜잭션을 커밋한다.
       
- flush?  
  : 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 
    영속성 컨텍스트의 엔티티를 지우는게 아니라 변경 내용을 데이터베이스에 동기화하는 것이다.  


- 영속성 컨택스트 플러쉬하는 방법
    1. 엔티티 매니저의 flush() 메소드를 사용 (직접 호출)
    2. Transaction Commit()이 수행 (자동 호출)
    3. JPQL 쿼리 실행 (자동 호출)

## Entity
: 식별자를 지닌 하나의 데이터 집합으로, 데이터베이스에 의해 관리되어야할 데이터입니다.

- 엔티티 생명주기
  1. 비영속 (new/transient)
     - 엔티티 객체는 생성되었지만 아직 영속성 컨텍스트에 저장되지 않은 상태
     - 영속성 컨텍스트와 전혀 관계가 없는 상태
  2. 영속 (managed)
     - 영속성 컨텍스트에 저장되어 관리받는 상태
     - persist()
  3. 준영속 (detached)
     - 영속성 컨텍스트에 저장되었다가 분리된 상태
     - detach(), clear(), close()
     - 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.
     - 식별자 값을 가지고 있다.
  4. 삭제 (removed)
      - 영속성 컨텍스트와 데이터베이스에서 삭제된 상태  
      - remove()
  ![img](https://media.vlpt.us/images/neptunes032/post/ecd3b113-862f-4158-a208-e1eeec92d61d/image.png)

## 즉시/지연 로딩
### 지연 로딩
: 원하는 엔티티는 바로 조회 쿼리문이 나가지만, 연관관계에 있는 엔티티는 프록시 객체로 가져온다.
단, 연관관계에 있는 엔티티를 직접적으로 사용하는 시점에 DB에 쿼리문이 나가게 된다.

- 로딩되는 시점에 Lazy 로딩 설정이 되어있는 Team 엔티티는 프록시 객체로 가져온다.
- 후에 실제 객체를 사용하는 시점에(Team을 사용하는 시점에) 초기화가 된다. DB에 쿼리가 나간다.
- JPQL의 fetch Join을 사용하면 두 번의 쿼리가 날라갈 것을 한 번에 날라가게 할 수 있다.

### 즉시 로딩
: 원하는 엔티티를 조회시 연관관계가 있는 객체까지 모두 DB에서 조회해서 가져온다.
 - 프록시 객체가 아닌 진짜 객체를 가져온다.

 - 주의사항  
   - 즉시 로딩을 사용하면 예상하지 못한 SQL문이 날라갈 수 있기 때문에 지연 로딩을 써야합니다.
   - 즉시 로딩은 JPQL 사용시 N+1문제를 만들 수 있습니다.
   - N+1 문제 : ORM을 사용하면 가장 쉽게 접할 수 있는 문제 중에 하나이다.
     1번 쿼리를 날렸는데 추가로 N번 더 쿼리문을 날려야 하는 상황을 1+N이라고 불린다.
   
## 프록시
: 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다.
  - 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
  - 프록시 객체는 처음 사용할 때 한 번만 초기화 된다.
  - 프록시 객체를 초기화 할 때, 프록시 객체가 실제로 엔티티로 바뀌는 것은 아니다.
  - EntityManager.getReference()

- 프록시 초기화
: 프록시 객체가 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는 것

  - 과정
    1. 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회한다.
    2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트 실제 엔티티 생성을 요청한다.
    3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
    4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버변수에 보관한다.
    5. 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 반환한다.
    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclMuqx%2FbtrpqytaMa5%2FBCvgvyAPJO5g5i458KFQW0%2Fimg.png)

  - 특징
    - 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
    - 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.
    - 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
    - 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해야 한다.
    - == 비교 실패, 대신 instance of 사용
    - 영속성 컨텍스트에 찾은 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 실제 엔티티를 반환한다.
