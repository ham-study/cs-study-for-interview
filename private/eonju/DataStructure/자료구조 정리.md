## 배열

- 동일한 데이터 형식을 연속된 메모리 공간에 저장하는 방식입니다.
- 고정된 크기의 메모리 공간을 갖습니다.

**시간 복잡도**

| 메소드              | 시간 복잡도                       |
|------------------|------------------------------|
| arr[idx]         | O(1) , 데이터의 위치를 알고 있기 때문에    |
| indexOf(data)    | O(N) , 순차 검색                 |
| arr[idx] = value | O(1) , 데이터의 위치를 알고 있기 때문에    |

**장점**

- 찾고자 하는 데이터의 위치(인덱스)를 알고있다면 빠르게 데이터에 접근할 수 있습니다.

**단점**

- 인덱스를 모르는 경우 삽입이나 삭제시 인덱스를 순차 탐색을 하기 때문에 상대적으로 시간이 오래 걸립니다.
- 크기가 정해져 있어 StackOverFlow같은 에러를 만날 수 있습니다.

---

## Java List (List)

- 동일한 데이터 형식을 저장하는 방식입니다.
- 동적인 크기의 메모리 공간을 갖습니다.
- Java에서는 ArrayList와 LinkedList 등이 이에 해당됩니다.

### ArrayList

- 연속된 메모리 공간에 데이터를 저장하는 방식입니다.

**시간 복잡도**

| 메소드               | 시간 복잡도                      |
|-------------------|-----------------------------|
| arr.get(idx)      | O(1), 인덱스를 알고 있기 때문에        |
| arr.indexOf(data) | O(N), 순차탐색                  |
| arr.add(idx)      | O(1), 삽입해야하는 인덱스를 알고 있기 때문에 |
| arr.add()         | O(N), 순차탐색 후 삽입             |
| arr.contains()    | O(N), 순차탐색                  |
| arr.remove(idx)   | O(N), 데이터의 순서를 모르기 때문에      |

**장점**

- 인덱스를 알고 있는 경우 데이터의 접근 속도가 빠르다.

**단점**

- 중간의 데이터 추가/삭제시 모든 데이터를 이동해야하므로 시간이 많이 걸립니다.

### LinkedList

- 연속되지 않게 저장하는 방식
- 데이터 부분과 주소 부분을 따로 가지고 있습니다.
- 데이터는 포인터와 주소를 사용해서 연결합니다.

**시간 복잡도**

| 메소드               | 시간 복잡도                         |
|-------------------|--------------------------------|
| arr.get(data)     | O(N), 순차탐색                     |
| arr.indexOf(data) | O(N), 순차탐색                     |
| arr.add(idx)      | O(1), 해당하는 위치에 데이터를 넣고 포인터로 연결 |
| arr.add(data)     | O(1), 해당하는 위치에 데이터를 넣고 포인터로 연결 |
| arr.contains()    | O(N), 순차탐색                     |
| arr.remove(idx)   | O(N), 데이터의 순서를 모르기 때문에         |

**장점**

- 중간 데이터를 삽입, 삭제하는데 ArrayList보다 효율적이다.

**단점**

- 포인터의 사용으로 메모리가 필요하다.

---

## HashMap

- Map 인터페이스를 구현한 구현체입니다.
- Key-Value 형식으로 이루어져있습니다.
- key : 중복 불가능, null 값 가능
- value : 중복 가능, null 값 가능
- Hash함수를 통해 저장되는 위치가 정해집니다.
- 데이터의 순서가 보장되지 않습니다.

**시간 복잡도**

| 메소드                                 | 시간 복잡도                                 |
|-------------------------------------|----------------------------------------|
| map.get(key)                        | O(1), 해시함수를 통해 key에 해당되는 value를 찾기 때문에 |
| map.getOrDefault(key, DefaultValue) | O(1)                                   |
| map.containsKey(key)                | O(1)                                   |

**장점**

- 해시함수를 이용하기 때문에, 키 값을 알고 있는 경우 해당하는 값을 빠르게 가져올 수 있다.
- 중복을 제거하는데 유용하다.

**단점**

- 해시 함수를 사용해 충돌이 발생할 수 있다.
- 순서를 보장해주지 않는다.
- 데이터를 저장하는데 있어 느릴 수 있다. -> 충돌 발생시 해결해야 하는 시간이 추가적으로 필요

**사용하면 좋은 경우**

- 특정 범위를 검색하는 경우가 아닌 특정 값에 대한 빈번한 검색이 있을 경우 유리하다고 생각

---

## HashTable

- Key-Value 형식으로 이루어져있습니다.
- Hash함수를 이용해 저장 공간을 선정한다.  
  `원래 데이터의 값(Key) -> Hash Function -> Hash Function의 결과 = Hash Code -> Hash Code를 배열의 Index 로 사용 -> 해당하는 Index에 data 넣기`

**시간 복잡도**

| 메소드                   | 시간 복잡도                     |
|-----------------------|----------------------------|
| table.add(key, value) | O(1), 해시충돌로 인한 최악인 경우 O(N) |
| table.remove(key)     | O(1), 해시충돌로 인한 최악인 경우 O(N) |
| table.get(key)        | O(1), 해시함수를 이용하기 때문에       |

**장점**

- 동기화를 지원해준다.
- key를 알고 있다면 빠르게 데이터에 접근할 수 있다.

**단점**

- 동기화로 인해 연산이 느릴 수 있다.
- 메모리 공간을 효율적으로 사용하는 것과는 거리가 있다.
- 해시 함수에 의존도가 높다.

---

### 번외) HashMap VS HashTable

**공통점**

- Hash함수를 이용해 데이터를 저장한다.
- Key-Value 형식으로 데이터를 저장한다.

**차이점**

1. 동기화
    - HashMap 동기화 지원 X
    - HashTable 동기화 지원 O (put 메소드를 보면 synchronized 키워드가 붙어있다.)
2. null 허용 유무
    - HashMap Key/Value -> null O
    - HashTable Key/Value -> null X (put 메소드 내에 null 값인지 확인하는 로직이 포함.)
    - HashMap의 key를 null로 설정하면, null일경우 따로 처리하는 로직을 추가해두었다. -> 에러 발생 X
    - HashTable key를 null로 설정하면, null일경우 따로 처리하는 로직이 따로 추가되어있지 않다. -> 에러 발생 O

**동기화란?**

- 하나의 공유되는 자원에 대해서 동시에 접근하는 것을 제한하는 것
- 순차적으로 접근할 수 있도록 해주는 것
- 동기화가 적용되는 경우 속도가 느려질 수 있다.
- Java에서는 synchronized 키워드를 사용한다.
- 메소드, 블록 단위로 적용이 가능하다.

---

### 번외) Hash 충돌 해결법

#### 1. Separating Chaining - 분리 연결법

- JDK 내부에서 사용하는 방식
- JDK 내부에서는 LinkedList나 Red-Black Tree 사용해 데이터를 저장한다.
- 추가적인 메모리를 공간을 사용해 데이터를 적재하는 방식
- 추가적인 메모리 공간을 사용하기 위해서 메모리를 늘리는 Resizing 과정이 필요하다.

#### 2. Open addressing - 개방 주소법

- 추가적인 메모리 공간을 사용하지 않고, 현재 비어있는 메모리 공간에 적재하는 방식

---

## Queue

- 한 쪽 끝으로는 삽입(add)이 이루어지고 다른 한 쪽으로는 삭제(pull)가 이루어지는 데이터 구조
    - 삽입 (rear), 삭제 (front)
- 선입선출 방식(FIFO)

**시간 복잡도**

| 메소드          | 시간 복잡도       |
|--------------|--------------|
| queue.add()  | O(1)         |
| queue.poll() | O(1)         |
| queue.peek() | O(1)         |
| queue.size() | O(1)         |

**장점**

- 삽입, 삭제 연산이 빠르다.

**단점**

- 다음 노드를 가리킬 포인터를 저장할 메모리 공간이 추가적으로 필요하다.
- 중간 데이터를 삽입, 삭제, 조회하는 것이 불가능하다.

**사용하는 경우**

- 순차적으로 데이터를 처리하고 싶을 때, 즉 순서가 중요한 곳

---

## Stack

- 한 쪽으로만 삽입(push), 삭제(pop)가 일어나는 구조
- 선입후출 방식 (FILO)

**시간 복잡도**

| 메소드          | 시간 복잡도       |
|--------------|--------------|
| stack.push() | O(1)         |
| stack.pop()  | O(1)         |
| stack.peek() | O(1)         |
| stack.size() | O(1)         |

**장점**

- 동기화가 지원된다. (synchronized 키워드가 붙어있다.)

**단점**

- 스택이 비어있는 경우 삭제 연산을 하거나, 스택이 꽉찬 경우 삽입 연산을 하게되면 Stack underflow와 Stack overflow가 발생할 수 있다.
- Java의 경우 Vector 클래스를 확장하여 중간에 데이터를 삽입하거나 삭제할 수 있다. -> 자바가 잘못 설계한 점
- 따라서 ArrayDeque를 사용하면 동기화가 지원되지 않아 더 빠르다.

---

## 그래프(Graph)

- 노드와 간선으로 이루어져 있습니다.
- 간선의 방향의 유무로 방향 그래프, 무방향 그래프가 있습니다.
- 표현 방법으로는 인접 행렬과 인접 리스트로 나타낼 수 있습니다.
- 사이클이 생길 수 있다.

### 인접행렬

- 보통 2차원 행렬 형태로 나타냅니다.
- 행과 열에 해당하는 인덱스 칸에 값이 적힌 경우, 해당 값이 간선의 가중치가 됩니다.

**장점**

- 임의의 두 정점 사이의 간선의 존재 유무를 한번에 확인할 수 있습니다.
- 정점 사이 간선의 가중치를 빠르게 파악할 수 있습니다.

**단점**

- 그래프 내에 존재하는 간선들의 수를 계산하는 것이 힘들다.
- N개의 노드를 표현하기 위해서는 N^2개의 공간이 필요합니다.
- 원하는 노드가 간접적으로 연결되어있는지 확인하기 위해서는 모든 노드를 순회해야합니다.

**인접행렬의 구조**  
![img](https://t1.daumcdn.net/cfile/tistory/99FEFB395CCDBCC810)

### 인접 리스트

- 해당 노드에 연견된 간선이나 노드의 정보를 리스트 형태로 나타냅니다.

**장점**

- 임의의 정점과 인접한 노드를 쉽게 찾을 수 있습니다.
- 임의의 정점과 연결된 간선의 갯수를 쉽게 파악할 수 있습니다.

**단점**

- 임의의 두 정점이 연결되어 있는지 확인하기 위해서는 양쪽 노드의 리스트를 모두 탐색해야 한다.

**인접 리스트의 구조**  
![img](https://t1.daumcdn.net/cfile/tistory/992D63355CC5BA5403)

---

## 트리(Tree)

- 노드와 간선들로 이루어져있는 구조
- 루트 노드가 존재합니다.
- 사이클이 존재할 수 없습니다.
- 노드들 간의 계층적인 관계를 나타냅니다, 즉 부모 노드와 자식 노드로 이루어져 있습니다.
- 인접 배열 또는 인접 리스트 방식으로 구현할 수 있다.

**인접 배열 방식**

- 1차원 배열 : 자신의 부모 노드 정보만 저장
- 2차원 배열 : 자식 노드의 정보를 저장 ex) `arr[parent][0] = left`, `arr[parent][1] = right`

**인접 리스트 방식**

- 가중치가 없는 경우 : 해당 노드와 연결된 노드의 정보만 저장 ex) `HashMap<Integer, List<Integer>>`
- 가중치가 있는 경우 : 해당 노드와 연결괸 노드의 정보와 간선 가중치를 저장 ex) `HashMap<Integer, List<Node>>`

---

### 이진 트리

- 하나의 부모 노드와 두 개의 자식 노드로 구성된 트리입니다.
- 레벨 l에서의 최대 노드 수 : 2^(l-1) 개
- 깊이가 k인 트리가 가질 수 있는 최대 노드 수 : (2^k)-1 개

---

### 완전 이진 트리

- 자식 노드가 왼쪽부터 오른쪽으로 순차적으로 채워진 이진트리입니다.

### 이진 탐색 트리

- 비교적 빠르게 원하는 노드를 검색할 수 있다.
- 삽입과 삭제가 효율적으로 수행된다.

**특징**

- 유일한 킷값
- 왼쪽 키값 < 루트 키값 < 오른쪽 키값

---

## 균형 트리(AVL Tree)

- 이진 탐색 트리
- 왼쪽 서브트리의 높이와 오른쪽 서브 트리의 높이 차이가 1 이하인 이진 탐색 트리
- 삽입과 삭제가 일어났을 때 높이 차이가 2이상이 될 경우 재배치를 통해 성질을 유지합니다.

**장점**

- 높이 차이가 거의 비슷하기 때문에 탐색, 삽입, 삭제 모두 O(log2n)안에 가능합니다.

**단점**

- 자료의 삽입과 삭제가 빈번할 경우 재배치에 많은 시간이 필요할 수 있습니다.

---

## 레드 블랙 트리(Red-Black Tree)

: 자가 균형 이진 탐색 트리로 AVL트리의 특징과 이진탐색 트리의 특징을 지닌 트리입니다.

---

#### 일반 트리 VS 이진 트리

- 일반트리에서는 자식의 순서를 구분하지 않지만, 이진트리에서는 구분한다.

#### 완전 이진 트리 VS 이진트리

- 완전 이진 트리 : 왼쪽부터 데이터를 채운다.
- 이진 트리 : 왼쪽, 오른쪽 아무 곳부터 채운다.

---

## 힙(Heap)

: 부모와 자식 노드 간에 일정한 순서적 성질을 가지는 완전 이진 트리 입니다. 크게 최대 힙 트리와 최소 힙 트리로 나뉩니다.

**최대 힙 트리**
: 부모 > 자식, 부모가 크다.

**최소 힙 트리**
: 자식 > 부모, 부모가 작다.

---

## 트라이(Trie)

: 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조입니다.

**활용될만한 곳**
자동완성 기능, 사전 검색 등 문자열을 탐색하는 것에 사용될 것 같습니다.

**장점**

- 문자열 탐색을 빠르게 한다.

**단점**

- 메모리 측면에서 자식들에 대한 포인터들을 모두 저장해두고 있어 비효율적일 수 있다.
  ![img](https://media.vlpt.us/images/kimdukbae/post/50497c5d-1598-48ad-b7cd-e60b2df366da/image.png)

---

## 이분 탐색

: 정렬된 배열 혹은 리스트에서 적합한 빠른 탐색 방법이며, 먼저 중앙값을 찾고 찾고자 하는 숫자가 중앙값을 기준으로 왼쪽에 위치할지 오른쪽에 위치할지를 통해 찾습니다.
시간 복잡도
: O(log n) - 탐색을 반복할 때마다 탐색해야하는 범위는 반으로 줄어들기 때문이다.

Lower Bound : 원하는 수보다 처음으로 크거나 같은 값이 나오는 위치를 반환한다.  
Upper Bound : 원하는 수보다 처음으로 큰 값이 나오는 위치를 반환한다.  
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2eip7%2FbtqwwYRwAfB%2FTuM9ohOJ7TGEWJtiw3w8nk%2Fimg.png)  
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FG7wHv%2FbtqV0D9Zn52%2FIrArSq3Au3Qlkd2ja1166k%2Fimg.png)

``` java
public static int binarySearch(int[] array, int target) {
    int left = 0;
    int right = array.length - 1;

    while (left <= right) {
        int mid = (left + right) / 2;

        if (target == array[mid]) {
            return mid;
        }

        if (target > array[mid]) {
            left = mid + 1;
            continue;
        }

        if (target < array[mid]) {
            right = mid - 1;
        }
    }

    return -1;
}

public static int lowerBound(int[] array, int target) {
    int left = 0;
    int right = array.length;

    while (left < right) {
        int mid = (left + right) / 2;

        if (target <= array[mid]) {
            right = mid;
            continue;
        }

        if (array[mid] < target) {
            left = mid + 1;
        }
    }

    return left;
}

public static int upperBound(int[] array, int target) {
    int left = 0;
    int right = array.length;

    while (left < right) {
        int mid = (left + right) / 2;

        if (array[mid] <= target) {
            left = mid + 1;
            continue;
        }

        if (array[mid] > target) {
            right = mid;
        }
    }

    return left;
}
```

## 동적계획법

: 하나의 문제를 여러 개의 작은 문제로 나눠 풀고 메모이제이션(memoization)을 통해 효율적으로 문제를 해결하는 방식입니다.

### 1.Top-Down -> 재귀

: 문제의 풀이가 위에서 아래로 진행되는 것을 말한다.

``` java
public static int fibo(int n) {
    if (n <= 2) {
        return 1;
    }

    if (fiboData[n] == 0) {
        fiboData[n] = fibo(n - 1) + fibo(n - 2);
    }

    return fiboData[n];
}
```

### 2. Bottom-Up -> 반복문

: 문제의 풀이가 아래에서 위로 진행되는 것을 말한다.

``` java
public static int fibo(int n) {
    fibodata[0] = 0;
    fiboData[1] = 1;

    for (int i = 2; i <= n; i++) {
        fiboData[i] = fiboData[i - 1] + fiboData[i - 2];
    }

    return fiboData[n];
}
```

**장점**

- 작은 문제를 해결한 것에 대한 값을 저장할 공간이 필요하다.
- 항상 최적의 해를 구할 수 있다.

**단점**

- 그리디 알고리즘과 달리 모든 문제를 해결해보고 결정하는 방식이라 그리디에 비해 조금 비효율적이다.
