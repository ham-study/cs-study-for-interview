## 배열 (Array)

: 동일한 데이터 형식을 연속된 메모리 공간에 저장하는 방식입니다.

**시간 복잡도**  

|메소드| 시간 복잡도                       |
|------|------------------------------|
|arr[idx]| O(1) , 해당 데이터에 바로 접근 가능하기 때문 |
|indexOf()| O(N) , 순차 검색                 |
|arr[idx] = value| O(1) , 데이터의 순서를 알고 있기 때문에    |
|arr[??] = value| O(N) , 데이터의 순서를 모르기 때문에      |

**장점**

- 인덱스를 안다면 빠르게 데이터에 접근할 수 있습니다.

**단점**

- 인덱스를 모르는 경우 삽입이나 삭제시 인덱스를 순차 탐색을 하기 때문에 상대적으로 시간이 오래 걸립니다.
- 크기가 정해져 있어 StackOverFlow같은 에러를 만날 수 있습니다.

## Java List (List)

: 동일한 데이터 형식을 동적인 배열로 저장하는 방식입니다. Java에서는 ArrayList와 LinkedList가 있습니다.

### ArrayList

:
**시간 복잡도**

| 메소드              | 시간 복잡도                   |
|------------------|--------------------------|
| ㅇㅇ               | ㅇㅇ                       |
|                  |                          |
| arr[idx] = value | O(1), 데이터의 순서를 알고 있기 때문에 |
| arr[??] = value  | O(N), 데이터의 순서를 모르기 때문에   |
**장점**

**단점**

### LinkedList

:
**시간 복잡도**

**장점**

**단점**

## HashMap

:
**시간 복잡도**

**장점**

**단점**

## HashTable

:
**시간 복잡도**

**장점**

**단점**

## Queue

:
**시간 복잡도**

**장점**

**단점**

### Message Queue

:
**시간 복잡도**

**장점**

**단점**

## Stack

:
**시간 복잡도**

**장점**

**단점**

---

## 그래프(Graph)

: 노드와 간선으로 이루어져 있으며 간선이 방향이 있느냐 없느냐로 크게 방향 그래프와 무방향 그래프가 있습니다. 그리고 방향 그래프는 크게 단방향 그래프와 양방향 그래프로
나뉩니다. 그래프의 표현방법으로는 인접 행렬 또는 인접 리스트로 나타냅니다.

### 인접행렬

: 보통 이차원 행렬 형태로 나타내며, 해당 두 정점의 인덱스에 해당하는 칸에 값이 적힌 경우 간선이 존재한다고 보며, 해당 가중치를 나타낼 수 있습니다.

**장점**

- 임의의 두 정점 사이의 간선의 존재 유무를 한번에 확인할 수 있습니다.
- 정점과 연결된 간선의 수를 쉽게 파악할 수 있다.

**단점**

- 그래프 내에 존재하는 간선들의 수를 계산하는 것이 힘들다.
- N개의 노드를 표현하기 위해서는 N^2개의 공간이 필요합니다.
- 원하는 노드가 간접적으로 연결되어있는지 확인하기 위해서는 모든 노드를 순회해야합니다.

**인접행렬의 구조**  
![img](https://t1.daumcdn.net/cfile/tistory/99FEFB395CCDBCC810)

### 인접 리스트

: 노드 별로 리스트를 가지고 있으며 해당 리스트에 연결된 노드의 정보가 들어있습니다.

**장점**

- 임의의 정점과 인접한 노드를 쉽게 찾을 수 있습니다.

**단점**

- 임의의 두 정점의 연결 여부를 확인하기 위해서는 리스트를 모두 탐색해야 한다.

**인접 리스트의 구조**  
![img](https://t1.daumcdn.net/cfile/tistory/992D63355CC5BA5403)


---

## 트리(Tree)

: 구성 원소간의 계층 관계를 표현하는 자료 구조입니다. 트리는 노드와 간선으로 구성 되어있고, 그래프와 달리 사이클이 존재하지 않는다는 특징이 있습니다.

### 이진 트리

: 근노드와 두 개의 자식 노드로 구성된 트리입니다.

**일반 트리와의 차이점**

- 일반트리에서는 자식의 순서를 구분하지 않지만, 이진트리에서는 구분한다.

**완전 이진 트리와의 차이점**

- 완전 이진 트리의 경우 동일 레벨에서는 왼쪽부터 오른쪽으로 순차적으로 대응되는 반면, 이진 트리는 왼쪽부터 꼭 대응되지 않아도 된다.

**이진 트리의 성질**

- 레벨 l에서의 최대 노드 수 : 2^(l-1) 개
- 깊이가 k인 트리가 가질 수 있는 최대 노드 수 : (2^k)-1 개

### 완전 이진 트리

: 동일 레벨에서 왼쪽부터 오른쪽으로 순차적으로 채워진 이진트리입니다.

### 이진 탐색 트리

: 이진 트리 구조를 이용하여 비교적 빠르게 원하는 레코드를 검색할 수 있고, 특정 레코드의 삽입과 삭제를 효율적으로 수행하는 것
**특징**

- 유일한 킷값
- 왼쪽 키값 < 루트 키값 < 오른쪽 키값

---

## 힙(Heap)

: 부모와 자식 노드 간에 일정한 순서적 성질을 가지는 완전 이진 트리 입니다. 크게 최대 힙 트리와 최소 힙 트리로 나뉩니다.

**최대 힙 트리**
: 부모 > 자식

**최소 힙 트리**
: 자식 > 부모

**자바 힙 영역**


---

## 트라이(Trie)

: 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조입니다.

**활용될만한 곳**
자동완성 기능, 사전 검색 등 문자열을 탐색하는 것에 사용될 것 같습니다.

**장점**

- 문자열 탐색을 빠르게 한다.

**단점**

- 메모리 측면에서 자식들에 대한 포인터들을 모두 저장해두고 있어 비효율적일 수 있다.
  ![img](https://media.vlpt.us/images/kimdukbae/post/50497c5d-1598-48ad-b7cd-e60b2df366da/image.png)

---

## 균형 트리(AVL Tree)

: 오른쪽 서브트리의 높이와 왼쪽 서브 트리의 높이 차이가 1 이하인 이진 탐색 트리를 말합니다. 삽입과 삭제가 일어났을 때 왼쪽과 오른쪽 서브 트리의 높이 차이가 2이상이 될
경우 재배치를 통해 성질을 유지합니다.

**장점**

- 높이 차이가 거의 비슷하기 때문에 탐색, 삽입, 삭제 모두 O(log2n)안에 가능합니다.

**단점**

- 자료의 삽입과 삭제가 빈번할 경우 재배치에 많은 시간이 필요할 수 있습니다.

---

## 레드 블랙 트리(Red-Black Tree)

: 자가 균형 이진 탐색 트리로 AVL트리의 특징과 이진탐색 트리의 특징을 지닌 트리입니다.

---

## 이분 탐색

: 정렬된 배열 혹은 리스트에서 적합한 빠른 탐색 방법이며, 먼저 중앙값을 찾고 찾고자 하는 숫자가 중앙값을 기준으로 왼쪽에 위치할지 오른쪽에 위치할지를 통해 찾습니다. 시간
복잡도 : O(log n) - 탐색을 반복할 때마다 탐색해야하는 범위는 반으로 줄어들기 때문이다.

Lower Bound : 원하는 수보다 처음으로 크거나 같은 값이 나오는 위치를 반환한다.  
Upper Bound : 원하는 수보다 처음으로 큰 값이 나오는 위치를 반환한다.  
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2eip7%2FbtqwwYRwAfB%2FTuM9ohOJ7TGEWJtiw3w8nk%2Fimg.png)  
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FG7wHv%2FbtqV0D9Zn52%2FIrArSq3Au3Qlkd2ja1166k%2Fimg.png)

``` java
public static int binarySearch(int[] array, int target) {
    int left = 0;
    int right = array.length - 1;

    while (left <= right) {
        int mid = (left + right) / 2;

        if (target == array[mid]) {
            return mid;
        }

        if (target > array[mid]) {
            left = mid + 1;
            continue;
        }

        if (target < array[mid]) {
            right = mid - 1;
        }
    }

    return -1;
}

public static int lowerBound(int[] array, int target) {
    int left = 0;
    int right = array.length;

    while (left < right) {
        int mid = (left + right) / 2;

        if (target <= array[mid]) {
            right = mid;
            continue;
        }

        if (array[mid] < target) {
            left = mid + 1;
        }
    }

    return left;
}

public static int upperBound(int[] array, int target) {
    int left = 0;
    int right = array.length;

    while (left < right) {
        int mid = (left + right) / 2;

        if (array[mid] <= target) {
            left = mid + 1;
            continue;
        }

        if (array[mid] > target) {
            right = mid;
        }
    }

    return left;
}
```

## 동적계획법

: 하나의 문제를 여러 개의 작은 문제로 나눠 풀고 메모이제이션(memoization)을 통해 효율적으로 문제를 해결하는 방식입니다.

**Top-Down** -> 재귀
: 문제의 풀이가 위에서 아래로 진행되는 것을 말한다.

``` java
public static int fibo(int n) {
    if (n <= 2) {
        return 1;
    }

    if (fiboData[n] == 0) {
        fiboData[n] = fibo(n - 1) + fibo(n - 2);
    }

    return fiboData[n];
}
```

**Bottom-Up** -> 반복문
: 문제의 풀이가 아래에서 위로 진행되는 것을 말한다.

``` java
public static int fibo(int n) {
    fibodata[0] = 0;
    fiboData[1] = 1;

    for (int i = 2; i <= n; i++) {
        fiboData[i] = fiboData[i - 1] + fiboData[i - 2];
    }

    return fiboData[n];
}
```

**장점**

- 작은 문제를 해결한 것에 대한 값을 저장할 공간이 필요하다.
- 항상 최적의 해를 구할 수 있다.

**단점**

- 그리디 알고리즘과 달리 모든 문제를 해결해보고 결정하는 방식이라 그리디에 비해 조금 비효율적이다.
