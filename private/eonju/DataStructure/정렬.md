# 정렬
: 오름차순 혹은 내림차순의 방법으로 레코드를 재배열하는 것을 의미합니다.

정렬은 정렬 장소에 따라서 내부 정렬과 외부 정렬로 나뉠 수 있습니다.  
**내부 정렬**은 파일의 크기가 작거나 처리해야할 자료의 양이 적은 경우 데이터의 이동속도가 빠른 
주기억 장치 내부에 정렬하고자 하는 파일을 적재하여 재배열을 수행하는 것을 말합니다.
**외부 정렬**은 파일의 크기나 처리해야할 자료의 양이 많아 주기억장치로 처리하기 어려울 경우 보조 기억
장치를 이용하여 정렬을 수행하는 것을 말합니다.  

정렬은 정렬 알고리즘에 따라 **비교에 의한 정렬**과 **분산에 의한 정렬**로 구분할 수 있습니다.  
**비교에 의한 정렬**은 레코드의 키값을 두 개씩 한 번에 비교한 다음 그 값을 서로 교환하여 정렬하는 방법입니다.  
비교에 의한 정렬 알고리즘으로는 선택 정렬, 삽입 정렬, 버블 정렬, 퀵 정렬, 병합 정렬, 힙 정렬이 있습니다.  
**분산에 의한 정렬**은 레코드의 키값을 기준으로 파일을 구성하는 전체 레코드를 여러 개의 부분 집합으로
나눠 한 부분 집합 내에 속한 킷값이 다른 부분에 속한 크도록 만들어 정렬을 수행하는 방법입니다.  
해당하는 알고리즘으로는 퀵정렬, 병합 정렬, 힙 정렬, 기수 정렬이 있습니다.  

## 선택 정렬(Selection Sort)
: 정렬되지 않은 값들 중에서 최솟값을 찾고 정렬되지 않은 맨 앞 값과 위치를 스위칭하는 방식의 정렬 방식

시간 복잡도 : O(n^2)  

**장점**
- 자료의 이동 횟수가 N-1번으로 정해져 있다.

**단점**
- 값이 같은 레코드의 경우 상대적인 위치가 변경될 수 있다.

**과정**
![img](https://gmlwjd9405.github.io/images/algorithm-selection-sort/selection-sort.png)

**코드**
```
void selectionSort(int arr[], int size) {
    int minIndex;
    int i, j;
    for (i = 0; i < size - 1; i++) {
        minIndex = i;
        for (j = i + 1; j < size; j++) 
            if (arr[j] < arr[minIndex])
                minIndex = j;
         
        swap(&arr[i], &arr[minIndex]);
    }
}
```

---
## 거품 정렬(Bubble Sort)
: 이웃한 두 인덱스의 값을 비교하며 앞 인덱스의 값이 큰 경우 뒷 인덱스의 값과 스위칭하며 진행하는 정렬입니다.

시간 복잡도 : O(n^2)

**장점**
- 추가적인 메모리 소비가 작다.
- 구현이 매우 쉽다.

**단점**
- 다른 정렬 알고리즘에 비해 교환 과정이 많아 많은 시간을 소비한다.

**과정**
![img](https://i.imgur.com/cyCfguy.png)

**코드**
```
void bubbleSort(int arr[], int size) {
    int i, j;
    for (i = size - 1; i>0; i--) 
        for (j = 0; j<i; j++)="" if="" (arr[j]<arr[j="" +="" 1])="" swap(&arr[j],="" &arr[j="" 1]);="" }="" void="" insertionsort(int="" arr[],="" int="" size)="" {="" i,="" j,key;="" for="" (i="1;" i="" <="" size;="" i++)="" key="arr[i];" j="i" -="" 1;="" while="" (j="">= 0&&arr[j]>key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

---
## 삽입 정렬(Insertion Sort)
: 인덱스를 하나씩 증가시키면서 해당 인덱스보다 왼쪽의 인덱스들을 정렬해가는 알고리즘입니다.

시간 복잡도 : O(n^2)

**장점**
- 안정적인 정렬 방법입니다.
- 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있습니다.
- 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있습니다.

**단점**
- 비교적 스위칭 횟수가 많다.
- 레코드 수가 많고 레코드 크기가 클 경우 적합하지 않다.


**과정**
![img](http://dawoonjeong.com/assets/images/posts/2020/algorithm-insertionsort.png)

**코드**
```
void insertSort(int arr[], int size) {
    for(int i = 1; i < size; i++) {
			int target = arr[i];
			int j = i - 1;
			
			while(j >= 0 && target < arr[j]) {
				arr[i] = arr[j];
				j--;
			}
			
			arr[j + 1] = target;
	}
}
```

---
## 병합 정렬(Merge Sort)
: 처음에는 2개의 수를 비교할 수 있을 때까지 쪼개고 하나의 배열에 병합하며 정렬하는 알고리즘입니다.

시간 복잡도 : O(N * logN)

**장점**
- 퀵 정렬과 달리 기준값을 설정하는 과정없이 무조건 절반으로 분할하기에 기준값에 따라 성능이 달라지는 경우가 없다.
항상 O(N * logN)이라는 시간복잡도를 가지게 된다.

**단점**
- 합정렬은 임시배열에 원본맵을 계속해서 옮겨주며 정렬을 하는 방식이기에 추가적인 메모리가 필요하다.
- 데이터가 최악인 면을 고려하면 퀵 정렬보다는 병합정렬이 훨씬 빠르기 때문에 병합정렬을 사용한다.

**과정**

**코드**
```

```

---
## 퀵 정렬
: 기준값이라 불리는 피벗(Pivot)을 기준으로 왼쪽과 오른쪽을 나누는 알고리즘입니다.

시간 복잡도 : O(N * logN)

**장점**
- 다른 NlogN 알고리즘에 비해 대체적으로 속도가 매우 빠르다.
- merge sort에 비해 2~3배정도 빠르다.
- 추가적인 별도의 메모리를 필요로하지 않으며 재귀 호출 스택프레임에 의한 공간복잡도는 logN으로 메모리를 적게 소비한다.

**단점**
- 특정 조건하에 성능이 급격하게 떨어진다.
- 재귀를 사용하기 때문에 재귀를 사용하지 못하는 환경일 경우 그 구현이 매우 복잡해진다.

**과정**
![img](https://blog.kakaocdn.net/dn/chw02p/btq5beAEWDZ/tNBgPWfHLr4X4WQigxK4KK/img.png)


**코드**
```
    private static void l_pivot_sort(int[] a, int lo, int hi) {
		
		int pivot = partition(a, lo, hi);	
		
		l_pivot_sort(a, lo, pivot - 1);
		l_pivot_sort(a, pivot + 1, hi);
	}
	
	private static int partition(int[] a, int left, int right) {
		
		int lo = left;
		int hi = right;
		int pivot = a[left];
		
		while(lo < hi) {
			
			while(a[hi] > pivot && lo < hi) {
				hi--;
			}
			
			while(a[lo] <= pivot && lo < hi) {
				lo++;
			}
			
			// 교환 될 두 요소를 찾았으면 두 요소를 바꾼다.
			swap(a, lo, hi);
		}
		
		swap(a, left, lo);
		
		return lo;
	}
```

---
## 힙 정렬
: 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법으로 내림차순 정렬을 위해서는 최대 힙을 구성하고,
오름차순 정렬을 위해서는 최소 힙을 구성하는 방법입니다.

시간 복잡도 : O(N * logN)

**장점**
- 힙(heap)은 1차원 배열로 쉽게 구현될 수 있다.
- 추가적인 메모리를 필요로하지 않으면서 항상 O(N * logN)의 시간 복잡도를 가진다.


**단점**
- 이상적인 경우에 퀵정렬과 비교했을 때 똑같이 O(N * logN)이 나오긴 하나
실제 시간을 측정하면 퀵정렬보다 느리다고 한다.


**코드**
```

```

---
