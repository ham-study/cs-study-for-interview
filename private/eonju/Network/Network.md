## OSI 7계층과 TCP/IP 4계층

## TCP/UDP

- 전송층에 해당하는 프로토콜이다.
- TCP는 신뢰성 있는 통신을 하는 대신

### 3way-handshake, 4way-handshake

### 흐름제어, 혼잡제어, 오류제어

## IPv4 VS IPv6

# 예상 질문

1. OSI 7계층의 계층별 특징을 알려주세요.
    1. 물리 계층
        - 케이블, 리피터, 허브 등이 있다.
        - 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송
    2. 데이터 링크계층
        - 맥 주소를 가지고 통신
        - 브릿지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 전달함.
        - 신뢰성있는 전송을 보장하기 위한 계층
        - 프레임에 주소부여(MAC - 물리적주소)
    3. 네트워크 계층
        - 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)
        - 주소부여(IP), 경로설정(Route)
    4. 전송 계층
        - 패킷 생성 및 전송
        - TCP/UDP프로토콜을 사용
    5. 세션 계층
        - 데이터가 통신하기 위한 논리적인 연결
        - TCP/IP 세션을 만들고 없애는 책임
    6. 표현 계층
        - 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다.
    7. 응용 계층
        - 네트워크 소프트웨어 UI 부분, 사용자의 입출력(I/O)부분

2. TCP/IP 4계층의 계층별 특징을 알려주세요.
    - ![img](https://t1.daumcdn.net/cfile/tistory/99B268485C16E68331)
    - 1계층 - Network Access Layer
        - OSI 7 Layer에서 물리계층과 데이터링크 계층에 해당한다.
        - 하드웨어적인 요소와 관련되 는 모든 것을 지원하는 계층
    - 2계층 - Internet Layer
        - OSI 7 Layer의 네트워크 계층에 해당
        - IP 패킷을 전송하는 기능 및 라우팅 기능을 담당
    - 3계층 - Transport Layer
        - OSI 7 Layer에서 전송계층에 해당
        - 통신 노드 간의 연결을 제어하고, 자료의 송수신을 담당
    - 4계층 - Application Layer
        - 세션계층 , 프레젠테이션계층, 응용 계층에 해당
        - TCP/IP 기반의 응용 프로그램을 구분할 때 사용
3. OSI7계층과 TCP/IP 4계층을 비교해서 말씀해주세요.

4. TCP와 UDP에 대해 간략히 설명해주세요.
    - TCP
        - 양종단 호스트 내 프로세스 상호 간에 신뢰적인 연결지향성 서비스를 제공
    - UDP
        - 비연결성이고, 신뢰성이 없으며, 순서화되지 않은 Datagram 서비스 제공
        - 실시간 응용 및 멀티캐스팅 가능
        - 헤더가 단순함

5. TCP와 UDP의 차이점에 대해 설명해주세요.
    - TCP : 연결성, 신뢰성 있는, UDP에 비해 느림
    - UDP : 비연결성, 신뢰성 없는, 하지만 빠른

6. 3 way-handshake의 과정을 간단히 설명해주세요.

7. 4 way-handshake의 과정을 간단히 설명해주세요.

8. 3 way-handshake 와 4 way-handshake의 차이점은 무엇인가요?
    - 3 way-handshake는 TCP의 연결을 초기화 하기 위해 사용하고,
    - 4 way-handshake는 TCP의 세션을 종료하기 위해서 사용하는 것이다.

9. 흐름제어, 혼잡제어, 오류제어에 대해서 설명해주세요.

    - 흐름 제어 : 데이터 처리 속도 차이(흐름)을 제어하기 위한 기법
        1. Stop and Wait(정지 - 대기)
            - 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다.
            - 비효율적
        2. Sliding Window(슬라이딩 윈도우)
            - 윈도우 : 송신, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기
            - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법
    - 오류제어 : 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구
        1. Stop and Wait ARQ : 수신측에서 수신된 프레임의 에러 유무에 따라 ACK 혹은 NAK(Negative Acknowledgement)를 보내는 방식
        2. Go-Back-n ARQ : ACK 패킷의 손실로 인한 TIME_OUT이 발생한 경우, 확인된 마지막 프레임 이후로 모든 프레임을 재전송

    - 혼잡제어 : 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법
        1. AIMD(Additive Increase Multicative Decrease)
        2. Slow Start
10. IPv4는 어떤 형식으로 되어있나요?

11. IPv4와 IPv6의 차이점은 무엇인가요?
    ![img](https://user-images.githubusercontent.com/73349375/162369150-c1499d0a-15ba-4c86-ad0f-b7668348659c.png)

## HTTP

: 텍스트 기반의 통신 규약, 인터넷에서 데이터를 주고받을 수 있는 프로토콜

### HTTP status code

- 1XX - 서버에 연결된 클라이언트는 작업을 계속 진행하라는 의미입니다.
- 2XX - 성공적
- 3XX - Redirection messages
- 4XX : Client error responses
    - 404 : 서버는 요청받은 리소스를 찾을 수 없습니다.

### HTTP METHOD

## HTTP 1.1 VS HTTP 2.0

## HTTPS

## 예상질문

- HTTP에 대해서 설명해주세요.
    - HTTP는 텍스트 기반 통신 규약으로 인터넷에서 어떤 형식으로 통신할 것인지 정의해둔 통신 규약입니다.
    - 요청과 응답으로 구성되어있으며 각 요청과 응답은 별개로 진행됩니다. 따라서 세션이나 쿠키가 필요한 이유입니다.
    - 비연결성, 무상태성

- HTTP 요청 패킷 구조에 대해 설명해주세요.
    - 크게 StartLine, Blank Line, Header, Body로 이루어져있습니다.
        - StartLine에는 HTTP method, target URI, HTTP version이 명시되어있습니다.
        - Header에는 요청을 보내는 클라이언트의 정보, 컨텐츠 타입, 메세지의 길이 등이 명시되어있습니다.
        - Body에는 메세지가 포함되는데, GET 요청일 경우 body가 없는 경우가 많습니다.

- HTTP 응답의 구조에 대해 설명해주세요.
    - 크게 StartLine, Blank Line , Header, Body로 이루어져있습니다.
    - StartLine은 HTTP 버전, 응답 상태 코드, 응답 메세지로 구분되어있습니다.
    - Header에서는 응답으로 보내는 서버의 정보나 응답을 받는 클라이언트의 정보 등이 저장되어있습니다.
    - Body부분 또한 클라이언트가 받아야하는 데이터가 없는 경우 비어있을 수 있습니다.

- HTTP 상태코드 중 200 OK가 뜻하는 바는 무엇인가요?
    - 문제없이 다 잘 실행 되었을때 보내는 코드.

- HTTP 상태코드 중 301이 뜻하는 바는 무엇인가요?
    - 해당 URI가 다른 주소로 바뀌었을때 보내는 코드.

- HTTP 상태코드 중 400가 뜻하는 바는 무엇인가요?
    - 잘못된 요청이 들어온 경우 발생
    - 401
        - 인증 관련 에러
        - 유저가 해당 요청을 진행 할려면 먼저 로그인을 하거나 회원 가입을 하거나 등등이 필요하다는것을 나타내려 할때 쓰이는 코드.
    - 403
        - 인가 관련 에러
        - 유저가 해당 요청에 대한 권한이 없다는 뜻.
    - 404
        - 요청된 uri가 존재 하지 않는다는 뜻.

- HTTP 상태코드 중 500이 뜻하는 바는 무엇인가요?
    - 서버에서 에러가 났을때 사용되는 코드.

- HTTP 메소드 종류를 말씀해주시고 간단하게 설명해주세요
    - HTTP 메소드 종류에는 Post, Get, Put, Patch, Delete가 있습니다.
    - Post는 어떤 리소스를 생성할 때 주로 쓰입니다.
    - Get은 어떤 리소스를 받아올 때 주로 쓰입니다.
    - Put은 요청된 리소스의 내용을 현재 요청한 데이터로 전체를 수정해줍니다.
    - Patch는 요청된 리소스의 내용 중 일부만 수정할 때 사용합니다.
    - Delete는 요청된 리소스를 삭제하는데 사용합니다.

- HTTP 1.0과 HTTP 2.0의 차이점을 설명해주세요.
    - 1.0은 커넥션 하나당 요청 하나만 처리할 수 있음 -> 1.1에서는 커넥션의 유지시간을 정해 커넥션을 지속적으로 사용할 수 있습니다.
    - 1.1부터는 Pipelining을 지원합니다. 하지만 이 또한 첫번째 요청에 대해서 2번째 요청이 일찍 끝났음에도 불구하고 기다려야하는 상황이 발생하여 비효율적이게
      됩니다.
    - 2.0부터는 바이너리 프레이밍이라는 계층을 사용 -> 기존 텍스트 형식보다 파싱 속도 향상, 오류 발생 가능성 저하
    - 커넥션 당 데이터 스트림을 개별화하여 HOLB를 해결
    - 2.0부터는 순차적인 처리가 필요없어짐.

- HTTP와 HTTPS의 차이점이 무엇인가요?
    - HTTPS는 검색엔진 최적화가 적용되었습니다.
    - SSL 인증서를 통해 보안이 강화되었습니다.

## REST API

[참고](https://victorydntmd.tistory.com/286)

## Web Server VS WAS

1. Web Server
    - HTTP 기반으로 동작하는 서버로 주로 정적인 리소스를 제공합니다.(HTML, JS, 이미지, 영상 등)
    - ex) NGINX, APACHE
2. Web Application Server(WAS)
    - HTTP 기반으로 동작하는 서버로 WebServer의 역할도 수행합니다.
    - 프로그램 코드를 직접 실행해서 애플리케이션 로직을 수행할 수 있습니다. (동적 HTML, HTTP API, 서블릿, JSP, Spring MVC)
    - ex) Tomcat, Jetty, Undertow

3. Web Sever vs WAS
   - 주로 Web Server를 WAS 앞단에 두고 정적인 리소스는 Web Server가 담당하고,
   - WAS는 애플리케이션 로직을 수행하도록 설계한다.
   - 이유
     1. 안정적인 서비스를 위함
        - Web Server는 잘 안죽음, WAS는 잘 죽음.
        - 즉, WAS나 DB 장애 시 오류 화면을 띄울 수 있다.
     2. 효율적인 리소스 관리
        - 각 리소스가 필요한 것에 맞게 서버를 늘리면 된다.
## CORS

## COOKIE & SESSION

[참고](https://interconnection.tistory.com/74)

- 쿠키의 동작 방식 클라이언트가 페이지를 요청 서버에서 쿠키를 생성 HTTP 헤더에 쿠키를 포함 시켜 응답 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고
  있음 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에
  포함시켜 응답

- 세션의 동작 방식 클라이언트가 서버에 접속 시 세션 ID를 발급 받음 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음 클라리언트는 서버에 요청할 때, 이
  쿠키의 세션 ID를 같이 서버에 전달해서 요청 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져와서 사용 클라이언트 정보를 가지고
  서버 요청을 처리하여 클라이언트에게 응답

## JWT

[참고](https://tech.toktokhan.dev/2021/04/30/JWT/)

## 예상질문

1. API란 무엇인가요?
    - 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다.

2. REST API를 설계한다고 하는데 RESTful은 무엇을 의미할까요?
    - HTTP의 장점을 활용할 수 있는 아키텍처이다.
    - HTTP URI를 통해 자원을 명시하고
    - HTTP method를 통해
    - 해당 자원을 쓰고, 조회하고, 수정하고, 삭제하는 등을 하는 것을 의미합니다.
    - REST API는 서버와 클라이언트 구조로 되어있고,
    - 무상태성을 지닙니다.
3. REST API를 왜 사용했나요?? (=장점)
    - 서버와 클라이언트를 분리할 수 있다.
    - http 프로토콜을 잘 활용할 수 있다.

4. Web Server와 WAS의 차이점이 무엇인가요?
    - Web server는 정적인 페이지를 처리하고, WAS는 동적인 페이지를 처리합니다.

5. CORS가 무엇인가요?

6. CORS를 경험한 적이 있나요?

7. CORS를 어떻게 해결했나요?

8. 쿠키와 세션이 무엇인가요?
    - 먼저 쿠키와 세션은 HTTP의 비연결성과 무상태성으로 인해 사용합니다.
    - 쿠키는 클라이언트 측에서 보관하고 있는 정보입니다.
    - 반면 세션은 서버 측에서 보관하고 있는 정보입니다.

9. 쿠키와 세션을 사용하는 이유가 무엇인가요?
    - "connectionless, stateless"한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야합니다. 이 특성을 보완하기 위해서 쿠키와 세션을
      사용하게됩니다.

10. JWT가 무엇인가요?
    - Json Web Token 약자로 모바일이나 웹의 사용자 인증을 위해 사용하는 암호화된 토큰을 의미합니다.
    - URL에서 사용할 수 있도록 base64url 인코딩을 사용합니다.
    - 크게 세 파트로 구성되며, "."을 이용하여 구분해줍니다.
    - header 파트에는 토큰 타입과 알고리즘이 명시되어있습니다.
    - payload 파트는 토큰에 담을 정보(클레임)가 들어있습니다.
    - signature 파트에는 JWT 백엔드에서 발행된 서명이 들어있습니다.

11. JWT의 장점은 무엇인가요?

    - 기존 서버에 세션을 저장하는 방식에서 서버 여러대를 사용하여 요청을 분산하였다면 어떤 유저가 로그인했을 때 그 유저는 처음 로그인한 서버에만 요청을 내보내도록
      설정해야합니다. 하지만 토큰을 사용하면 토큰 값만 알고 있다면 어떤 서버로 요청이 들어가던 상관이 없습니다. 즉, 세션스토리지가 필요없다!

    - 보안성 쿠키를 전달하지 않아도 되므로 쿠키를 사용함으로써 발생하는 취약점이 사라집니다.
    - 여러 플랫폼 및 도메인 어플리케이션 규모가 커지면 여러 디바이스를 호환 시키고 더 많은 종류의 서비스를 제공합니다. 토큰을 사용한다면 그 어떤 디바이스에서도 그 어떤
      도메인에서도 토큰만 유효하다면 요청이 정상적으로 처리 됩니다.


10. JWT의 단점은 무엇인가요?

    - 길이 claim에 넣는 데이터가 많아질 수록 JWT토큰이 길어집니다. API호출 시 매 호출마다 토큰 데이터를 서버에 전달해야 하는데 길이가 길다는 것은 그만큼 네트워크
      대역폭 낭비가 심할 수 있습니다.

    - 보안 JWT는 기본적으로 Payload에 대한 정보를 암호화 하지 않습니다. 단순히 BASE64로 인코딩만 하기 때문에 중간에 패킷을 가로채거나 기타 방법으로 토큰을
      취득했으면 디코딩을 통해 데이터를 볼 수 있습니다. 그래서 JWE(JSON Web Encryption)를 통해 암호화 하거나 중요데이터를 Payload에 넣지 말아야
      합니다.

11. JWT의 동작은?

## 로드밸런서

[참고](https://deveric.tistory.com/91)
[참고](https://velog.io/@kimjiwonpg98/Nginx-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EA%B5%AC%EC%B6%95)
[참고](https://m.post.naver.com/viewer/postView.naver?volumeNo=27046347&memberNo=2521903)

## DNS

[참고](https://gentlysallim.com/dns%EB%9E%80-%EB%AD%90%EA%B3%A0-%EB%84%A4%EC%9E%84%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AD%94%EC%A7%80-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/)
[참고](https://steady-coding.tistory.com/523)

## Blocking/Nonblocking&Synchronous/Asynchronous

[참고](https://velog.io/@wonhee010/%EB%8F%99%EA%B8%B0vs%EB%B9%84%EB%8F%99%EA%B8%B0-feat.-blocking-vs-non-blocking)

## 웹 통신의 흐름

[참고](https://velog.io/@woo0_hooo/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%9D%90%EB%A6%84)

## URL

[참고](https://www.beusable.net/blog/?p=4507)

## 예상 질문

1. 로드밸런서가 무엇인가요?
    - 여러 대의 서버를 두고 서비스를 제공하는 분산 처리 시스템에서 필요한 기술
    - 증가한 트래픽을 대처하는 방식 중 scale-out에 해당 (scale-up : 서버 자체의 성능을 확장하는 것을 의미)

2. 로드밸런서가 왜 필요한가요?
    - 트래픽이 많을 경우 하나의 서버에 집중되면 서버가 과부하가 발생하여 다운될 수 있기 때문입니다.
    - 물론 트래픽을 분산할 방법으로는 Scale-up도 있습니다. 하지만 scale-up의 경우 해당 서버가 아무리 좋더라도 만약 장애가 발생하면 영향이 크기 때문입니다.
    - 하나의 서버가 장애가 나타나더라도 다른 서버는 그대로 동작하기 때문에 효과적입니다.

3. 로드밸런서가 서버를 선택하는 알고리즘 중 하나를 말하고 설명해주세요.
    - 라운드로빈 방식(Round Robin Method)  : 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식입니다.
    - 가중 라운드로빈 방식(Weighted Round Robin Method) : 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로
      배분합니다.
    - IP 해시 방식(IP Hash Method) : 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식입니다.
    - 최소 연결 방식(Least Connection Method) :  가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분합니다.
    - 최소 리스폰타임(Least Response Time Method) : 서버의 현재 연결 상태와 응답시간(Response Time, 서버에 요청을 보내고 최초 응답을 받을
      때까지 소요되는 시간)을 모두 고려하여 트래픽을 배분합니다.

4. L4 과 L7의 차이점을 알려주세요.

   ![img](https://post-phinf.pstatic.net/MjAxOTEyMTBfMTUx/MDAxNTc1OTU2NzEwMzMy.SekjHws4oCgNmCkjYoiZg_pfAlBu2yC66wPkLq0JHbsg.Zn9aLJYZX7rbdEL-X4HRkVO4PCgDNanhQntuR-iGBwkg.PNG/%EC%9B%B9_1920_%E2%80%93_1.png?type=w1200)

5. DNS가 무엇인가요?
    - 우리가 입력한 도메인 주소(www. naver .com)를 숫자인 IP 주소로 변환하는 과정이 필요한데 이것을 담당하는 시스템이 DNS입니다.
    - 길고 복잡한 IP 주소를 외울수가 없기 때문에 문자 주소를 사용하기 위해 DNS를 사용하게 됩니다.
    - ① 도메인 네임 스페이스 (Domain Name Space) : 최상위에 루트 DNS 서버가 존재하고 , 그 하위로 인터넷에 연결된 모든 노드가 연속해서 이어진
      계층구조로 구성
    - ② 네임 서버 (Name Server): 주소를 변환 시키기 위해 도메인 네임 스페이스의 트리구조에 대한 정보가 필요. 이 정보를 가진 서버 도메인 이름을 IP주소로
      변환하는 것을 네임 서비스
    - ③ 리졸버 (Resolver): DNS클라이언트의 요청을 네임 서버로 전달하고 네임 서버로부터 도메인이름과 IP 주소를 받아 클라이언트에게 제공하는 기능을 수행

6. DNS 서버가 어떻게 돌아가나요?
    1. DNS Query (Web Browser -> Local DNS) : "제가 원하는 웹 사이트의 IP 주소를 알고 계신가요?" Local DNS 서버에게 전달
    2. DNS Query (Local DNS-> Root DNS) : "제가 원하는 웹 사이트의 IP 주소를 알고 계신가요?" Root DNS서버에게 전달
    3. DNS Response (Root DNS->Local DNS) : "저는 모르지만 , Com 도메인을 관리하는 네임서버의 이름과 IP 주소를 알려드릴 테니 거기에
       물어보세요"
    4. DNS Query (Local DNS-> com NS) : “ 안녕하세요. www. naver. com의 IP 주소를 알고 계신가요?"
    5. DNS Response (com NS -> Local DNS) : "저는 모르지만 , naver.com 도메인을 관리하는 네임서버의 이름과 IP 주소를 알려드릴 테니
       거기에 물어보세요"
    6. DNS Query (Local DNS->naver.com NS) : “ 안녕하세요. www. Naver .com의 IP 주소를 알고 계신가요?"
    7. DNS Response (naver.com NS -> Local DNS) : "저는 모르지만 해당 웹은 www. g.naver. com이라는 이름으로 통해요.
       g.naver .com 도메인을 관리하는 네임서버의 이름과 IP 주소를 알려드릴테니 거기에 물어보세요"
    8. DNS Query (Local DNS -> g.naver.com NS) : “ 안녕하세요. www. g.naver. com의 IP 주소를 알고 계신가요?"
    9. DNS Response (g.naver .com NS -> Local DNS) : " 네 www. g.naver .com의 IP 주소는 222.222.222.22와
       333.333.333.33입니다"
    10. DNS Response (Local DNS -> Web Browser) : "네 www. naver .com의 IP 주소는 222.222.222.22와
        333.333.333.33입니다"

7. DNS 서버 종류가 어떤게 있나요?

8. DNS 서버를 여러 종류로 나누는 이유는?
    - 존재하는 도메인 수가 많기 때문에 하나의 DNS 서버만 사용한다면 성능, 유지 관리 등 많은 문제가 생긴다. 따라서 DNS 서버 종류를 계층화해 단계적으로 처리하여
      트래픽을 분산하고 유지 및 관리를 안정적으로 하기 위해 나누었다.

9. DNS는 왜 사용해야 하나요?

10. DNS 서버에게 IP 주소를 요청할 때 UDP를 사용하는 이유는?
    - DNS는 신뢰성보다 속도가 더 중요하고, 많은 클라이언트를 수용하는 것을 필요로 한다. 따라서 속도가 빠르고, 연결 상태를 유지하지 않고 정보 기록을 최소화하여 많은
      클라이언트 수용이 가능한 UDP를 사용한다.

11. 동기와 비동기를 각각 설명해주세요.

12. 웹 통신의 흐름을 DNS 서버와 연관지어 차례대로 설명해주세요.
    
