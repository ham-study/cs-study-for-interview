
* [Interface 🆚 Abstract class](#interface----abstract-class)
+ [Abstract class](#abstract-class)
+ [Interface](#interface)
+ [추상클래스 🆚 인터페이스](#--------------)
* [static](#static)
* [final](#final)
* [Generic](#generic)
  + [장점](#--)
* [synchronized](#synchronized)
  + [방법](#--)
* [stream, lambda](#stream--lambda)
  + [lambda](#lambda)
  + [함수형 인터페이스(Functional Interface)](#----------functional-interface-)
  + [stream](#stream)
* [Reflection](#reflection)

## Interface 🆚 Abstract class

### Abstract class

- 추상메서드를 선언해 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스
  - 선언부만 작성하는 추상메서드를 선언
- 상속을 위한 클래스이기 때문에 따로 객체를 생성할 수 없다.
- 목적 : 그 추상 클래스를 상속받아서 기능을 이용하고, 확장시키는 데 있다.
- 설계 : 달라질 가능성이 없는 부분에 대해서는 일반 메소드로 작성을 하고 달라질 가능성이 존재하는 메소드에 대해서는 추상 메소드로 정의를 해준다.

### Interface

- 일종의 추상 클래스로, 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아 몸통을 갖춘 일반 메서드나 멤버변수를 구성원으로 가질 수 없다.
- 사용 가능한 접근 제어자 : public, default
- 인터페이스 멤버들의 특징
  - 모든 멤버변수들은 public static final이어야 하며 이는 생략가능
  - 모든 메서드는 public abstract하며, 이는 생략 가능
    (jdk1.8부터 static 메서드와 디폴트 메서드도 허용)
  - 오로지 추상 메소드와 상수만을 포함할 수 있습니다.
- 인터페이스만 상속받을 수 있고, 클래스와 달리 다중상속이 가능하다.
- 인터페이스는 함수의 껍데기만 있는데, 그 이유는 그 함수의 구현을 강제하기 위해서 입니다.
- 상속하는 집합간에는 연관관계가 존재하지 않을 수 있습니다.

### 추상클래스 🆚 인터페이스

- 사용용도에 따라 차이가 있다.
  - 추상 클래스 : is-a 관계
  - 인터페이스 : is able 관계
  - **추상클래스와 달리 인터페이스는 구현하는 집합간에는 연관관계가 존재하지 않을 수 있다.**
- 공통된 기능 사용여부
  - 모든 클래스가 인터페이스를 사용해서 기본 틀을 구성한다면 공통으로 필요한 기능들도 모든 클래스에서 오버라이딩 하여 재정의 해야하는 번거로움이 있다.
  - 각각 다른 추상클래스를 상속하는데 공통된 기능이 필요하다면 해당 기능을 인터페이스로 작성해서 구현하는게 편하다.
  - 추상클래스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능까지 완변히 똑같은 기능이 필요한 경우
  - 인터페이스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용

## static

- 객체 생성 없이 사용할 수 있는 필드와 메소드를 생성하고자 할 때 활용되는 클래스 변수
- 메모리 공간에 하나만 존재하며, 어디서나 접근이 가능한 변수
  - 어디서나 접근이 가능하려면 static 변수도 public으로 선언되어야 한다.
  - 해당 데이터의 메모리 할당을 컴파일 시간에 할 것임을 의미하기 때문에 프로그램 실행~종료까지 메모리 수명이 유지
  - 런타임 중에 필요할 때마다 동적으로 할당 및 해제되는 동적 데이터와는 기능과 역할이 구분
- **공용 데이터**이거나 **인스턴스 필드를 포함하지 않는 메소드**를 선언하고자 할 때, 그리고 **유틸리티 함수**(상태를 가지고 있지 않는 클래스)를 만드는데 유용하게 사용
- static 변수는 인스턴스가 생성되기 전에 별도의 메모리 공간에 할당되어 초기화까지 완료된다. 초기화되는 시점은 JVM(Java Virtual Machin) 에 의해서 클래스가 메모리 공간에 올라가는 순간이다.
- “클래스이름.필드”로 사용
- 클래스의 인스턴스 없이 호출이 가능하며, 인스턴스에서는 호출 할 수 없다.
- 정적 메소드는 객체 참조 없이 바로 사용할 수 있는 특징 때문에 인스턴스 필드나 메소드, 그리고 this 키워드를 사용할 수 없다.
  - **인스턴스를 생성하지 않아도 static 메소드를 호출**할 수 있다.

    ```java
    public class PlusClass{
      static int field1 = 15;
      int field2;
    
      void method1(){}
      static void method2(){}
      static int plusMethod(int x, int y){
        this.field2 = 10; // <-- x
        this.method1(); // <-- x
        field1 = 10; // <-- o
        method2(); // <-- o
      } 
    }
    ```


> 👉**정적 팩토리 메서드**
>
> - 객체를 생성하는 역할을 분리하겠다는 취지로, 객체 생성의 역할을 하는 클래스 메서드를 말함
> - **장점**
    >     - 이름을 가질 수 있다.
>     - 호출할 때마다 새로운 객체를 생성할 필요가 없다.
>     - 하위 자료형 객체를 반환할 수 있다.
>     - 객체 생성을 캡슐화할 수 있다.
> - **단점**
    >     - 상속을 하려면 public이나 protected 생성자여야 하므로 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.
>     - 정적 팩토리 메서드는 프로그래머가 찾기 힘들다.

## final

- 해당 변수는 값이 저장되면 최종적인 값이 되므로, 수정이 불가능하다는 의미
  - 상수 : 상수에 언제든 값을 한번 저장하고 다음에 다시 바꾸지 않을때 사용
  - 메서드 : 오버라이딩(재정의)을 못하게 만든다.
  - 클래스 : 상속을 못하게 만든다.
- 선언과 동시에 값을 주는 방법, 객체를 생성할 때 생성자를 통해 값을 주는 방법이 있다.

| static | 객체마다 가질 필요가 없는 공용으로 사용하는 필드 혹은 인스턴스 필드를 포함하지 않는 메소드 |
| --- | --- |
| final | 한 번 값이 정해지고 나면 값을 바꿀 수 없는 필드 |
| static final | 모든 영역에서 고정된 값으로 사용하는 상수 |

> 👉**final** 🆚 **static final**
>
> - final
    >     - 한 번만 초기화 가능하다
>     - final 변수는 인스턴스 내에서는 변하지 않지만 인스턴스마다 다른 값을 가질 수 있다
>     - 클래스 내에서 통용되는 상수가 될 수 없다.
>     - spring에선 인스턴스마다 다른 final 멤버 변수를 생성자에서 초기화시키는 식으로 사용
> - static final
    >     - 클래스 내부 또는 외부에서 참조의 용도로만 선언된 변수
>     - 객체(인스턴스)가 아닌 클래스에 존재하는 단 하나의 상수
>     - 객체마다 값이 바뀌는 것이 아닌 클래스에 존재하는 상수이므로 선언과 동시에 초기화를 해 주어야하는 클래스 상수
>     - 다 같은 값을 가질 데이터를 위해 인스턴스 생성마다 매번 같은 메모리를 잡는 것보다 더 효율적이고 동시성 문제도 없다

## Generic

- 데이터 형식에 의존하지 않고, **하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법**
- 클래스 내부에서 지정하는 것이 아닌 **외부에서 사용자에 의해 지정되는 것**
- 제네릭 타입은 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서 **컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환**된다.
- 타입 변수 자리에 사용할 실제 타입을 명시할 때 기본 타입을 바로 사용할 수는 없다.
  (**Wrapper class 사용**)

### 장점

- 제네릭을 사용하면 **잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다**.
- 클래스 외부에서 타입을 지정해주기 때문에 **따로 타입을 체크하고 변환해줄 필요가 없다**.
  (관리하기가 편하다.)
- 비슷한 기능을 지원하는 경우 **코드의 재사용성이 높아진다**.

> 👉**와일드카드**
>
> - 경계가 지정되고 K는 특정 타입으로 지정이 되지만, ?는 타입이 지정되지 않는다는 의미
>
> ```java
> <K extends T>	// T와 T의 자손 타입만 가능 (K는 들어오는 타입으로 지정 됨)
> <K super T>	// T와 T의 부모(조상) 타입만 가능 (K는 들어오는 타입으로 지정 됨)
>  
> <? extends T>	// T와 T의 자손 타입만 가능
> <? super T>	// T와 T의 부모(조상) 타입만 가능
> <?>		// 모든 타입 가능. <? extends Object>랑 같은 의미
> ```
>

## synchronized

- 공유 데이터에 lock을 걸어서 먼저 작업 중이던 쓰레드가 작업을 완전히 끝낼 때까지는 다른 쓰레드에게 제어권이 넘어가더라도 데이터가 변경되지 않도록 보호한다.

### 방법

- **메서드에 synchronized 하기**
  - 인스턴스 메서드의 동기화는 이 메서드를 가진 인스턴스를 기준으로 이루어진다.
  - 한 클래스에 synchronized를 사용한 메서드를 가진다면, 여기서 동기화는 인스턴스를 기준으로 이루어진다.
  - 오직 하나의 Thread 만이 동기화된 인스턴스 메서드를 실행할 수 있다.
  - synchronized를 사용한 메서드가 존재한다면 인스턴스당 한 개의 Thread만이 접근할 수 있다. (**그 함수가 포함된 객체(this)가 lock이 걸린 것.**)
- **블록에 synchronized 하기**
  - 동기화 블록은 메서드 안의 특정 부분을 동기화할 수 있다.
  - 락 객체는 자기 자신 객체를 의미하는 this 키워드를 사용할 수도 있지만 다른 객체를 락으로 사용할 수 있다.
    - 단, 락 객체가 여러 개라면 우리가 원하는 동기화 작업을 제대로 실행할 수 없다.
    - 그래서 보통은 락 객체를 하나만 사용하는 경우가 많다.
  - 동기화 블록을 사용하는 경우, 해당 메서드는 여러 스레드가 동시에 점유할 수 있다.
    - 하지만 동기화된 블록에 이르면 락 객체에 의해서 모든 스레드들은 실행을 중단하고 자신의 차례가 될 때까지 대기한다.

> 👉**동기화 방법**
>
> - synchronized, volatile, Atomic 클래스
> - // Todo

## stream, lambda

### lambda

- 함수를 하나의 식(expression)으로 표현한 것
- 메소드의 이름이 필요 없기 때문에, 람다식은 익명 함수(Anonymous Function)의 한 종류
- **람다식(Lambda Expression) 의 특징**
  - 람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
  - 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.
- **람다식(Lambda Expression) 의 장점**
  - 코드를 간결하게 만들 수 있다.
  - 식에 개발자의 의도가 명확히 드러나 가독성이 높아진다.
  - 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.
  - 병렬프로그래밍이 용이하다.
- **람다식(Lambda Expression) 의 단점**
  - 람다를 사용하면서 만든 무명함수는 재사용이 불가능하다.
  - 디버깅이 어렵다.
  - 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
  - 재귀로 만들경우에 부적합하다.

### 함수형 인터페이스(Functional Interface)

함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션으로, 인터페이스에 선언하여 단 하나의 추상 메소드만을 갖도록 제한하는 역할을 한다.

함수형 인터페이스를 사용하는 이유는 Java의 람다식이 함수형 인터페이스를 반환하기 때문이다.

함수를 변수처럼 선언할 수 있게 되었고, 코드 역시 간결하게 작성할 수 있게 되었다. 함수형 인터페이스를 구현하기 위해서는 인터페이스를 개발하여 그 내부에는 1개 뿐인 abstract 함수를 선언하고, 위에는 @FunctionalInterface 어노테이션을 붙여주면 된다.

### stream

1. **Stream API의 특징**

- 원본의 데이터를 변경하지 않는다.
- 일회용이다.
- 내부 반복으로 작업을 처리한다.
- Stream연산들은 매개변수로 함수형 인터페이스(Functional Interface)를 받도록 되어있다.

## Reflection

- 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법
- 클래스, 인터페이스, 메소드들을 찾을 수 있고, 객체를 생성하거나 변수를 변경할 수 있고 메소드를 호출할 수도 있습니다.
- **구체적인 클래스 타입을 알지 못해도** 그 클래스의 정보(메서드, 타입, 변수 등등)에 접근할 수 있게 해주는 자바 API
- 자바에서는 JVM이 실행되면 사용자가 작성한 자바 코드가 컴파일러를 거쳐 바이트 코드로 변환되어 static 영역에 저장된다. Reflection API는 이 정보를 활용한다. 그래서 클래스 이름만 알고 있다면 언제든 static 영역을 뒤져서 정보를 가져올 수 있는 것이다.

---

> 🔗 **참고**
>
> - [https://myjamong.tistory.com/150](https://myjamong.tistory.com/150)
> - [https://gobae.tistory.com/3](https://gobae.tistory.com/3)
> - [https://devlog-wjdrbs96.tistory.com/370](https://devlog-wjdrbs96.tistory.com/370)
> - [https://brunch.co.kr/@kd4/6](https://brunch.co.kr/@kd4/6)
> - [http://www.tcpschool.com/java/](http://www.tcpschool.com/java/java_polymorphism_interface)
> - [https://asfirstalways.tistory.com/165](https://asfirstalways.tistory.com/165)
> - [https://blog.naver.com/goddlaek/220889229659](https://blog.naver.com/goddlaek/220889229659)
> - [https://devlogofchris.tistory.com/43](https://devlogofchris.tistory.com/43)
> - [https://djkeh.github.io/articles/Why-should-final-member-variables-be-conventionally-static-in-Java-kor/](https://djkeh.github.io/articles/Why-should-final-member-variables-be-conventionally-static-in-Java-kor/)
> - [https://mygumi.tistory.com/253](https://mygumi.tistory.com/253)
> - [https://velog.io/@ljinsk3/정적-팩토리-메서드는-왜-사용할까](https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C)
> - [https://st-lab.tistory.com/153](https://st-lab.tistory.com/153)
> - [https://ktko.tistory.com/entry/자바-synchronized에-대하여](https://ktko.tistory.com/entry/%EC%9E%90%EB%B0%94-synchronized%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)