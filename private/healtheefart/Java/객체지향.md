## 객체지향의 특징

### 1️⃣캡슐화

- 객체지향의 캡슐화(정보은닉)는 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉하는 것
- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야한다.
- 정적멤버의 접근방법 : 정적 멤버(static)는 클래스명.정적멤버 형식으로 접근하는 것을 권장
- 기본 자료형 변수는 값을 값 자체로 판단한다.
- 참조 자료형 변수는 값을 주소(포인터)로 판단한다.

### 2️⃣상속

- 객체지향의 상속은 상위 클래스의 특성을 재사용, 확장하는 것이다.
    - 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가(확장)해 사용할 수 있다는 의미
- 상속은 “하위 클래스는 상위 클래스의 한 분류이다”(is a kind of) 관계를 만족한다.
- 상속의 예시
    - 포유류(하위 클래스)는 동물(상위 클래스)의 한 분류이다.
    - 계층의 개념이 아닌 분류, (부분)집합의 개념

> **👉 자바는 다중상속을 지원하지 않는다.**
>
> - 다중상속의 예시 : **사람**이기도 하면서 **물고기**이기도 한 **인어**
> - 다중상속의 다이아몬드 문제 : 사람 & 물고기의 행동 중 ‘수영’을 인어는 사람처럼 수영해야하나, 물고기처럼 헤엄쳐야하나
>
> ⇒ 자바는 C++을 계승/발전/단순화하면서 다중 상속을 빼고 인터페이스를 도입
>

> 👉 **상속과 인터페이스**
>
> - 인터페이스 : 구현 클래스 is able to 인터페이스
> - 자바 API에서의 인터페이스
    >     - Serializable : 직력화 가능
>     - Cloneable : 복제 가능
>     - Comparable : 비교 가능
>     - Runnable : 실행 가능
>
> ⇒ 상위 클래스는 물려줄 특성이 많으면 많을 수록(LSP), 인터페이스는 구현을 강제할 메서드 개수가 적을 수록(ISP) 좋다
>

### 3️⃣추상화

- 자바는 **class 키워드를 통해 객체 지향의 추상화를 지원**하고 있다.
- 구체적인 것을 분해해 관심 영역(어플리케이션 경계)에 있는 특성만 가지고 재조합하는 것
  (= 모델링)
- 클래스 = 같은 특성을 지닌 여러 객체를 총칭하는 집합(객체지향에서 추상화의 결과)
- 객체 = 유일무이한 사물/실체
- 모델 = 목적에 맞게 관심있는 특성만 추출해 표현하는 것(클래스 설계, DB 테이블 설계에 필요)
- **추상화 예시**
  
| Application Boundary | 병원 application                             | 은행 application                                  |
|----------------------|--------------------------------------------|-------------------------------------------------|
| 사람(클래스)              | 사람 = 환자                                    | 사람 = 고객                                         |
| 클래스 모델링              | ```class 환자 {나이, 시력, 몸무게, 혈액형 / 먹다, 자다}``` | ```class 고객 {나이, 연봉, 직업 / 일하다, 출금하다, 입금하다 } ``` |

### 4️⃣다형성

- 객체지향에서의 다형성 = 오버라이딩과 오버로딩
    - **오버라이딩** : 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드 **재정의**
    - **오버로딩** : 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 **중복 정의**
- 👍**장점**
    - 유지보수가 쉬워진다.
    - 재사용성이 증가한다.
    - 결합도가 낮아져 안전성이 높아진다

## 객체지향의 5원칙 (SOLID)

### 1️⃣SRP(Single Responsibility Principle)

- 단일책임원칙 ≒ 추상화
- **어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.**
- 클래스 하나가 가지는 역할(책임)이 많을 경우 역할을 분리하라
  (속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등도 마찬가지)

### 2️⃣OCP(Open Closed Principle)

- 개방-폐쇄 원칙
- **SW 엔티티는 확장에 대해서는 열려있고 변경에 대해서는 닫혀있어야 한다.**
  (자신의 확장에는 열려있고, 주변의 변화에 대해선 닫혀있어야 한다.)
- OCP의 예제 : JDBC 인터페이스는 DB를 바꿔도 각 DB에 따라 JDBC 구현한 JDBC 드라이버들이 여러 개 있기 때문에 connection 설정 이외에 수정할 부분이 없다.

### 3️⃣LSP(Liskov Substitution Principle)

- 리스코프 치환법칙
- **서브 타입은 언제나 자신의 base type으로 교체할 수 있어야 한다.**
- 계층/조직도는 LSP를 위반하고, 분류도는 만족한다.

### 4️⃣ISP(Interface Segregation Principle)

- 인터페이스 분리 원칙
- **클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안 된다.**

> **👉 SRP와 ISP**
>
> - 남자 > 아들, 사원, 남자친구의 역할
    >     - SRP의 해결= 아들 class, 사원 class, 남자친구 class
>     - ISP의 해결= 아들 interface, 사원 interface, 남자친구 interface
> - **특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책**
    >     - 인터페이스 최소주의 원칙 **:** 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라

### 5️⃣DIP(Dependency Inversion Principle)

- 의존 역전 원칙
- **고차원 모듈은 저차원 모듈에 의존하면 안 된다. 둘 다 다른 추상화된 것에 의존해야 한다.**
- **추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.**
- **자주 변경되는 구체 클래스에 의존하지 마라**
- 자주 변경되는 구체 클래스에 의존한다면 중간에 추상적인 인터페이스나 상위 클래스를 두어 그 인터페이스나 상위클래스에 구체 클래스가 의존하게 한다면 의존 역전이 일어나면서,
  **자주 변경되는 구체클래스의 변경에 영향을 받지 않는다.**

## 절차지향 vs 객체지향 vs 함수형 프로그래밍

### 1️⃣절차지향 프로그래밍

- 일이 진행되는 순서대로 프로그래밍 하는 방법
- 👍**장점**
    - 코드의 가독성이 좋다.
    - 컴퓨터 처리구조와 비슷해 실행속도가 빠르다
- 👎**단점**
    - 각각의 코드가 순서에 민감히 연결돼있어 유지보수와 분석이 어렵다

### 2️⃣객체지향 프로그래밍

- 모든 데이터를 **객체(Object)**로 취급하고, 객체가 처리 요청을 받았을 때, 객체 내부에 있는 기능을 사용해 처리하는 방법
- 서로 연관되어있는 함수와 변수들을 객체라는 것으로 그룹핑하고, 그 객체에 들어있는 함수들을 호출해서 다른 함수들과 분리/구분해줌.
- 객체지향 프로그래밍 언어: Java, 스몰토크
- 👍**장점**
    - 코드의 재사용이 가능해 확장이나 유지보수에 좋다.
    - 분석과 설계의 전환이 쉽다.
- 👎**단점**
    - 처리 속도가 상대적으로 느리다
    - 설계에 많은 시간이 소요된다.

### 3️⃣함수형 프로그래밍

- 순수 함수를 사용해 상태를 제어하기보다는 빨리 처리하는데 초점을 둔 방법

  > ❓**순수함수란**
  >
  > - 동일한 값을 넣었을 때 항상 동일한 리턴값을 반환하며 외부에 영향을 받지않는 함수
  > - 함수의 실행이 프로그램에 영향을 주지 않으며, 비상태 불변성을 유지한다.
      > (전달된 데이터를 변경하는 것이 아니라, 새로운 버전 or 오브젝트를 만들어 결과값으로 전달해야함)
  > - 동시다발적인 멀티쓰레딩 환경에서도 안정적으로 동작한다.
- 실행순서를 지정할 필요가 없기 때문에 비절차형 언어라고도 함
- 함수형 프로그래밍 언어 : Haskell 등 / C++, Python, JS, Java 언어의 최신버전에 함수형 프로그래밍 특징들이 더해짐
- 👍**장점**
    - 함수의 동작부가 간결해지기 때문에, 객체지향에 비해 코드 이해도와 가독성이 좋다.
    - 테스트가 쉽다.
- 👎**단점**
    - 외부 데이터 or 내부 데이터의 상태를 조작할 수 없다.

### 4️⃣절차지향 vs 객체지향

- 절차형 프로그래밍의 단점을 객체지향 프로그래밍이 보완하여 생겨남
- 절차형 프로그래밍은 함수가 있고, 객체지향 프로그래밍은 여기에 객체라는 개념이 더해짐

### 5️⃣함수형 vs 객체지향

- 함수형 프로그래밍에서는 함수(Function) 자체가 일급 객체가 되지만, 객체지향 프로그래밍에서는 클래스(또는 객체, Object)가 일급 객체가 됨.

  > ❓**일급객체란**
  >
  > - 다른 요소들과 아무런 차별이 없는 객체.
      > 즉, 함수의 인자로도 넘겨질 수 있고, 변수에 대입도 가능한 객체를 일급 객체.
  > - 모든 일급 객체는 함수의 실질적인 매개변수가 될 수 있다.
  > - 모든 일급 객체는 함수의 반환값이 될 수 있다.
  > - 모든 일급 객체는 할당의 대상이 될 수 있다.
  > - 모든 일급 객체는 비교 연산(==, equal)을 적용할 수 있다.
- 객체지향 프로그래밍에서는 프로그램을 **상호작용하는 객체들의 집합**으로 볼 수 있지만,
  함수형 프로그래밍에서는 **상태 값을 지니지 않는 함수들의 연속**으로 볼 수 있음.
    - 객체지향
        - 클래스 디자인과 객체들의 관계를 중심으로 코드 작성이 이루어짐.
        - 따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있음.
          (특히, 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라짐.)
    - 함수형
        - 값의 연산 및 결과 도출 중심으로 코드작성이 이루어짐.
        - 함수는 인자로 받은 값을 별도로 저장하지 않고, 간결한 과정으로 처리하고 매핑하는데에 주 목적을 둠.

---

> 🔗**참고**
>
> - 스프링 입문을 위한 자바 객체 지향의 원리와 이해
> - [https://velog.io/@majaeh43/절차지향-객체지향-함수형-프로그래밍](https://velog.io/@majaeh43/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)